// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

"use strict";

// @ts-nocheck
/* eslint-disable */
let System, __instantiate;
(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    },
  };
  async function dI(mid, src) {
    let id = mid.replace(/\.\w+$/i, "");
    if (id.includes("./")) {
      const [o, ...ia] = id.split("/").reverse(),
        [, ...sa] = src.split("/").reverse(),
        oa = [o];
      let s = 0,
        i;
      while ((i = ia.shift())) {
        if (i === "..") s++;
        else if (i === ".") break;
        else oa.push(i);
      }
      if (s < sa.length) oa.push(...sa.slice(s));
      id = oa.reverse().join("/");
    }
    return r.has(id) ? gExpA(id) : import(mid);
  }

  function gC(id, main) {
    return {
      id,
      import: (m) => dI(m, id),
      meta: { url: id, main },
    };
  }

  function gE(exp) {
    return (id, v) => {
      v = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(v)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true,
        });
      }
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }
  __instantiate = (m, a) => {
    System = __instantiate = undefined;
    rF(m);
    return a ? gExpA(m) : gExp(m);
  };
})();

"use strict";
System.register("https://deno.land/std@0.67.0/bytes/mod", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_1("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_1("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_1("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_1("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_1("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_1("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_1("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_1("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_1("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/sha1", [], function (exports_2, context_2) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, blocks, Sha1;
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            blocks = [];
            Sha1 = class Sha1 {
                constructor(sharedMemory = false) {
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#lastByteIndex = 0;
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                #blocks;
                #block;
                #start;
                #bytes;
                #hBytes;
                #finalized;
                #hashed;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #lastByteIndex;
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) >>> 0;
                        this.#bytes = this.#bytes >>> 0;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f;
                    let j;
                    let t;
                    const blocks = this.#blocks;
                    for (j = 16; j < 80; ++j) {
                        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                        blocks[j] = (t << 1) | (t >>> 31);
                    }
                    for (j = 0; j < 20; j += 5) {
                        f = (b & c) | (~b & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1518500249 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (~a & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1518500249 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (~e & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1518500249 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (~d & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1518500249 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (~c & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1518500249 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 40; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1859775393 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1859775393 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1859775393 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1859775393 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1859775393 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 60; j += 5) {
                        f = (b & c) | (b & d) | (c & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 1894007588 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (a & c) | (b & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 1894007588 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (e & b) | (a & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 1894007588 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (d & a) | (e & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 1894007588 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (c & e) | (d & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 1894007588 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 80; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 899497514 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 899497514 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 899497514 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 899497514 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 899497514 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    this.#h0 = (this.#h0 + a) >>> 0;
                    this.#h1 = (this.#h1 + b) >>> 0;
                    this.#h2 = (this.#h2 + c) >>> 0;
                    this.#h3 = (this.#h3 + d) >>> 0;
                    this.#h4 = (this.#h4 + e) >>> 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return (HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f]);
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                    ];
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(20);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    return buffer;
                }
            };
            exports_2("Sha1", Sha1);
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/sha256", [], function (exports_3, context_3) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^
                            (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 = ((a >>> 2) | (a << 30)) ^
                                ((a >>> 13) | (a << 19)) ^
                                ((a >>> 22) | (a << 10));
                            s1 = ((e >>> 6) | (e << 26)) ^
                                ((e >>> 11) | (e << 21)) ^
                                ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 = ((d >>> 2) | (d << 30)) ^
                            ((d >>> 13) | (d << 19)) ^
                            ((d >>> 22) | (d << 10));
                        s1 = ((h >>> 6) | (h << 26)) ^
                            ((h >>> 11) | (h << 21)) ^
                            ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 = ((c >>> 2) | (c << 30)) ^
                            ((c >>> 13) | (c << 19)) ^
                            ((c >>> 22) | (c << 10));
                        s1 = ((g >>> 6) | (g << 26)) ^
                            ((g >>> 11) | (g << 21)) ^
                            ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 = ((b >>> 2) | (b << 30)) ^
                            ((b >>> 13) | (b << 19)) ^
                            ((b >>> 22) | (b << 10));
                        s1 = ((f >>> 6) | (f << 26)) ^
                            ((f >>> 11) | (f << 21)) ^
                            ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex += HEX_CHARS[(h7 >> 28) & 0x0f] +
                            HEX_CHARS[(h7 >> 24) & 0x0f] +
                            HEX_CHARS[(h7 >> 20) & 0x0f] +
                            HEX_CHARS[(h7 >> 16) & 0x0f] +
                            HEX_CHARS[(h7 >> 12) & 0x0f] +
                            HEX_CHARS[(h7 >> 8) & 0x0f] +
                            HEX_CHARS[(h7 >> 4) & 0x0f] +
                            HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_3("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code = 0x10000 +
                                    (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_3("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.67.0/encoding/utf8", [], function (exports_4, context_4) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_4 && context_4.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_4("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_4("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_4("encoder", encoder = new TextEncoder());
            exports_4("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.67.0/_util/assert", [], function (exports_5, context_5) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_5 && context_5.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_5("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_5("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.67.0/io/bufio", ["https://deno.land/std@0.67.0/bytes/mod", "https://deno.land/std@0.67.0/_util/assert"], function (exports_6, context_6) {
    "use strict";
    var mod_ts_1, assert_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_6 && context_6.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_6("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_6("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_6("readLines", readLines);
    return {
        setters: [
            function (mod_ts_1_1) {
                mod_ts_1 = mod_ts_1_1;
            },
            function (assert_ts_1_1) {
                assert_ts_1 = assert_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_6("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_6("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_1.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_1.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_1.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_1.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_6("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_6("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_6("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.67.0/async/deferred", [], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_7("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/async/delay", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_8("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/async/mux_async_iterator", ["https://deno.land/std@0.67.0/async/deferred"], function (exports_9, context_9) {
    "use strict";
    var deferred_ts_1, MuxAsyncIterator;
    var __moduleName = context_9 && context_9.id;
    return {
        setters: [
            function (deferred_ts_1_1) {
                deferred_ts_1 = deferred_ts_1_1;
            }
        ],
        execute: function () {
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.throws = [];
                    this.signal = deferred_ts_1.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    try {
                        const { value, done } = await iterator.next();
                        if (done) {
                            --this.iteratorCount;
                        }
                        else {
                            this.yields.push({ iterator, value });
                        }
                    }
                    catch (e) {
                        this.throws.push(e);
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        await this.signal;
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        if (this.throws.length) {
                            for (const e of this.throws) {
                                throw e;
                            }
                            this.throws.length = 0;
                        }
                        this.yields.length = 0;
                        this.signal = deferred_ts_1.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_9("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.67.0/async/pool", [], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    function pooledMap(poolLimit, array, iteratorFn) {
        const res = new TransformStream({
            async transform(p, controller) {
                controller.enqueue(await p);
            },
        });
        (async () => {
            const writer = res.writable.getWriter();
            const executing = [];
            for await (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                writer.write(p);
                const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                executing.push(e);
                if (executing.length >= poolLimit) {
                    await Promise.race(executing);
                }
            }
            await Promise.all(executing);
            writer.close();
        })();
        return res.readable.getIterator();
    }
    exports_10("pooledMap", pooledMap);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/async/mod", ["https://deno.land/std@0.67.0/async/deferred", "https://deno.land/std@0.67.0/async/delay", "https://deno.land/std@0.67.0/async/mux_async_iterator", "https://deno.land/std@0.67.0/async/pool"], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_11(exports);
    }
    return {
        setters: [
            function (deferred_ts_2_1) {
                exportStar_1(deferred_ts_2_1);
            },
            function (delay_ts_1_1) {
                exportStar_1(delay_ts_1_1);
            },
            function (mux_async_iterator_ts_1_1) {
                exportStar_1(mux_async_iterator_ts_1_1);
            },
            function (pool_ts_1_1) {
                exportStar_1(pool_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/textproto/mod", ["https://deno.land/std@0.67.0/bytes/mod", "https://deno.land/std@0.67.0/encoding/utf8"], function (exports_12, context_12) {
    "use strict";
    var mod_ts_2, utf8_ts_1, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_12 && context_12.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_1.decode(buf);
        }
    }
    function charCode(s) {
        return s.charCodeAt(0);
    }
    return {
        setters: [
            function (mod_ts_2_1) {
                mod_ts_2 = mod_ts_2_1;
            },
            function (utf8_ts_1_1) {
                utf8_ts_1 = utf8_ts_1_1;
            }
        ],
        execute: function () {
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice();
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        let i = kv.indexOf(charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        const key = str(kv.subarray(0, i));
                        if (key == "") {
                            continue;
                        }
                        i++;
                        while (i < kv.byteLength &&
                            (kv[i] == charCode(" ") || kv[i] == charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        try {
                            m.append(key, value);
                        }
                        catch {
                        }
                    }
                }
                async readLineSlice() {
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        if (!line && !more) {
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_2.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === charCode(" ") || l[i] === charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_12("TextProtoReader", TextProtoReader);
        }
    };
});
System.register("https://deno.land/std@0.67.0/http/http_status", [], function (exports_13, context_13) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [],
        execute: function () {
            (function (Status) {
                Status[Status["Continue"] = 100] = "Continue";
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                Status[Status["Processing"] = 102] = "Processing";
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                Status[Status["OK"] = 200] = "OK";
                Status[Status["Created"] = 201] = "Created";
                Status[Status["Accepted"] = 202] = "Accepted";
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                Status[Status["NoContent"] = 204] = "NoContent";
                Status[Status["ResetContent"] = 205] = "ResetContent";
                Status[Status["PartialContent"] = 206] = "PartialContent";
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                Status[Status["IMUsed"] = 226] = "IMUsed";
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                Status[Status["Found"] = 302] = "Found";
                Status[Status["SeeOther"] = 303] = "SeeOther";
                Status[Status["NotModified"] = 304] = "NotModified";
                Status[Status["UseProxy"] = 305] = "UseProxy";
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                Status[Status["BadRequest"] = 400] = "BadRequest";
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                Status[Status["Forbidden"] = 403] = "Forbidden";
                Status[Status["NotFound"] = 404] = "NotFound";
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                Status[Status["Conflict"] = 409] = "Conflict";
                Status[Status["Gone"] = 410] = "Gone";
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                Status[Status["Teapot"] = 418] = "Teapot";
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                Status[Status["Locked"] = 423] = "Locked";
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                Status[Status["TooEarly"] = 425] = "TooEarly";
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                Status[Status["BadGateway"] = 502] = "BadGateway";
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                Status[Status["NotExtended"] = 510] = "NotExtended";
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_13("Status", Status);
            exports_13("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.67.0/http/_io", ["https://deno.land/std@0.67.0/io/bufio", "https://deno.land/std@0.67.0/textproto/mod", "https://deno.land/std@0.67.0/_util/assert", "https://deno.land/std@0.67.0/encoding/utf8", "https://deno.land/std@0.67.0/http/server", "https://deno.land/std@0.67.0/http/http_status"], function (exports_14, context_14) {
    "use strict";
    var bufio_ts_1, mod_ts_3, assert_ts_2, utf8_ts_2, server_ts_1, http_status_ts_1;
    var __moduleName = context_14 && context_14.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_14("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_14("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        const tp = new mod_ts_3.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_2.assert(chunkSize === 0);
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_14("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_3.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_14("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_1.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_2.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_2.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_2.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_14("writeChunkedBody", writeChunkedBody);
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_1.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_2.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_2.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_14("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_1.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_1.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_2.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_2.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_2.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_2.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_2.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_2.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_14("writeResponse", writeResponse);
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_14("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_3.TextProtoReader(bufr);
        const firstLine = await tp.readLine();
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_1.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_14("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_1_1) {
                bufio_ts_1 = bufio_ts_1_1;
            },
            function (mod_ts_3_1) {
                mod_ts_3 = mod_ts_3_1;
            },
            function (assert_ts_2_1) {
                assert_ts_2 = assert_ts_2_1;
            },
            function (utf8_ts_2_1) {
                utf8_ts_2 = utf8_ts_2_1;
            },
            function (server_ts_1_1) {
                server_ts_1 = server_ts_1_1;
            },
            function (http_status_ts_1_1) {
                http_status_ts_1 = http_status_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/http/server", ["https://deno.land/std@0.67.0/encoding/utf8", "https://deno.land/std@0.67.0/io/bufio", "https://deno.land/std@0.67.0/_util/assert", "https://deno.land/std@0.67.0/async/mod", "https://deno.land/std@0.67.0/http/_io"], function (exports_15, context_15) {
    "use strict";
    var utf8_ts_3, bufio_ts_2, assert_ts_3, mod_ts_4, _io_ts_1, ServerRequest, Server;
    var __moduleName = context_15 && context_15.id;
    function _parseAddrFromStr(addr) {
        let url;
        try {
            const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
            url = new URL(`http://${host}`);
        }
        catch {
            throw new TypeError("Invalid address.");
        }
        if (url.username ||
            url.password ||
            url.pathname != "/" ||
            url.search ||
            url.hash) {
            throw new TypeError("Invalid address.");
        }
        return {
            hostname: url.hostname,
            port: url.port === "" ? 80 : Number(url.port),
        };
    }
    exports_15("_parseAddrFromStr", _parseAddrFromStr);
    function serve(addr) {
        if (typeof addr === "string") {
            addr = _parseAddrFromStr(addr);
        }
        const listener = Deno.listen(addr);
        return new Server(listener);
    }
    exports_15("serve", serve);
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_15("listenAndServe", listenAndServe);
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = Deno.listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_15("serveTLS", serveTLS);
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_15("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_3_1) {
                utf8_ts_3 = utf8_ts_3_1;
            },
            function (bufio_ts_2_1) {
                bufio_ts_2 = bufio_ts_2_1;
            },
            function (assert_ts_3_1) {
                assert_ts_3 = assert_ts_3_1;
            },
            function (mod_ts_4_1) {
                mod_ts_4 = mod_ts_4_1;
            },
            function (_io_ts_1_1) {
                _io_ts_1 = _io_ts_1_1;
            }
        ],
        execute: function () {
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_4.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                get contentLength() {
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_1.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_3.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_1.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                this._body = _io_ts_1.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        await _io_ts_1.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            this.conn.close();
                        }
                        catch {
                        }
                        err = e;
                    }
                    this.done.resolve(err);
                    if (err) {
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                    }
                    this.finalized = true;
                }
            };
            exports_15("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_2.BufReader(conn);
                    const writer = new bufio_ts_2.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_1.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                await _io_ts_1.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_3.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        const responseError = await request.done;
                        if (responseError) {
                            this.untrackConnection(request.conn);
                            return;
                        }
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_4.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_15("Server", Server);
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/_constants", [], function (exports_16, context_16) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, NATIVE_OS, navigator, isWindows;
    var __moduleName = context_16 && context_16.id;
    return {
        setters: [],
        execute: function () {
            exports_16("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65);
            exports_16("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97);
            exports_16("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90);
            exports_16("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122);
            exports_16("CHAR_DOT", CHAR_DOT = 46);
            exports_16("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47);
            exports_16("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92);
            exports_16("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124);
            exports_16("CHAR_COLON", CHAR_COLON = 58);
            exports_16("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63);
            exports_16("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95);
            exports_16("CHAR_LINE_FEED", CHAR_LINE_FEED = 10);
            exports_16("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13);
            exports_16("CHAR_TAB", CHAR_TAB = 9);
            exports_16("CHAR_FORM_FEED", CHAR_FORM_FEED = 12);
            exports_16("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33);
            exports_16("CHAR_HASH", CHAR_HASH = 35);
            exports_16("CHAR_SPACE", CHAR_SPACE = 32);
            exports_16("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160);
            exports_16("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279);
            exports_16("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91);
            exports_16("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93);
            exports_16("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60);
            exports_16("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62);
            exports_16("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123);
            exports_16("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125);
            exports_16("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45);
            exports_16("CHAR_PLUS", CHAR_PLUS = 43);
            exports_16("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34);
            exports_16("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39);
            exports_16("CHAR_PERCENT", CHAR_PERCENT = 37);
            exports_16("CHAR_SEMICOLON", CHAR_SEMICOLON = 59);
            exports_16("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94);
            exports_16("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96);
            exports_16("CHAR_AT", CHAR_AT = 64);
            exports_16("CHAR_AMPERSAND", CHAR_AMPERSAND = 38);
            exports_16("CHAR_EQUAL", CHAR_EQUAL = 61);
            exports_16("CHAR_0", CHAR_0 = 48);
            exports_16("CHAR_9", CHAR_9 = 57);
            NATIVE_OS = "linux";
            exports_16("NATIVE_OS", NATIVE_OS);
            navigator = globalThis.navigator;
            if (globalThis.Deno != null) {
                exports_16("NATIVE_OS", NATIVE_OS = Deno.build.os);
            }
            else if (navigator?.appVersion?.includes?.("Win") ?? false) {
                exports_16("NATIVE_OS", NATIVE_OS = "windows");
            }
            exports_16("isWindows", isWindows = NATIVE_OS == "windows");
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/_interface", [], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/_util", ["https://deno.land/std@0.67.0/path/_constants"], function (exports_18, context_18) {
    "use strict";
    var _constants_ts_1;
    var __moduleName = context_18 && context_18.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_18("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_1.CHAR_FORWARD_SLASH;
    }
    exports_18("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_1.CHAR_BACKWARD_SLASH;
    }
    exports_18("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_1.CHAR_LOWERCASE_A && code <= _constants_ts_1.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_1.CHAR_UPPERCASE_A && code <= _constants_ts_1.CHAR_UPPERCASE_Z));
    }
    exports_18("isWindowsDeviceRoot", isWindowsDeviceRoot);
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_1.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_1.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_1.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_1.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_18("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base ||
            (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_18("_format", _format);
    return {
        setters: [
            function (_constants_ts_1_1) {
                _constants_ts_1 = _constants_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/win32", ["https://deno.land/std@0.67.0/path/_constants", "https://deno.land/std@0.67.0/path/_util", "https://deno.land/std@0.67.0/_util/assert"], function (exports_19, context_19) {
    "use strict";
    var _constants_ts_2, _util_ts_1, assert_ts_4, sep, delimiter;
    var __moduleName = context_19 && context_19.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_1.assertPath(path);
            const len = path.length;
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len > 1) {
                if (_util_ts_1.isPathSeparator(code)) {
                    isAbsolute = true;
                    if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                        let j = 2;
                        let last = j;
                        for (; j < len; ++j) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            last = j;
                            for (; j < len; ++j) {
                                if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                last = j;
                                for (; j < len; ++j) {
                                    if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                    if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        resolvedTail = _util_ts_1.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_1.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_19("resolve", resolve);
    function normalize(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                isAbsolute = true;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_1.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_1.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_1.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_19("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_1.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_1.isWindowsDeviceRoot(code)) {
            if (len > 2 && path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_19("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_1.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_4.assert(firstPart != null);
        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_1.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_19("join", join);
    function relative(from, to) {
        _util_ts_1.assertPath(from);
        _util_ts_1.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_2.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_2.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_19("relative", relative);
    function toNamespacedPath(path) {
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_2.CHAR_QUESTION_MARK && code !== _constants_ts_2.CHAR_DOT) {
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_19("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = offset = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return path;
                            }
                            if (j !== last) {
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_19("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_1.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_1.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_1.isPathSeparator(code)) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_19("basename", basename);
    function extname(path) {
        _util_ts_1.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
            _util_ts_1.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_19("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_1._format("\\", pathObject);
    }
    exports_19("format", format);
    function parse(path) {
        _util_ts_1.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_19("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        let path = decodeURIComponent(url.pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\")
            .replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
        if (url.hostname != "") {
            path = `\\\\${url.hostname}${path}`;
        }
        return path;
    }
    exports_19("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_2_1) {
                _constants_ts_2 = _constants_ts_2_1;
            },
            function (_util_ts_1_1) {
                _util_ts_1 = _util_ts_1_1;
            },
            function (assert_ts_4_1) {
                assert_ts_4 = assert_ts_4_1;
            }
        ],
        execute: function () {
            exports_19("sep", sep = "\\");
            exports_19("delimiter", delimiter = ";");
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/posix", ["https://deno.land/std@0.67.0/path/_constants", "https://deno.land/std@0.67.0/path/_util"], function (exports_20, context_20) {
    "use strict";
    var _constants_ts_3, _util_ts_2, sep, delimiter;
    var __moduleName = context_20 && context_20.id;
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_2.assertPath(path);
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        }
        resolvedPath = _util_ts_2.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_20("resolve", resolve);
    function normalize(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_3.CHAR_FORWARD_SLASH;
        path = _util_ts_2.normalizeString(path, !isAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_20("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_2.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
    }
    exports_20("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_2.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_20("join", join);
    function relative(from, to) {
        _util_ts_2.assertPath(from);
        _util_ts_2.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_3.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_3.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_20("relative", relative);
    function toNamespacedPath(path) {
        return path;
    }
    exports_20("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_20("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_2.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_20("basename", basename);
    function extname(path) {
        _util_ts_2.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_20("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_2._format("/", pathObject);
    }
    exports_20("format", format);
    function parse(path) {
        _util_ts_2.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_20("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    }
    exports_20("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_3_1) {
                _constants_ts_3 = _constants_ts_3_1;
            },
            function (_util_ts_2_1) {
                _util_ts_2 = _util_ts_2_1;
            }
        ],
        execute: function () {
            exports_20("sep", sep = "/");
            exports_20("delimiter", delimiter = ":");
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/separator", ["https://deno.land/std@0.67.0/path/_constants"], function (exports_21, context_21) {
    "use strict";
    var _constants_ts_4, SEP, SEP_PATTERN;
    var __moduleName = context_21 && context_21.id;
    return {
        setters: [
            function (_constants_ts_4_1) {
                _constants_ts_4 = _constants_ts_4_1;
            }
        ],
        execute: function () {
            exports_21("SEP", SEP = _constants_ts_4.isWindows ? "\\" : "/");
            exports_21("SEP_PATTERN", SEP_PATTERN = _constants_ts_4.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/common", ["https://deno.land/std@0.67.0/path/separator"], function (exports_22, context_22) {
    "use strict";
    var separator_ts_1;
    var __moduleName = context_22 && context_22.id;
    function common(paths, sep = separator_ts_1.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_22("common", common);
    return {
        setters: [
            function (separator_ts_1_1) {
                separator_ts_1 = separator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/glob", ["https://deno.land/std@0.67.0/path/_constants", "https://deno.land/std@0.67.0/path/mod", "https://deno.land/std@0.67.0/path/separator"], function (exports_23, context_23) {
    "use strict";
    var _constants_ts_5, mod_ts_5, separator_ts_2;
    var __moduleName = context_23 && context_23.id;
    function globToRegExp(glob, { extended = true, globstar: globstarOption = true, os = _constants_ts_5.NATIVE_OS } = {}) {
        const sep = os == "windows" ? `(?:\\\\|\\/)+` : `\\/+`;
        const sepMaybe = os == "windows" ? `(?:\\\\|\\/)*` : `\\/*`;
        const seps = os == "windows" ? ["\\", "/"] : ["/"];
        const sepRaw = os == "windows" ? `\\` : `/`;
        const globstar = os == "windows"
            ? `(?:[^\\\\/]*(?:\\\\|\\/|$)+)*`
            : `(?:[^/]*(?:\\/|$)+)*`;
        const wildcard = os == "windows" ? `[^\\\\/]*` : `[^/]*`;
        const extStack = [];
        let inGroup = false;
        let inRange = false;
        let regExpString = "";
        let newLength = glob.length;
        for (; newLength > 0 && seps.includes(glob[newLength - 1]); newLength--)
            ;
        glob = glob.slice(0, newLength);
        let c, n;
        for (let i = 0; i < glob.length; i++) {
            c = glob[i];
            n = glob[i + 1];
            if (seps.includes(c)) {
                regExpString += sep;
                while (seps.includes(glob[i + 1]))
                    i++;
                continue;
            }
            if (c == "[") {
                if (inRange && n == ":") {
                    i++;
                    let value = "";
                    while (glob[++i] !== ":")
                        value += glob[i];
                    if (value == "alnum")
                        regExpString += "\\w\\d";
                    else if (value == "space")
                        regExpString += "\\s";
                    else if (value == "digit")
                        regExpString += "\\d";
                    i++;
                    continue;
                }
                inRange = true;
                regExpString += c;
                continue;
            }
            if (c == "]") {
                inRange = false;
                regExpString += c;
                continue;
            }
            if (c == "!") {
                if (inRange) {
                    if (glob[i - 1] == "[") {
                        regExpString += "^";
                        continue;
                    }
                }
                else if (extended) {
                    if (n == "(") {
                        extStack.push(c);
                        regExpString += "(?!";
                        i++;
                        continue;
                    }
                    regExpString += `\\${c}`;
                    continue;
                }
                else {
                    regExpString += `\\${c}`;
                    continue;
                }
            }
            if (inRange) {
                if (c == "\\" || c == "^" && glob[i - 1] == "[")
                    regExpString += `\\${c}`;
                else
                    regExpString += c;
                continue;
            }
            if (["\\", "$", "^", ".", "="].includes(c)) {
                regExpString += `\\${c}`;
                continue;
            }
            if (c == "(") {
                if (extStack.length) {
                    regExpString += `${c}?:`;
                    continue;
                }
                regExpString += `\\${c}`;
                continue;
            }
            if (c == ")") {
                if (extStack.length) {
                    regExpString += c;
                    const type = extStack.pop();
                    if (type == "@") {
                        regExpString += "{1}";
                    }
                    else if (type == "!") {
                        regExpString += wildcard;
                    }
                    else {
                        regExpString += type;
                    }
                    continue;
                }
                regExpString += `\\${c}`;
                continue;
            }
            if (c == "|") {
                if (extStack.length) {
                    regExpString += c;
                    continue;
                }
                regExpString += `\\${c}`;
                continue;
            }
            if (c == "+") {
                if (n == "(" && extended) {
                    extStack.push(c);
                    continue;
                }
                regExpString += `\\${c}`;
                continue;
            }
            if (c == "@" && extended) {
                if (n == "(") {
                    extStack.push(c);
                    continue;
                }
            }
            if (c == "?") {
                if (extended) {
                    if (n == "(") {
                        extStack.push(c);
                    }
                    continue;
                }
                else {
                    regExpString += ".";
                    continue;
                }
            }
            if (c == "{") {
                inGroup = true;
                regExpString += "(?:";
                continue;
            }
            if (c == "}") {
                inGroup = false;
                regExpString += ")";
                continue;
            }
            if (c == ",") {
                if (inGroup) {
                    regExpString += "|";
                    continue;
                }
                regExpString += `\\${c}`;
                continue;
            }
            if (c == "*") {
                if (n == "(" && extended) {
                    extStack.push(c);
                    continue;
                }
                const prevChar = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] == "*") {
                    starCount++;
                    i++;
                }
                const nextChar = glob[i + 1];
                const isGlobstar = globstarOption && starCount > 1 &&
                    [sepRaw, "/", undefined].includes(prevChar) &&
                    [sepRaw, "/", undefined].includes(nextChar);
                if (isGlobstar) {
                    regExpString += globstar;
                    while (seps.includes(glob[i + 1]))
                        i++;
                }
                else {
                    regExpString += wildcard;
                }
                continue;
            }
            regExpString += c;
        }
        regExpString = `^${regExpString}${regExpString != "" ? sepMaybe : ""}$`;
        return new RegExp(regExpString);
    }
    exports_23("globToRegExp", globToRegExp);
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_23("isGlob", isGlob);
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_5.normalize(glob);
        }
        const s = separator_ts_2.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_5.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_23("normalizeGlob", normalizeGlob);
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_5.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_2.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_23("joinGlobs", joinGlobs);
    return {
        setters: [
            function (_constants_ts_5_1) {
                _constants_ts_5 = _constants_ts_5_1;
            },
            function (mod_ts_5_1) {
                mod_ts_5 = mod_ts_5_1;
            },
            function (separator_ts_2_1) {
                separator_ts_2 = separator_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/path/mod", ["https://deno.land/std@0.67.0/path/_constants", "https://deno.land/std@0.67.0/path/win32", "https://deno.land/std@0.67.0/path/posix", "https://deno.land/std@0.67.0/path/common", "https://deno.land/std@0.67.0/path/separator", "https://deno.land/std@0.67.0/path/_interface", "https://deno.land/std@0.67.0/path/glob"], function (exports_24, context_24) {
    "use strict";
    var _constants_ts_6, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_24 && context_24.id;
    var exportedNames_1 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_24(exports);
    }
    return {
        setters: [
            function (_constants_ts_6_1) {
                _constants_ts_6 = _constants_ts_6_1;
            },
            function (_win32_1) {
                _win32 = _win32_1;
            },
            function (_posix_1) {
                _posix = _posix_1;
            },
            function (common_ts_1_1) {
                exportStar_2(common_ts_1_1);
            },
            function (separator_ts_3_1) {
                exports_24({
                    "SEP": separator_ts_3_1["SEP"],
                    "SEP_PATTERN": separator_ts_3_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_1_1) {
                exportStar_2(_interface_ts_1_1);
            },
            function (glob_ts_1_1) {
                exportStar_2(glob_ts_1_1);
            }
        ],
        execute: function () {
            path = _constants_ts_6.isWindows ? _win32 : _posix;
            exports_24("win32", win32 = _win32);
            exports_24("posix", posix = _posix);
            exports_24("basename", basename = path.basename), exports_24("delimiter", delimiter = path.delimiter), exports_24("dirname", dirname = path.dirname), exports_24("extname", extname = path.extname), exports_24("format", format = path.format), exports_24("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_24("isAbsolute", isAbsolute = path.isAbsolute), exports_24("join", join = path.join), exports_24("normalize", normalize = path.normalize), exports_24("parse", parse = path.parse), exports_24("relative", relative = path.relative), exports_24("resolve", resolve = path.resolve), exports_24("sep", sep = path.sep), exports_24("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.67.0/fmt/colors", [], function (exports_25, context_25) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_25 && context_25.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_25("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_25("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_25("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_25("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_25("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_25("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_25("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_25("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_25("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_25("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_25("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_25("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_25("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_25("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_25("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_25("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_25("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_25("white", white);
    function gray(str) {
        return brightBlack(str);
    }
    exports_25("gray", gray);
    function brightBlack(str) {
        return run(str, code([90], 39));
    }
    exports_25("brightBlack", brightBlack);
    function brightRed(str) {
        return run(str, code([91], 39));
    }
    exports_25("brightRed", brightRed);
    function brightGreen(str) {
        return run(str, code([92], 39));
    }
    exports_25("brightGreen", brightGreen);
    function brightYellow(str) {
        return run(str, code([93], 39));
    }
    exports_25("brightYellow", brightYellow);
    function brightBlue(str) {
        return run(str, code([94], 39));
    }
    exports_25("brightBlue", brightBlue);
    function brightMagenta(str) {
        return run(str, code([95], 39));
    }
    exports_25("brightMagenta", brightMagenta);
    function brightCyan(str) {
        return run(str, code([96], 39));
    }
    exports_25("brightCyan", brightCyan);
    function brightWhite(str) {
        return run(str, code([97], 39));
    }
    exports_25("brightWhite", brightWhite);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_25("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_25("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_25("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_25("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_25("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_25("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_25("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_25("bgWhite", bgWhite);
    function bgBrightBlack(str) {
        return run(str, code([100], 49));
    }
    exports_25("bgBrightBlack", bgBrightBlack);
    function bgBrightRed(str) {
        return run(str, code([101], 49));
    }
    exports_25("bgBrightRed", bgBrightRed);
    function bgBrightGreen(str) {
        return run(str, code([102], 49));
    }
    exports_25("bgBrightGreen", bgBrightGreen);
    function bgBrightYellow(str) {
        return run(str, code([103], 49));
    }
    exports_25("bgBrightYellow", bgBrightYellow);
    function bgBrightBlue(str) {
        return run(str, code([104], 49));
    }
    exports_25("bgBrightBlue", bgBrightBlue);
    function bgBrightMagenta(str) {
        return run(str, code([105], 49));
    }
    exports_25("bgBrightMagenta", bgBrightMagenta);
    function bgBrightCyan(str) {
        return run(str, code([106], 49));
    }
    exports_25("bgBrightCyan", bgBrightCyan);
    function bgBrightWhite(str) {
        return run(str, code([107], 49));
    }
    exports_25("bgBrightWhite", bgBrightWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_25("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_25("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_25("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_25("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_25("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/std@0.67.0/testing/diff", [], function (exports_26, context_26) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_26 && context_26.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_26("default", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_26("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
System.register("https://deno.land/std@0.67.0/testing/asserts", ["https://deno.land/std@0.67.0/fmt/colors", "https://deno.land/std@0.67.0/testing/diff"], function (exports_27, context_27) {
    "use strict";
    var colors_ts_1, diff_ts_1, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_27 && context_27.id;
    function _format(v) {
        let string = globalThis.Deno
            ? Deno.inspect(v, {
                depth: Infinity,
                sorted: true,
                trailingComma: true,
                compact: false,
                iterableLimit: Infinity,
            })
            : String(v);
        if (typeof v == "string") {
            string = `"${string.replace(/(?=["\\])/g, "\\")}"`;
        }
        return string;
    }
    exports_27("_format", _format);
    function createColor(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return (s) => colors_ts_1.green(colors_ts_1.bold(s));
            case diff_ts_1.DiffType.removed:
                return (s) => colors_ts_1.red(colors_ts_1.bold(s));
            default:
                return colors_ts_1.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return "+   ";
            case diff_ts_1.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_1.gray(colors_ts_1.bold("[Diff]"))} ${colors_ts_1.red(colors_ts_1.bold("Actual"))} / ${colors_ts_1.green(colors_ts_1.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof URL && b instanceof URL))) {
                return String(a) === String(b);
            }
            if (a instanceof Date && b instanceof Date) {
                const aTime = a.getTime();
                const bTime = b.getTime();
                if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                    return true;
                }
                return a.getTime() === b.getTime();
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_27("equal", equal);
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_27("assert", assert);
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = _format(actual);
        const expectedString = _format(expected);
        try {
            const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult).join("\n");
            message = `Values are not equal:\n${diffMsg}`;
        }
        catch (e) {
            message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_27("assertEquals", assertEquals);
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_27("assertNotEquals", assertNotEquals);
    function assertStrictEquals(actual, expected, msg) {
        if (actual === expected) {
            return;
        }
        let message;
        if (msg) {
            message = msg;
        }
        else {
            const actualString = _format(actual);
            const expectedString = _format(expected);
            if (actualString === expectedString) {
                const withOffset = actualString
                    .split("\n")
                    .map((l) => `    ${l}`)
                    .join("\n");
                message =
                    `Values have the same structure but are not reference-equal:\n\n${colors_ts_1.red(withOffset)}\n`;
            }
            else {
                try {
                    const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
                    const diffMsg = buildMessage(diffResult).join("\n");
                    message = `Values are not strictly equal:\n${diffMsg}`;
                }
                catch (e) {
                    message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
                }
            }
        }
        throw new AssertionError(message);
    }
    exports_27("assertStrictEquals", assertStrictEquals);
    function assertNotStrictEquals(actual, expected, msg) {
        if (actual !== expected) {
            return;
        }
        throw new AssertionError(msg ?? `Expected "actual" to be strictly unequal to: ${_format(actual)}\n`);
    }
    exports_27("assertNotStrictEquals", assertNotStrictEquals);
    function assertStringContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contain: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertStringContains", assertStringContains);
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${_format(actual)}" expected to contain: "${_format(expected)}"\nmissing: ${_format(missing)}`;
        }
        throw new AssertionError(msg);
    }
    exports_27("assertArrayContains", assertArrayContains);
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertMatch", assertMatch);
    function assertNotMatch(actual, expected, msg) {
        if (expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to not match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_27("assertNotMatch", assertNotMatch);
    function fail(msg) {
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_27("fail", fail);
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_27("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown or rejected.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_27("assertThrowsAsync", assertThrowsAsync);
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_27("unimplemented", unimplemented);
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_27("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_1_1) {
                colors_ts_1 = colors_ts_1_1;
            },
            function (diff_ts_1_1) {
                diff_ts_1 = diff_ts_1_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_27("AssertionError", AssertionError);
        }
    };
});
System.register("https://deno.land/std@0.67.0/_util/has_own_property", [], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_28("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/io/ioutil", ["https://deno.land/std@0.67.0/_util/assert"], function (exports_29, context_29) {
    "use strict";
    var assert_ts_5, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_29 && context_29.id;
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_5.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_29("copyN", copyN);
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_29("readShort", readShort);
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_29("readInt", readInt);
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_29("readLong", readLong);
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_29("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_5_1) {
                assert_ts_5 = assert_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
System.register("https://deno.land/std@0.67.0/ws/mod", ["https://deno.land/std@0.67.0/encoding/utf8", "https://deno.land/std@0.67.0/_util/has_own_property", "https://deno.land/std@0.67.0/io/bufio", "https://deno.land/std@0.67.0/io/ioutil", "https://deno.land/std@0.67.0/hash/sha1", "https://deno.land/std@0.67.0/http/_io", "https://deno.land/std@0.67.0/textproto/mod", "https://deno.land/std@0.67.0/async/deferred", "https://deno.land/std@0.67.0/_util/assert", "https://deno.land/std@0.67.0/bytes/mod"], function (exports_30, context_30) {
    "use strict";
    var utf8_ts_4, has_own_property_ts_1, bufio_ts_3, ioutil_ts_1, sha1_ts_1, _io_ts_2, mod_ts_6, deferred_ts_3, assert_ts_6, mod_ts_7, OpCode, WebSocketImpl, kGUID, kSecChars;
    var __moduleName = context_30 && context_30.id;
    function isWebSocketCloseEvent(a) {
        return has_own_property_ts_1.hasOwnProperty(a, "code");
    }
    exports_30("isWebSocketCloseEvent", isWebSocketCloseEvent);
    function isWebSocketPingEvent(a) {
        return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
    }
    exports_30("isWebSocketPingEvent", isWebSocketPingEvent);
    function isWebSocketPongEvent(a) {
        return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
    }
    exports_30("isWebSocketPongEvent", isWebSocketPongEvent);
    function unmask(payload, mask) {
        if (mask) {
            for (let i = 0, len = payload.length; i < len; i++) {
                payload[i] ^= mask[i & 3];
            }
        }
    }
    exports_30("unmask", unmask);
    async function writeFrame(frame, writer) {
        const payloadLength = frame.payload.byteLength;
        let header;
        const hasMask = frame.mask ? 0x80 : 0;
        if (frame.mask && frame.mask.byteLength !== 4) {
            throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
        }
        if (payloadLength < 126) {
            header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
        }
        else if (payloadLength < 0xffff) {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111110,
                payloadLength >>> 8,
                payloadLength & 0x00ff,
            ]);
        }
        else {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111111,
                ...ioutil_ts_1.sliceLongToBytes(payloadLength),
            ]);
        }
        if (frame.mask) {
            header = mod_ts_7.concat(header, frame.mask);
        }
        unmask(frame.payload, frame.mask);
        header = mod_ts_7.concat(header, frame.payload);
        const w = bufio_ts_3.BufWriter.create(writer);
        await w.write(header);
        await w.flush();
    }
    exports_30("writeFrame", writeFrame);
    async function readFrame(buf) {
        let b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        let isLastFrame = false;
        switch (b >>> 4) {
            case 0b1000:
                isLastFrame = true;
                break;
            case 0b0000:
                isLastFrame = false;
                break;
            default:
                throw new Error("invalid signature");
        }
        const opcode = b & 0x0f;
        b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        const hasMask = b >>> 7;
        let payloadLength = b & 0b01111111;
        if (payloadLength === 126) {
            const l = await ioutil_ts_1.readShort(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = l;
        }
        else if (payloadLength === 127) {
            const l = await ioutil_ts_1.readLong(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = Number(l);
        }
        let mask;
        if (hasMask) {
            mask = new Uint8Array(4);
            assert_ts_6.assert((await buf.readFull(mask)) !== null);
        }
        const payload = new Uint8Array(payloadLength);
        assert_ts_6.assert((await buf.readFull(payload)) !== null);
        return {
            isLastFrame,
            opcode,
            mask,
            payload,
        };
    }
    exports_30("readFrame", readFrame);
    function createMask() {
        return crypto.getRandomValues(new Uint8Array(4));
    }
    function acceptable(req) {
        const upgrade = req.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = req.headers.get("sec-websocket-key");
        return (req.headers.has("sec-websocket-key") &&
            typeof secKey === "string" &&
            secKey.length > 0);
    }
    exports_30("acceptable", acceptable);
    function createSecAccept(nonce) {
        const sha1 = new sha1_ts_1.Sha1();
        sha1.update(nonce + kGUID);
        const bytes = sha1.digest();
        return btoa(String.fromCharCode(...bytes));
    }
    exports_30("createSecAccept", createSecAccept);
    async function acceptWebSocket(req) {
        const { conn, headers, bufReader, bufWriter } = req;
        if (acceptable(req)) {
            const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
            const secKey = headers.get("sec-websocket-key");
            if (typeof secKey !== "string") {
                throw new Error("sec-websocket-key is not provided");
            }
            const secAccept = createSecAccept(secKey);
            await _io_ts_2.writeResponse(bufWriter, {
                status: 101,
                headers: new Headers({
                    Upgrade: "websocket",
                    Connection: "Upgrade",
                    "Sec-WebSocket-Accept": secAccept,
                }),
            });
            return sock;
        }
        throw new Error("request is not acceptable");
    }
    exports_30("acceptWebSocket", acceptWebSocket);
    function createSecKey() {
        let key = "";
        for (let i = 0; i < 16; i++) {
            const j = Math.floor(Math.random() * kSecChars.length);
            key += kSecChars[j];
        }
        return btoa(key);
    }
    exports_30("createSecKey", createSecKey);
    async function handshake(url, headers, bufReader, bufWriter) {
        const { hostname, pathname, search } = url;
        const key = createSecKey();
        if (!headers.has("host")) {
            headers.set("host", hostname);
        }
        headers.set("upgrade", "websocket");
        headers.set("connection", "upgrade");
        headers.set("sec-websocket-key", key);
        headers.set("sec-websocket-version", "13");
        let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
        for (const [key, value] of headers) {
            headerStr += `${key}: ${value}\r\n`;
        }
        headerStr += "\r\n";
        await bufWriter.write(utf8_ts_4.encode(headerStr));
        await bufWriter.flush();
        const tpReader = new mod_ts_6.TextProtoReader(bufReader);
        const statusLine = await tpReader.readLine();
        if (statusLine === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
        if (!m) {
            throw new Error("ws: invalid status line: " + statusLine);
        }
        assert_ts_6.assert(m.groups);
        const { version, statusCode } = m.groups;
        if (version !== "HTTP/1.1" || statusCode !== "101") {
            throw new Error(`ws: server didn't accept handshake: ` +
                `version=${version}, statusCode=${statusCode}`);
        }
        const responseHeaders = await tpReader.readMIMEHeader();
        if (responseHeaders === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const expectedSecAccept = createSecAccept(key);
        const secAccept = responseHeaders.get("sec-websocket-accept");
        if (secAccept !== expectedSecAccept) {
            throw new Error(`ws: unexpected sec-websocket-accept header: ` +
                `expected=${expectedSecAccept}, actual=${secAccept}`);
        }
    }
    exports_30("handshake", handshake);
    async function connectWebSocket(endpoint, headers = new Headers()) {
        const url = new URL(endpoint);
        const { hostname } = url;
        let conn;
        if (url.protocol === "http:" || url.protocol === "ws:") {
            const port = parseInt(url.port || "80");
            conn = await Deno.connect({ hostname, port });
        }
        else if (url.protocol === "https:" || url.protocol === "wss:") {
            const port = parseInt(url.port || "443");
            conn = await Deno.connectTls({ hostname, port });
        }
        else {
            throw new Error("ws: unsupported protocol: " + url.protocol);
        }
        const bufWriter = new bufio_ts_3.BufWriter(conn);
        const bufReader = new bufio_ts_3.BufReader(conn);
        try {
            await handshake(url, headers, bufReader, bufWriter);
        }
        catch (err) {
            conn.close();
            throw err;
        }
        return new WebSocketImpl({
            conn,
            bufWriter,
            bufReader,
            mask: createMask(),
        });
    }
    exports_30("connectWebSocket", connectWebSocket);
    function createWebSocket(params) {
        return new WebSocketImpl(params);
    }
    exports_30("createWebSocket", createWebSocket);
    return {
        setters: [
            function (utf8_ts_4_1) {
                utf8_ts_4 = utf8_ts_4_1;
            },
            function (has_own_property_ts_1_1) {
                has_own_property_ts_1 = has_own_property_ts_1_1;
            },
            function (bufio_ts_3_1) {
                bufio_ts_3 = bufio_ts_3_1;
            },
            function (ioutil_ts_1_1) {
                ioutil_ts_1 = ioutil_ts_1_1;
            },
            function (sha1_ts_1_1) {
                sha1_ts_1 = sha1_ts_1_1;
            },
            function (_io_ts_2_1) {
                _io_ts_2 = _io_ts_2_1;
            },
            function (mod_ts_6_1) {
                mod_ts_6 = mod_ts_6_1;
            },
            function (deferred_ts_3_1) {
                deferred_ts_3 = deferred_ts_3_1;
            },
            function (assert_ts_6_1) {
                assert_ts_6 = assert_ts_6_1;
            },
            function (mod_ts_7_1) {
                mod_ts_7 = mod_ts_7_1;
            }
        ],
        execute: function () {
            (function (OpCode) {
                OpCode[OpCode["Continue"] = 0] = "Continue";
                OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
                OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
                OpCode[OpCode["Close"] = 8] = "Close";
                OpCode[OpCode["Ping"] = 9] = "Ping";
                OpCode[OpCode["Pong"] = 10] = "Pong";
            })(OpCode || (OpCode = {}));
            exports_30("OpCode", OpCode);
            WebSocketImpl = class WebSocketImpl {
                constructor({ conn, bufReader, bufWriter, mask, }) {
                    this.sendQueue = [];
                    this._isClosed = false;
                    this.conn = conn;
                    this.mask = mask;
                    this.bufReader = bufReader || new bufio_ts_3.BufReader(conn);
                    this.bufWriter = bufWriter || new bufio_ts_3.BufWriter(conn);
                }
                async *[Symbol.asyncIterator]() {
                    let frames = [];
                    let payloadsLength = 0;
                    while (!this._isClosed) {
                        let frame;
                        try {
                            frame = await readFrame(this.bufReader);
                        }
                        catch (e) {
                            this.ensureSocketClosed();
                            break;
                        }
                        unmask(frame.payload, frame.mask);
                        switch (frame.opcode) {
                            case OpCode.TextFrame:
                            case OpCode.BinaryFrame:
                            case OpCode.Continue:
                                frames.push(frame);
                                payloadsLength += frame.payload.length;
                                if (frame.isLastFrame) {
                                    const concat = new Uint8Array(payloadsLength);
                                    let offs = 0;
                                    for (const frame of frames) {
                                        concat.set(frame.payload, offs);
                                        offs += frame.payload.length;
                                    }
                                    if (frames[0].opcode === OpCode.TextFrame) {
                                        yield utf8_ts_4.decode(concat);
                                    }
                                    else {
                                        yield concat;
                                    }
                                    frames = [];
                                    payloadsLength = 0;
                                }
                                break;
                            case OpCode.Close: {
                                const code = (frame.payload[0] << 8) | frame.payload[1];
                                const reason = utf8_ts_4.decode(frame.payload.subarray(2, frame.payload.length));
                                await this.close(code, reason);
                                yield { code, reason };
                                return;
                            }
                            case OpCode.Ping:
                                await this.enqueue({
                                    opcode: OpCode.Pong,
                                    payload: frame.payload,
                                    isLastFrame: true,
                                });
                                yield ["ping", frame.payload];
                                break;
                            case OpCode.Pong:
                                yield ["pong", frame.payload];
                                break;
                            default:
                        }
                    }
                }
                dequeue() {
                    const [entry] = this.sendQueue;
                    if (!entry)
                        return;
                    if (this._isClosed)
                        return;
                    const { d, frame } = entry;
                    writeFrame(frame, this.bufWriter)
                        .then(() => d.resolve())
                        .catch((e) => d.reject(e))
                        .finally(() => {
                        this.sendQueue.shift();
                        this.dequeue();
                    });
                }
                enqueue(frame) {
                    if (this._isClosed) {
                        throw new Deno.errors.ConnectionReset("Socket has already been closed");
                    }
                    const d = deferred_ts_3.deferred();
                    this.sendQueue.push({ d, frame });
                    if (this.sendQueue.length === 1) {
                        this.dequeue();
                    }
                    return d;
                }
                send(data) {
                    const opcode = typeof data === "string"
                        ? OpCode.TextFrame
                        : OpCode.BinaryFrame;
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const isLastFrame = true;
                    const frame = {
                        isLastFrame,
                        opcode,
                        payload,
                        mask: this.mask,
                    };
                    return this.enqueue(frame);
                }
                ping(data = "") {
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const frame = {
                        isLastFrame: true,
                        opcode: OpCode.Ping,
                        mask: this.mask,
                        payload,
                    };
                    return this.enqueue(frame);
                }
                get isClosed() {
                    return this._isClosed;
                }
                async close(code = 1000, reason) {
                    try {
                        const header = [code >>> 8, code & 0x00ff];
                        let payload;
                        if (reason) {
                            const reasonBytes = utf8_ts_4.encode(reason);
                            payload = new Uint8Array(2 + reasonBytes.byteLength);
                            payload.set(header);
                            payload.set(reasonBytes, 2);
                        }
                        else {
                            payload = new Uint8Array(header);
                        }
                        await this.enqueue({
                            isLastFrame: true,
                            opcode: OpCode.Close,
                            mask: this.mask,
                            payload,
                        });
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.ensureSocketClosed();
                    }
                }
                closeForce() {
                    this.ensureSocketClosed();
                }
                ensureSocketClosed() {
                    if (this.isClosed)
                        return;
                    try {
                        this.conn.close();
                    }
                    catch (e) {
                        console.error(e);
                    }
                    finally {
                        this._isClosed = true;
                        const rest = this.sendQueue;
                        this.sendQueue = [];
                        rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
                    }
                }
            };
            kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
        }
    };
});
System.register("https://deno.land/x/media_types@v2.4.6/db", [], function (exports_31, context_31) {
    "use strict";
    var db;
    var __moduleName = context_31 && context_31.id;
    return {
        setters: [],
        execute: function () {
            exports_31("db", db = {
                "application/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "application/3gpdash-qoe-report+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/3gpp-ims+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/a2l": {
                    source: "iana",
                },
                "application/activemessage": {
                    source: "iana",
                },
                "application/activity+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-directory+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcost+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcostparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointprop+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointpropparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-error+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamcontrol+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/aml": {
                    source: "iana",
                },
                "application/andrew-inset": {
                    source: "iana",
                    extensions: ["ez"],
                },
                "application/applefile": {
                    source: "iana",
                },
                "application/applixware": {
                    source: "apache",
                    extensions: ["aw"],
                },
                "application/atf": {
                    source: "iana",
                },
                "application/atfx": {
                    source: "iana",
                },
                "application/atom+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atom"],
                },
                "application/atomcat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomcat"],
                },
                "application/atomdeleted+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomdeleted"],
                },
                "application/atomicmail": {
                    source: "iana",
                },
                "application/atomsvc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomsvc"],
                },
                "application/atsc-dwd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dwd"],
                },
                "application/atsc-dynamic-event-message": {
                    source: "iana",
                },
                "application/atsc-held+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["held"],
                },
                "application/atsc-rdt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/atsc-rsat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsat"],
                },
                "application/atxml": {
                    source: "iana",
                },
                "application/auth-policy+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/bacnet-xdd+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/batch-smtp": {
                    source: "iana",
                },
                "application/bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/beep+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/calendar+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/calendar+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xcs"],
                },
                "application/call-completion": {
                    source: "iana",
                },
                "application/cals-1840": {
                    source: "iana",
                },
                "application/cap+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/cbor": {
                    source: "iana",
                },
                "application/cbor-seq": {
                    source: "iana",
                },
                "application/cccex": {
                    source: "iana",
                },
                "application/ccmp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ccxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ccxml"],
                },
                "application/cdfx+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdfx"],
                },
                "application/cdmi-capability": {
                    source: "iana",
                    extensions: ["cdmia"],
                },
                "application/cdmi-container": {
                    source: "iana",
                    extensions: ["cdmic"],
                },
                "application/cdmi-domain": {
                    source: "iana",
                    extensions: ["cdmid"],
                },
                "application/cdmi-object": {
                    source: "iana",
                    extensions: ["cdmio"],
                },
                "application/cdmi-queue": {
                    source: "iana",
                    extensions: ["cdmiq"],
                },
                "application/cdni": {
                    source: "iana",
                },
                "application/cea": {
                    source: "iana",
                },
                "application/cea-2018+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cellml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cfw": {
                    source: "iana",
                },
                "application/clue+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/clue_info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cms": {
                    source: "iana",
                },
                "application/cnrp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-group+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-payload": {
                    source: "iana",
                },
                "application/commonground": {
                    source: "iana",
                },
                "application/conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cose": {
                    source: "iana",
                },
                "application/cose-key": {
                    source: "iana",
                },
                "application/cose-key-set": {
                    source: "iana",
                },
                "application/cpl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csrattrs": {
                    source: "iana",
                },
                "application/csta+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cstadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csvm+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/cu-seeme": {
                    source: "apache",
                    extensions: ["cu"],
                },
                "application/cwt": {
                    source: "iana",
                },
                "application/cybercash": {
                    source: "iana",
                },
                "application/dart": {
                    compressible: true,
                },
                "application/dash+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpd"],
                },
                "application/dashdelta": {
                    source: "iana",
                },
                "application/davmount+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["davmount"],
                },
                "application/dca-rft": {
                    source: "iana",
                },
                "application/dcd": {
                    source: "iana",
                },
                "application/dec-dx": {
                    source: "iana",
                },
                "application/dialog-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom": {
                    source: "iana",
                },
                "application/dicom+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dii": {
                    source: "iana",
                },
                "application/dit": {
                    source: "iana",
                },
                "application/dns": {
                    source: "iana",
                },
                "application/dns+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dns-message": {
                    source: "iana",
                },
                "application/docbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dbk"],
                },
                "application/dots+cbor": {
                    source: "iana",
                },
                "application/dskpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dssc+der": {
                    source: "iana",
                    extensions: ["dssc"],
                },
                "application/dssc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdssc"],
                },
                "application/dvcs": {
                    source: "iana",
                },
                "application/ecmascript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ecma", "es"],
                },
                "application/edi-consent": {
                    source: "iana",
                },
                "application/edi-x12": {
                    source: "iana",
                    compressible: false,
                },
                "application/edifact": {
                    source: "iana",
                    compressible: false,
                },
                "application/efi": {
                    source: "iana",
                },
                "application/emergencycalldata.comment+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.deviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.ecall.msd": {
                    source: "iana",
                },
                "application/emergencycalldata.providerinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.serviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.subscriberinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.veds+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emma+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emma"],
                },
                "application/emotionml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emotionml"],
                },
                "application/encaprtp": {
                    source: "iana",
                },
                "application/epp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/epub+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["epub"],
                },
                "application/eshop": {
                    source: "iana",
                },
                "application/exi": {
                    source: "iana",
                    extensions: ["exi"],
                },
                "application/expect-ct-report+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/fastinfoset": {
                    source: "iana",
                },
                "application/fastsoap": {
                    source: "iana",
                },
                "application/fdt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fdt"],
                },
                "application/fhir+json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fhir+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fido.trusted-apps+json": {
                    compressible: true,
                },
                "application/fits": {
                    source: "iana",
                },
                "application/flexfec": {
                    source: "iana",
                },
                "application/font-sfnt": {
                    source: "iana",
                },
                "application/font-tdpfr": {
                    source: "iana",
                    extensions: ["pfr"],
                },
                "application/font-woff": {
                    source: "iana",
                    compressible: false,
                },
                "application/framework-attributes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/geo+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["geojson"],
                },
                "application/geo+json-seq": {
                    source: "iana",
                },
                "application/geopackage+sqlite3": {
                    source: "iana",
                },
                "application/geoxacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/gltf-buffer": {
                    source: "iana",
                },
                "application/gml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gml"],
                },
                "application/gpx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["gpx"],
                },
                "application/gxf": {
                    source: "apache",
                    extensions: ["gxf"],
                },
                "application/gzip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gz"],
                },
                "application/h224": {
                    source: "iana",
                },
                "application/held+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/hjson": {
                    extensions: ["hjson"],
                },
                "application/http": {
                    source: "iana",
                },
                "application/hyperstudio": {
                    source: "iana",
                    extensions: ["stk"],
                },
                "application/ibe-key-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pkg-reply+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pp-data": {
                    source: "iana",
                },
                "application/iges": {
                    source: "iana",
                },
                "application/im-iscomposing+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/index": {
                    source: "iana",
                },
                "application/index.cmd": {
                    source: "iana",
                },
                "application/index.obj": {
                    source: "iana",
                },
                "application/index.response": {
                    source: "iana",
                },
                "application/index.vnd": {
                    source: "iana",
                },
                "application/inkml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ink", "inkml"],
                },
                "application/iotp": {
                    source: "iana",
                },
                "application/ipfix": {
                    source: "iana",
                    extensions: ["ipfix"],
                },
                "application/ipp": {
                    source: "iana",
                },
                "application/isup": {
                    source: "iana",
                },
                "application/its+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["its"],
                },
                "application/java-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jar", "war", "ear"],
                },
                "application/java-serialized-object": {
                    source: "apache",
                    compressible: false,
                    extensions: ["ser"],
                },
                "application/java-vm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["class"],
                },
                "application/javascript": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["js", "mjs"],
                },
                "application/jf2feed+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jose": {
                    source: "iana",
                },
                "application/jose+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jrd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["json", "map"],
                },
                "application/json-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json-seq": {
                    source: "iana",
                },
                "application/json5": {
                    extensions: ["json5"],
                },
                "application/jsonml+json": {
                    source: "apache",
                    compressible: true,
                    extensions: ["jsonml"],
                },
                "application/jwk+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwk-set+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwt": {
                    source: "iana",
                },
                "application/kpml-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/kpml-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ld+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["jsonld"],
                },
                "application/lgr+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lgr"],
                },
                "application/link-format": {
                    source: "iana",
                },
                "application/load-control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lost+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lostxml"],
                },
                "application/lostsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lpf+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/lxf": {
                    source: "iana",
                },
                "application/mac-binhex40": {
                    source: "iana",
                    extensions: ["hqx"],
                },
                "application/mac-compactpro": {
                    source: "apache",
                    extensions: ["cpt"],
                },
                "application/macwriteii": {
                    source: "iana",
                },
                "application/mads+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mads"],
                },
                "application/manifest+json": {
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["webmanifest"],
                },
                "application/marc": {
                    source: "iana",
                    extensions: ["mrc"],
                },
                "application/marcxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mrcx"],
                },
                "application/mathematica": {
                    source: "iana",
                    extensions: ["ma", "nb", "mb"],
                },
                "application/mathml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mathml"],
                },
                "application/mathml-content+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mathml-presentation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-associated-procedure-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-deregister+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-envelope+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-protection-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-reception-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-schedule+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-user-service-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbox": {
                    source: "iana",
                    extensions: ["mbox"],
                },
                "application/media-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/media_control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mediaservercontrol+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mscml"],
                },
                "application/merge-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/metalink+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["metalink"],
                },
                "application/metalink4+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["meta4"],
                },
                "application/mets+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mets"],
                },
                "application/mf4": {
                    source: "iana",
                },
                "application/mikey": {
                    source: "iana",
                },
                "application/mipc": {
                    source: "iana",
                },
                "application/mmt-aei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["maei"],
                },
                "application/mmt-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musd"],
                },
                "application/mods+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mods"],
                },
                "application/moss-keys": {
                    source: "iana",
                },
                "application/moss-signature": {
                    source: "iana",
                },
                "application/mosskey-data": {
                    source: "iana",
                },
                "application/mosskey-request": {
                    source: "iana",
                },
                "application/mp21": {
                    source: "iana",
                    extensions: ["m21", "mp21"],
                },
                "application/mp4": {
                    source: "iana",
                    extensions: ["mp4s", "m4p"],
                },
                "application/mpeg4-generic": {
                    source: "iana",
                },
                "application/mpeg4-iod": {
                    source: "iana",
                },
                "application/mpeg4-iod-xmt": {
                    source: "iana",
                },
                "application/mrb-consumer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/mrb-publish+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/msc-ivr+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msc-mixer+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msword": {
                    source: "iana",
                    compressible: false,
                    extensions: ["doc", "dot"],
                },
                "application/mud+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/multipart-core": {
                    source: "iana",
                },
                "application/mxf": {
                    source: "iana",
                    extensions: ["mxf"],
                },
                "application/n-quads": {
                    source: "iana",
                    extensions: ["nq"],
                },
                "application/n-triples": {
                    source: "iana",
                    extensions: ["nt"],
                },
                "application/nasdata": {
                    source: "iana",
                },
                "application/news-checkgroups": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-groupinfo": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-transmission": {
                    source: "iana",
                },
                "application/nlsml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/node": {
                    source: "iana",
                    extensions: ["cjs"],
                },
                "application/nss": {
                    source: "iana",
                },
                "application/ocsp-request": {
                    source: "iana",
                },
                "application/ocsp-response": {
                    source: "iana",
                },
                "application/octet-stream": {
                    source: "iana",
                    compressible: false,
                    extensions: [
                        "bin",
                        "dms",
                        "lrf",
                        "mar",
                        "so",
                        "dist",
                        "distz",
                        "pkg",
                        "bpk",
                        "dump",
                        "elc",
                        "deploy",
                        "exe",
                        "dll",
                        "deb",
                        "dmg",
                        "iso",
                        "img",
                        "msi",
                        "msp",
                        "msm",
                        "buffer",
                    ],
                },
                "application/oda": {
                    source: "iana",
                    extensions: ["oda"],
                },
                "application/odm+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/odx": {
                    source: "iana",
                },
                "application/oebps-package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["opf"],
                },
                "application/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogx"],
                },
                "application/omdoc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["omdoc"],
                },
                "application/onenote": {
                    source: "apache",
                    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
                },
                "application/oscore": {
                    source: "iana",
                },
                "application/oxps": {
                    source: "iana",
                    extensions: ["oxps"],
                },
                "application/p2p-overlay+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["relo"],
                },
                "application/parityfec": {
                    source: "iana",
                },
                "application/passport": {
                    source: "iana",
                },
                "application/patch-ops-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/pdf": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pdf"],
                },
                "application/pdx": {
                    source: "iana",
                },
                "application/pem-certificate-chain": {
                    source: "iana",
                },
                "application/pgp-encrypted": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pgp"],
                },
                "application/pgp-keys": {
                    source: "iana",
                },
                "application/pgp-signature": {
                    source: "iana",
                    extensions: ["asc", "sig"],
                },
                "application/pics-rules": {
                    source: "apache",
                    extensions: ["prf"],
                },
                "application/pidf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pidf-diff+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pkcs10": {
                    source: "iana",
                    extensions: ["p10"],
                },
                "application/pkcs12": {
                    source: "iana",
                },
                "application/pkcs7-mime": {
                    source: "iana",
                    extensions: ["p7m", "p7c"],
                },
                "application/pkcs7-signature": {
                    source: "iana",
                    extensions: ["p7s"],
                },
                "application/pkcs8": {
                    source: "iana",
                    extensions: ["p8"],
                },
                "application/pkcs8-encrypted": {
                    source: "iana",
                },
                "application/pkix-attr-cert": {
                    source: "iana",
                    extensions: ["ac"],
                },
                "application/pkix-cert": {
                    source: "iana",
                    extensions: ["cer"],
                },
                "application/pkix-crl": {
                    source: "iana",
                    extensions: ["crl"],
                },
                "application/pkix-pkipath": {
                    source: "iana",
                    extensions: ["pkipath"],
                },
                "application/pkixcmp": {
                    source: "iana",
                    extensions: ["pki"],
                },
                "application/pls+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pls"],
                },
                "application/poc-settings+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/postscript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ai", "eps", "ps"],
                },
                "application/ppsp-tracker+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/provenance+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["provx"],
                },
                "application/prs.alvestrand.titrax-sheet": {
                    source: "iana",
                },
                "application/prs.cww": {
                    source: "iana",
                    extensions: ["cww"],
                },
                "application/prs.hpub+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/prs.nprend": {
                    source: "iana",
                },
                "application/prs.plucker": {
                    source: "iana",
                },
                "application/prs.rdf-xml-crypt": {
                    source: "iana",
                },
                "application/prs.xsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/pskc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pskcxml"],
                },
                "application/pvd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/qsig": {
                    source: "iana",
                },
                "application/raml+yaml": {
                    compressible: true,
                    extensions: ["raml"],
                },
                "application/raptorfec": {
                    source: "iana",
                },
                "application/rdap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/rdf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rdf", "owl"],
                },
                "application/reginfo+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rif"],
                },
                "application/relax-ng-compact-syntax": {
                    source: "iana",
                    extensions: ["rnc"],
                },
                "application/remote-printing": {
                    source: "iana",
                },
                "application/reputon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/resource-lists+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rl"],
                },
                "application/resource-lists-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rld"],
                },
                "application/rfc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/riscos": {
                    source: "iana",
                },
                "application/rlmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/rls-services+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rs"],
                },
                "application/route-apd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rapd"],
                },
                "application/route-s-tsid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sls"],
                },
                "application/route-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rusd"],
                },
                "application/rpki-ghostbusters": {
                    source: "iana",
                    extensions: ["gbr"],
                },
                "application/rpki-manifest": {
                    source: "iana",
                    extensions: ["mft"],
                },
                "application/rpki-publication": {
                    source: "iana",
                },
                "application/rpki-roa": {
                    source: "iana",
                    extensions: ["roa"],
                },
                "application/rpki-updown": {
                    source: "iana",
                },
                "application/rsd+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rsd"],
                },
                "application/rss+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rss"],
                },
                "application/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "application/rtploopback": {
                    source: "iana",
                },
                "application/rtx": {
                    source: "iana",
                },
                "application/samlassertion+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/samlmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sbe": {
                    source: "iana",
                },
                "application/sbml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sbml"],
                },
                "application/scaip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/scim+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/scvp-cv-request": {
                    source: "iana",
                    extensions: ["scq"],
                },
                "application/scvp-cv-response": {
                    source: "iana",
                    extensions: ["scs"],
                },
                "application/scvp-vp-request": {
                    source: "iana",
                    extensions: ["spq"],
                },
                "application/scvp-vp-response": {
                    source: "iana",
                    extensions: ["spp"],
                },
                "application/sdp": {
                    source: "iana",
                    extensions: ["sdp"],
                },
                "application/secevent+jwt": {
                    source: "iana",
                },
                "application/senml+cbor": {
                    source: "iana",
                },
                "application/senml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["senmlx"],
                },
                "application/senml-etch+cbor": {
                    source: "iana",
                },
                "application/senml-etch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml-exi": {
                    source: "iana",
                },
                "application/sensml+cbor": {
                    source: "iana",
                },
                "application/sensml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/sensml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sensmlx"],
                },
                "application/sensml-exi": {
                    source: "iana",
                },
                "application/sep+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sep-exi": {
                    source: "iana",
                },
                "application/session-info": {
                    source: "iana",
                },
                "application/set-payment": {
                    source: "iana",
                },
                "application/set-payment-initiation": {
                    source: "iana",
                    extensions: ["setpay"],
                },
                "application/set-registration": {
                    source: "iana",
                },
                "application/set-registration-initiation": {
                    source: "iana",
                    extensions: ["setreg"],
                },
                "application/sgml": {
                    source: "iana",
                },
                "application/sgml-open-catalog": {
                    source: "iana",
                },
                "application/shf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["shf"],
                },
                "application/sieve": {
                    source: "iana",
                    extensions: ["siv", "sieve"],
                },
                "application/simple-filter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/simple-message-summary": {
                    source: "iana",
                },
                "application/simplesymbolcontainer": {
                    source: "iana",
                },
                "application/sipc": {
                    source: "iana",
                },
                "application/slate": {
                    source: "iana",
                },
                "application/smil": {
                    source: "iana",
                },
                "application/smil+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["smi", "smil"],
                },
                "application/smpte336m": {
                    source: "iana",
                },
                "application/soap+fastinfoset": {
                    source: "iana",
                },
                "application/soap+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sparql-query": {
                    source: "iana",
                    extensions: ["rq"],
                },
                "application/sparql-results+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["srx"],
                },
                "application/spirits-event+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sql": {
                    source: "iana",
                },
                "application/srgs": {
                    source: "iana",
                    extensions: ["gram"],
                },
                "application/srgs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["grxml"],
                },
                "application/sru+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sru"],
                },
                "application/ssdl+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ssdl"],
                },
                "application/ssml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ssml"],
                },
                "application/stix+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/swid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["swidtag"],
                },
                "application/tamp-apex-update": {
                    source: "iana",
                },
                "application/tamp-apex-update-confirm": {
                    source: "iana",
                },
                "application/tamp-community-update": {
                    source: "iana",
                },
                "application/tamp-community-update-confirm": {
                    source: "iana",
                },
                "application/tamp-error": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust-confirm": {
                    source: "iana",
                },
                "application/tamp-status-query": {
                    source: "iana",
                },
                "application/tamp-status-response": {
                    source: "iana",
                },
                "application/tamp-update": {
                    source: "iana",
                },
                "application/tamp-update-confirm": {
                    source: "iana",
                },
                "application/tar": {
                    compressible: true,
                },
                "application/taxii+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/td+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tei", "teicorpus"],
                },
                "application/tetra_isi": {
                    source: "iana",
                },
                "application/thraud+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tfi"],
                },
                "application/timestamp-query": {
                    source: "iana",
                },
                "application/timestamp-reply": {
                    source: "iana",
                },
                "application/timestamped-data": {
                    source: "iana",
                    extensions: ["tsd"],
                },
                "application/tlsrpt+gzip": {
                    source: "iana",
                },
                "application/tlsrpt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tnauthlist": {
                    source: "iana",
                },
                "application/toml": {
                    compressible: true,
                    extensions: ["toml"],
                },
                "application/trickle-ice-sdpfrag": {
                    source: "iana",
                },
                "application/trig": {
                    source: "iana",
                },
                "application/ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttml"],
                },
                "application/tve-trigger": {
                    source: "iana",
                },
                "application/tzif": {
                    source: "iana",
                },
                "application/tzif-leap": {
                    source: "iana",
                },
                "application/ulpfec": {
                    source: "iana",
                },
                "application/urc-grpsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-ressheet+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsheet"],
                },
                "application/urc-targetdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-uisocketdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vemmi": {
                    source: "iana",
                },
                "application/vividence.scriptfile": {
                    source: "apache",
                },
                "application/vnd.1000minds.decision-model+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["1km"],
                },
                "application/vnd.3gpp-prose+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-prose-pc3ch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-v2x-local-service-information": {
                    source: "iana",
                },
                "application/vnd.3gpp.access-transfer-events+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.bsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.gmop+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mc-signalling-ear": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-payload": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-signalling": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-floor-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-signed+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-init-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-transmission-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mid-call+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.pic-bw-large": {
                    source: "iana",
                    extensions: ["plb"],
                },
                "application/vnd.3gpp.pic-bw-small": {
                    source: "iana",
                    extensions: ["psb"],
                },
                "application/vnd.3gpp.pic-bw-var": {
                    source: "iana",
                    extensions: ["pvb"],
                },
                "application/vnd.3gpp.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp.sms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-ext+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.state-and-event-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.ussd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.bcmcsinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp2.tcap": {
                    source: "iana",
                    extensions: ["tcap"],
                },
                "application/vnd.3lightssoftware.imagescal": {
                    source: "iana",
                },
                "application/vnd.3m.post-it-notes": {
                    source: "iana",
                    extensions: ["pwn"],
                },
                "application/vnd.accpac.simply.aso": {
                    source: "iana",
                    extensions: ["aso"],
                },
                "application/vnd.accpac.simply.imp": {
                    source: "iana",
                    extensions: ["imp"],
                },
                "application/vnd.acucobol": {
                    source: "iana",
                    extensions: ["acu"],
                },
                "application/vnd.acucorp": {
                    source: "iana",
                    extensions: ["atc", "acutc"],
                },
                "application/vnd.adobe.air-application-installer-package+zip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["air"],
                },
                "application/vnd.adobe.flash.movie": {
                    source: "iana",
                },
                "application/vnd.adobe.formscentral.fcdt": {
                    source: "iana",
                    extensions: ["fcdt"],
                },
                "application/vnd.adobe.fxp": {
                    source: "iana",
                    extensions: ["fxp", "fxpl"],
                },
                "application/vnd.adobe.partial-upload": {
                    source: "iana",
                },
                "application/vnd.adobe.xdp+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdp"],
                },
                "application/vnd.adobe.xfdf": {
                    source: "iana",
                    extensions: ["xfdf"],
                },
                "application/vnd.aether.imp": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata-pagedef": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-charset": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codedfont": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codepage": {
                    source: "iana",
                },
                "application/vnd.afpc.modca": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-formdef": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-mediummap": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-objectcontainer": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-overlay": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-pagesegment": {
                    source: "iana",
                },
                "application/vnd.ah-barcode": {
                    source: "iana",
                },
                "application/vnd.ahead.space": {
                    source: "iana",
                    extensions: ["ahead"],
                },
                "application/vnd.airzip.filesecure.azf": {
                    source: "iana",
                    extensions: ["azf"],
                },
                "application/vnd.airzip.filesecure.azs": {
                    source: "iana",
                    extensions: ["azs"],
                },
                "application/vnd.amadeus+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.amazon.ebook": {
                    source: "apache",
                    extensions: ["azw"],
                },
                "application/vnd.amazon.mobi8-ebook": {
                    source: "iana",
                },
                "application/vnd.americandynamics.acc": {
                    source: "iana",
                    extensions: ["acc"],
                },
                "application/vnd.amiga.ami": {
                    source: "iana",
                    extensions: ["ami"],
                },
                "application/vnd.amundsen.maze+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.android.ota": {
                    source: "iana",
                },
                "application/vnd.android.package-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["apk"],
                },
                "application/vnd.anki": {
                    source: "iana",
                },
                "application/vnd.anser-web-certificate-issue-initiation": {
                    source: "iana",
                    extensions: ["cii"],
                },
                "application/vnd.anser-web-funds-transfer-initiation": {
                    source: "apache",
                    extensions: ["fti"],
                },
                "application/vnd.antix.game-component": {
                    source: "iana",
                    extensions: ["atx"],
                },
                "application/vnd.apache.thrift.binary": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.compact": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.json": {
                    source: "iana",
                },
                "application/vnd.api+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.aplextor.warrp+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apothekende.reservation+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apple.installer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpkg"],
                },
                "application/vnd.apple.keynote": {
                    source: "iana",
                    extensions: ["keynote"],
                },
                "application/vnd.apple.mpegurl": {
                    source: "iana",
                    extensions: ["m3u8"],
                },
                "application/vnd.apple.numbers": {
                    source: "iana",
                    extensions: ["numbers"],
                },
                "application/vnd.apple.pages": {
                    source: "iana",
                    extensions: ["pages"],
                },
                "application/vnd.apple.pkpass": {
                    compressible: false,
                    extensions: ["pkpass"],
                },
                "application/vnd.arastra.swi": {
                    source: "iana",
                },
                "application/vnd.aristanetworks.swi": {
                    source: "iana",
                    extensions: ["swi"],
                },
                "application/vnd.artisan+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.artsquare": {
                    source: "iana",
                },
                "application/vnd.astraea-software.iota": {
                    source: "iana",
                    extensions: ["iota"],
                },
                "application/vnd.audiograph": {
                    source: "iana",
                    extensions: ["aep"],
                },
                "application/vnd.autopackage": {
                    source: "iana",
                },
                "application/vnd.avalon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.avistar+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.balsamiq.bmml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmml"],
                },
                "application/vnd.balsamiq.bmpr": {
                    source: "iana",
                },
                "application/vnd.banana-accounting": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.error": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bekitzur-stech+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bint.med-content": {
                    source: "iana",
                },
                "application/vnd.biopax.rdf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.blink-idb-value-wrapper": {
                    source: "iana",
                },
                "application/vnd.blueice.multipass": {
                    source: "iana",
                    extensions: ["mpm"],
                },
                "application/vnd.bluetooth.ep.oob": {
                    source: "iana",
                },
                "application/vnd.bluetooth.le.oob": {
                    source: "iana",
                },
                "application/vnd.bmi": {
                    source: "iana",
                    extensions: ["bmi"],
                },
                "application/vnd.bpf": {
                    source: "iana",
                },
                "application/vnd.bpf3": {
                    source: "iana",
                },
                "application/vnd.businessobjects": {
                    source: "iana",
                    extensions: ["rep"],
                },
                "application/vnd.byu.uapi+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cab-jscript": {
                    source: "iana",
                },
                "application/vnd.canon-cpdl": {
                    source: "iana",
                },
                "application/vnd.canon-lips": {
                    source: "iana",
                },
                "application/vnd.capasystems-pg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cendio.thinlinc.clientconf": {
                    source: "iana",
                },
                "application/vnd.century-systems.tcp_stream": {
                    source: "iana",
                },
                "application/vnd.chemdraw+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdxml"],
                },
                "application/vnd.chess-pgn": {
                    source: "iana",
                },
                "application/vnd.chipnuts.karaoke-mmd": {
                    source: "iana",
                    extensions: ["mmd"],
                },
                "application/vnd.ciedi": {
                    source: "iana",
                },
                "application/vnd.cinderella": {
                    source: "iana",
                    extensions: ["cdy"],
                },
                "application/vnd.cirpack.isdn-ext": {
                    source: "iana",
                },
                "application/vnd.citationstyles.style+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csl"],
                },
                "application/vnd.claymore": {
                    source: "iana",
                    extensions: ["cla"],
                },
                "application/vnd.cloanto.rp9": {
                    source: "iana",
                    extensions: ["rp9"],
                },
                "application/vnd.clonk.c4group": {
                    source: "iana",
                    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
                },
                "application/vnd.cluetrust.cartomobile-config": {
                    source: "iana",
                    extensions: ["c11amc"],
                },
                "application/vnd.cluetrust.cartomobile-config-pkg": {
                    source: "iana",
                    extensions: ["c11amz"],
                },
                "application/vnd.coffeescript": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet-template": {
                    source: "iana",
                },
                "application/vnd.collection+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.doc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.next+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.comicbook+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.comicbook-rar": {
                    source: "iana",
                },
                "application/vnd.commerce-battelle": {
                    source: "iana",
                },
                "application/vnd.commonspace": {
                    source: "iana",
                    extensions: ["csp"],
                },
                "application/vnd.contact.cmsg": {
                    source: "iana",
                    extensions: ["cdbcmsg"],
                },
                "application/vnd.coreos.ignition+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cosmocaller": {
                    source: "iana",
                    extensions: ["cmc"],
                },
                "application/vnd.crick.clicker": {
                    source: "iana",
                    extensions: ["clkx"],
                },
                "application/vnd.crick.clicker.keyboard": {
                    source: "iana",
                    extensions: ["clkk"],
                },
                "application/vnd.crick.clicker.palette": {
                    source: "iana",
                    extensions: ["clkp"],
                },
                "application/vnd.crick.clicker.template": {
                    source: "iana",
                    extensions: ["clkt"],
                },
                "application/vnd.crick.clicker.wordbank": {
                    source: "iana",
                    extensions: ["clkw"],
                },
                "application/vnd.criticaltools.wbs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wbs"],
                },
                "application/vnd.cryptii.pipe+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.crypto-shade-file": {
                    source: "iana",
                },
                "application/vnd.ctc-posml": {
                    source: "iana",
                    extensions: ["pml"],
                },
                "application/vnd.ctct.ws+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cups-pdf": {
                    source: "iana",
                },
                "application/vnd.cups-postscript": {
                    source: "iana",
                },
                "application/vnd.cups-ppd": {
                    source: "iana",
                    extensions: ["ppd"],
                },
                "application/vnd.cups-raster": {
                    source: "iana",
                },
                "application/vnd.cups-raw": {
                    source: "iana",
                },
                "application/vnd.curl": {
                    source: "iana",
                },
                "application/vnd.curl.car": {
                    source: "apache",
                    extensions: ["car"],
                },
                "application/vnd.curl.pcurl": {
                    source: "apache",
                    extensions: ["pcurl"],
                },
                "application/vnd.cyan.dean.root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cybank": {
                    source: "iana",
                },
                "application/vnd.d2l.coursepackage1p0+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.dart": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dart"],
                },
                "application/vnd.data-vision.rdz": {
                    source: "iana",
                    extensions: ["rdz"],
                },
                "application/vnd.datapackage+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dataresource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dbf": {
                    source: "iana",
                },
                "application/vnd.debian.binary-package": {
                    source: "iana",
                },
                "application/vnd.dece.data": {
                    source: "iana",
                    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
                },
                "application/vnd.dece.ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uvt", "uvvt"],
                },
                "application/vnd.dece.unspecified": {
                    source: "iana",
                    extensions: ["uvx", "uvvx"],
                },
                "application/vnd.dece.zip": {
                    source: "iana",
                    extensions: ["uvz", "uvvz"],
                },
                "application/vnd.denovo.fcselayout-link": {
                    source: "iana",
                    extensions: ["fe_launch"],
                },
                "application/vnd.desmume.movie": {
                    source: "iana",
                },
                "application/vnd.dir-bi.plate-dl-nosuffix": {
                    source: "iana",
                },
                "application/vnd.dm.delegation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dna": {
                    source: "iana",
                    extensions: ["dna"],
                },
                "application/vnd.document+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dolby.mlp": {
                    source: "apache",
                    extensions: ["mlp"],
                },
                "application/vnd.dolby.mobile.1": {
                    source: "iana",
                },
                "application/vnd.dolby.mobile.2": {
                    source: "iana",
                },
                "application/vnd.doremir.scorecloud-binary-document": {
                    source: "iana",
                },
                "application/vnd.dpgraph": {
                    source: "iana",
                    extensions: ["dpg"],
                },
                "application/vnd.dreamfactory": {
                    source: "iana",
                    extensions: ["dfac"],
                },
                "application/vnd.drive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ds-keypoint": {
                    source: "apache",
                    extensions: ["kpxx"],
                },
                "application/vnd.dtg.local": {
                    source: "iana",
                },
                "application/vnd.dtg.local.flash": {
                    source: "iana",
                },
                "application/vnd.dtg.local.html": {
                    source: "iana",
                },
                "application/vnd.dvb.ait": {
                    source: "iana",
                    extensions: ["ait"],
                },
                "application/vnd.dvb.dvbisl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.dvbj": {
                    source: "iana",
                },
                "application/vnd.dvb.esgcontainer": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcdftnotifaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess2": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgpdd": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcroaming": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-base": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-enhancement": {
                    source: "iana",
                },
                "application/vnd.dvb.notif-aggregate-root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-container+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-generic+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-msglist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-init+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.pfr": {
                    source: "iana",
                },
                "application/vnd.dvb.service": {
                    source: "iana",
                    extensions: ["svc"],
                },
                "application/vnd.dxr": {
                    source: "iana",
                },
                "application/vnd.dynageo": {
                    source: "iana",
                    extensions: ["geo"],
                },
                "application/vnd.dzr": {
                    source: "iana",
                },
                "application/vnd.easykaraoke.cdgdownload": {
                    source: "iana",
                },
                "application/vnd.ecdis-update": {
                    source: "iana",
                },
                "application/vnd.ecip.rlp": {
                    source: "iana",
                },
                "application/vnd.ecowin.chart": {
                    source: "iana",
                    extensions: ["mag"],
                },
                "application/vnd.ecowin.filerequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.fileupdate": {
                    source: "iana",
                },
                "application/vnd.ecowin.series": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesrequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesupdate": {
                    source: "iana",
                },
                "application/vnd.efi.img": {
                    source: "iana",
                },
                "application/vnd.efi.iso": {
                    source: "iana",
                },
                "application/vnd.emclient.accessrequest+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.enliven": {
                    source: "iana",
                    extensions: ["nml"],
                },
                "application/vnd.enphase.envoy": {
                    source: "iana",
                },
                "application/vnd.eprints.data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.epson.esf": {
                    source: "iana",
                    extensions: ["esf"],
                },
                "application/vnd.epson.msf": {
                    source: "iana",
                    extensions: ["msf"],
                },
                "application/vnd.epson.quickanime": {
                    source: "iana",
                    extensions: ["qam"],
                },
                "application/vnd.epson.salt": {
                    source: "iana",
                    extensions: ["slt"],
                },
                "application/vnd.epson.ssf": {
                    source: "iana",
                    extensions: ["ssf"],
                },
                "application/vnd.ericsson.quickcall": {
                    source: "iana",
                },
                "application/vnd.espass-espass+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.eszigno3+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["es3", "et3"],
                },
                "application/vnd.etsi.aoc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.asic-e+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.asic-s+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.cug+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvcommand+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-bc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-cod+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-npvr+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvservice+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mcid+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mheg5": {
                    source: "iana",
                },
                "application/vnd.etsi.overload-control-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.pstn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.sci+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.simservs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.timestamp-token": {
                    source: "iana",
                },
                "application/vnd.etsi.tsl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.tsl.der": {
                    source: "iana",
                },
                "application/vnd.eudora.data": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.profile": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.settings": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.theme": {
                    source: "iana",
                },
                "application/vnd.exstream-empower+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.exstream-package": {
                    source: "iana",
                },
                "application/vnd.ezpix-album": {
                    source: "iana",
                    extensions: ["ez2"],
                },
                "application/vnd.ezpix-package": {
                    source: "iana",
                    extensions: ["ez3"],
                },
                "application/vnd.f-secure.mobile": {
                    source: "iana",
                },
                "application/vnd.fastcopy-disk-image": {
                    source: "iana",
                },
                "application/vnd.fdf": {
                    source: "iana",
                    extensions: ["fdf"],
                },
                "application/vnd.fdsn.mseed": {
                    source: "iana",
                    extensions: ["mseed"],
                },
                "application/vnd.fdsn.seed": {
                    source: "iana",
                    extensions: ["seed", "dataless"],
                },
                "application/vnd.ffsns": {
                    source: "iana",
                },
                "application/vnd.ficlab.flb+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.filmit.zfc": {
                    source: "iana",
                },
                "application/vnd.fints": {
                    source: "iana",
                },
                "application/vnd.firemonkeys.cloudcell": {
                    source: "iana",
                },
                "application/vnd.flographit": {
                    source: "iana",
                    extensions: ["gph"],
                },
                "application/vnd.fluxtime.clip": {
                    source: "iana",
                    extensions: ["ftc"],
                },
                "application/vnd.font-fontforge-sfd": {
                    source: "iana",
                },
                "application/vnd.framemaker": {
                    source: "iana",
                    extensions: ["fm", "frame", "maker", "book"],
                },
                "application/vnd.frogans.fnc": {
                    source: "iana",
                    extensions: ["fnc"],
                },
                "application/vnd.frogans.ltf": {
                    source: "iana",
                    extensions: ["ltf"],
                },
                "application/vnd.fsc.weblaunch": {
                    source: "iana",
                    extensions: ["fsc"],
                },
                "application/vnd.fujitsu.oasys": {
                    source: "iana",
                    extensions: ["oas"],
                },
                "application/vnd.fujitsu.oasys2": {
                    source: "iana",
                    extensions: ["oa2"],
                },
                "application/vnd.fujitsu.oasys3": {
                    source: "iana",
                    extensions: ["oa3"],
                },
                "application/vnd.fujitsu.oasysgp": {
                    source: "iana",
                    extensions: ["fg5"],
                },
                "application/vnd.fujitsu.oasysprs": {
                    source: "iana",
                    extensions: ["bh2"],
                },
                "application/vnd.fujixerox.art-ex": {
                    source: "iana",
                },
                "application/vnd.fujixerox.art4": {
                    source: "iana",
                },
                "application/vnd.fujixerox.ddd": {
                    source: "iana",
                    extensions: ["ddd"],
                },
                "application/vnd.fujixerox.docuworks": {
                    source: "iana",
                    extensions: ["xdw"],
                },
                "application/vnd.fujixerox.docuworks.binder": {
                    source: "iana",
                    extensions: ["xbd"],
                },
                "application/vnd.fujixerox.docuworks.container": {
                    source: "iana",
                },
                "application/vnd.fujixerox.hbpl": {
                    source: "iana",
                },
                "application/vnd.fut-misnet": {
                    source: "iana",
                },
                "application/vnd.futoin+cbor": {
                    source: "iana",
                },
                "application/vnd.futoin+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.fuzzysheet": {
                    source: "iana",
                    extensions: ["fzs"],
                },
                "application/vnd.genomatix.tuxedo": {
                    source: "iana",
                    extensions: ["txd"],
                },
                "application/vnd.gentics.grd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geo+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geocube+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geogebra.file": {
                    source: "iana",
                    extensions: ["ggb"],
                },
                "application/vnd.geogebra.tool": {
                    source: "iana",
                    extensions: ["ggt"],
                },
                "application/vnd.geometry-explorer": {
                    source: "iana",
                    extensions: ["gex", "gre"],
                },
                "application/vnd.geonext": {
                    source: "iana",
                    extensions: ["gxt"],
                },
                "application/vnd.geoplan": {
                    source: "iana",
                    extensions: ["g2w"],
                },
                "application/vnd.geospace": {
                    source: "iana",
                    extensions: ["g3w"],
                },
                "application/vnd.gerber": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt-response": {
                    source: "iana",
                },
                "application/vnd.gmx": {
                    source: "iana",
                    extensions: ["gmx"],
                },
                "application/vnd.google-apps.document": {
                    compressible: false,
                    extensions: ["gdoc"],
                },
                "application/vnd.google-apps.presentation": {
                    compressible: false,
                    extensions: ["gslides"],
                },
                "application/vnd.google-apps.spreadsheet": {
                    compressible: false,
                    extensions: ["gsheet"],
                },
                "application/vnd.google-earth.kml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["kml"],
                },
                "application/vnd.google-earth.kmz": {
                    source: "iana",
                    compressible: false,
                    extensions: ["kmz"],
                },
                "application/vnd.gov.sk.e-form+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.gov.sk.e-form+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.gov.sk.xmldatacontainer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.grafeq": {
                    source: "iana",
                    extensions: ["gqf", "gqs"],
                },
                "application/vnd.gridmp": {
                    source: "iana",
                },
                "application/vnd.groove-account": {
                    source: "iana",
                    extensions: ["gac"],
                },
                "application/vnd.groove-help": {
                    source: "iana",
                    extensions: ["ghf"],
                },
                "application/vnd.groove-identity-message": {
                    source: "iana",
                    extensions: ["gim"],
                },
                "application/vnd.groove-injector": {
                    source: "iana",
                    extensions: ["grv"],
                },
                "application/vnd.groove-tool-message": {
                    source: "iana",
                    extensions: ["gtm"],
                },
                "application/vnd.groove-tool-template": {
                    source: "iana",
                    extensions: ["tpl"],
                },
                "application/vnd.groove-vcard": {
                    source: "iana",
                    extensions: ["vcg"],
                },
                "application/vnd.hal+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hal+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["hal"],
                },
                "application/vnd.handheld-entertainment+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zmm"],
                },
                "application/vnd.hbci": {
                    source: "iana",
                    extensions: ["hbci"],
                },
                "application/vnd.hc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hcl-bireports": {
                    source: "iana",
                },
                "application/vnd.hdt": {
                    source: "iana",
                },
                "application/vnd.heroku+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hhe.lesson-player": {
                    source: "iana",
                    extensions: ["les"],
                },
                "application/vnd.hp-hpgl": {
                    source: "iana",
                    extensions: ["hpgl"],
                },
                "application/vnd.hp-hpid": {
                    source: "iana",
                    extensions: ["hpid"],
                },
                "application/vnd.hp-hps": {
                    source: "iana",
                    extensions: ["hps"],
                },
                "application/vnd.hp-jlyt": {
                    source: "iana",
                    extensions: ["jlt"],
                },
                "application/vnd.hp-pcl": {
                    source: "iana",
                    extensions: ["pcl"],
                },
                "application/vnd.hp-pclxl": {
                    source: "iana",
                    extensions: ["pclxl"],
                },
                "application/vnd.httphone": {
                    source: "iana",
                },
                "application/vnd.hydrostatix.sof-data": {
                    source: "iana",
                    extensions: ["sfd-hdstx"],
                },
                "application/vnd.hyper+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyper-item+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyperdrive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hzn-3d-crossword": {
                    source: "iana",
                },
                "application/vnd.ibm.afplinedata": {
                    source: "iana",
                },
                "application/vnd.ibm.electronic-media": {
                    source: "iana",
                },
                "application/vnd.ibm.minipay": {
                    source: "iana",
                    extensions: ["mpy"],
                },
                "application/vnd.ibm.modcap": {
                    source: "iana",
                    extensions: ["afp", "listafp", "list3820"],
                },
                "application/vnd.ibm.rights-management": {
                    source: "iana",
                    extensions: ["irm"],
                },
                "application/vnd.ibm.secure-container": {
                    source: "iana",
                    extensions: ["sc"],
                },
                "application/vnd.iccprofile": {
                    source: "iana",
                    extensions: ["icc", "icm"],
                },
                "application/vnd.ieee.1905": {
                    source: "iana",
                },
                "application/vnd.igloader": {
                    source: "iana",
                    extensions: ["igl"],
                },
                "application/vnd.imagemeter.folder+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.imagemeter.image+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.immervision-ivp": {
                    source: "iana",
                    extensions: ["ivp"],
                },
                "application/vnd.immervision-ivu": {
                    source: "iana",
                    extensions: ["ivu"],
                },
                "application/vnd.ims.imsccv1p1": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p2": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p3": {
                    source: "iana",
                },
                "application/vnd.ims.lis.v2.result+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy.id+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings.simple+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informedcontrol.rms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informix-visionary": {
                    source: "iana",
                },
                "application/vnd.infotech.project": {
                    source: "iana",
                },
                "application/vnd.infotech.project+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.innopath.wamp.notification": {
                    source: "iana",
                },
                "application/vnd.insors.igm": {
                    source: "iana",
                    extensions: ["igm"],
                },
                "application/vnd.intercon.formnet": {
                    source: "iana",
                    extensions: ["xpw", "xpx"],
                },
                "application/vnd.intergeo": {
                    source: "iana",
                    extensions: ["i2g"],
                },
                "application/vnd.intertrust.digibox": {
                    source: "iana",
                },
                "application/vnd.intertrust.nncp": {
                    source: "iana",
                },
                "application/vnd.intu.qbo": {
                    source: "iana",
                    extensions: ["qbo"],
                },
                "application/vnd.intu.qfx": {
                    source: "iana",
                    extensions: ["qfx"],
                },
                "application/vnd.iptc.g2.catalogitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.conceptitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.knowledgeitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.packageitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.planningitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ipunplugged.rcprofile": {
                    source: "iana",
                    extensions: ["rcprofile"],
                },
                "application/vnd.irepository.package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["irp"],
                },
                "application/vnd.is-xpr": {
                    source: "iana",
                    extensions: ["xpr"],
                },
                "application/vnd.isac.fcs": {
                    source: "iana",
                    extensions: ["fcs"],
                },
                "application/vnd.iso11783-10+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.jam": {
                    source: "iana",
                    extensions: ["jam"],
                },
                "application/vnd.japannet-directory-service": {
                    source: "iana",
                },
                "application/vnd.japannet-jpnstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-payment-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-registration": {
                    source: "iana",
                },
                "application/vnd.japannet-registration-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-setstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-verification": {
                    source: "iana",
                },
                "application/vnd.japannet-verification-wakeup": {
                    source: "iana",
                },
                "application/vnd.jcp.javame.midlet-rms": {
                    source: "iana",
                    extensions: ["rms"],
                },
                "application/vnd.jisp": {
                    source: "iana",
                    extensions: ["jisp"],
                },
                "application/vnd.joost.joda-archive": {
                    source: "iana",
                    extensions: ["joda"],
                },
                "application/vnd.jsk.isdn-ngn": {
                    source: "iana",
                },
                "application/vnd.kahootz": {
                    source: "iana",
                    extensions: ["ktz", "ktr"],
                },
                "application/vnd.kde.karbon": {
                    source: "iana",
                    extensions: ["karbon"],
                },
                "application/vnd.kde.kchart": {
                    source: "iana",
                    extensions: ["chrt"],
                },
                "application/vnd.kde.kformula": {
                    source: "iana",
                    extensions: ["kfo"],
                },
                "application/vnd.kde.kivio": {
                    source: "iana",
                    extensions: ["flw"],
                },
                "application/vnd.kde.kontour": {
                    source: "iana",
                    extensions: ["kon"],
                },
                "application/vnd.kde.kpresenter": {
                    source: "iana",
                    extensions: ["kpr", "kpt"],
                },
                "application/vnd.kde.kspread": {
                    source: "iana",
                    extensions: ["ksp"],
                },
                "application/vnd.kde.kword": {
                    source: "iana",
                    extensions: ["kwd", "kwt"],
                },
                "application/vnd.kenameaapp": {
                    source: "iana",
                    extensions: ["htke"],
                },
                "application/vnd.kidspiration": {
                    source: "iana",
                    extensions: ["kia"],
                },
                "application/vnd.kinar": {
                    source: "iana",
                    extensions: ["kne", "knp"],
                },
                "application/vnd.koan": {
                    source: "iana",
                    extensions: ["skp", "skd", "skt", "skm"],
                },
                "application/vnd.kodak-descriptor": {
                    source: "iana",
                    extensions: ["sse"],
                },
                "application/vnd.las": {
                    source: "iana",
                },
                "application/vnd.las.las+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.las.las+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lasxml"],
                },
                "application/vnd.laszip": {
                    source: "iana",
                },
                "application/vnd.leap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.liberty-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.llamagraphics.life-balance.desktop": {
                    source: "iana",
                    extensions: ["lbd"],
                },
                "application/vnd.llamagraphics.life-balance.exchange+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lbe"],
                },
                "application/vnd.logipipe.circuit+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.loom": {
                    source: "iana",
                },
                "application/vnd.lotus-1-2-3": {
                    source: "iana",
                    extensions: ["123"],
                },
                "application/vnd.lotus-approach": {
                    source: "iana",
                    extensions: ["apr"],
                },
                "application/vnd.lotus-freelance": {
                    source: "iana",
                    extensions: ["pre"],
                },
                "application/vnd.lotus-notes": {
                    source: "iana",
                    extensions: ["nsf"],
                },
                "application/vnd.lotus-organizer": {
                    source: "iana",
                    extensions: ["org"],
                },
                "application/vnd.lotus-screencam": {
                    source: "iana",
                    extensions: ["scm"],
                },
                "application/vnd.lotus-wordpro": {
                    source: "iana",
                    extensions: ["lwp"],
                },
                "application/vnd.macports.portpkg": {
                    source: "iana",
                    extensions: ["portpkg"],
                },
                "application/vnd.mapbox-vector-tile": {
                    source: "iana",
                },
                "application/vnd.marlin.drm.actiontoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.conftoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.license+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.mdcf": {
                    source: "iana",
                },
                "application/vnd.mason+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.maxmind.maxmind-db": {
                    source: "iana",
                },
                "application/vnd.mcd": {
                    source: "iana",
                    extensions: ["mcd"],
                },
                "application/vnd.medcalcdata": {
                    source: "iana",
                    extensions: ["mc1"],
                },
                "application/vnd.mediastation.cdkey": {
                    source: "iana",
                    extensions: ["cdkey"],
                },
                "application/vnd.meridian-slingshot": {
                    source: "iana",
                },
                "application/vnd.mfer": {
                    source: "iana",
                    extensions: ["mwf"],
                },
                "application/vnd.mfmp": {
                    source: "iana",
                    extensions: ["mfm"],
                },
                "application/vnd.micro+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.micrografx.flo": {
                    source: "iana",
                    extensions: ["flo"],
                },
                "application/vnd.micrografx.igx": {
                    source: "iana",
                    extensions: ["igx"],
                },
                "application/vnd.microsoft.portable-executable": {
                    source: "iana",
                },
                "application/vnd.microsoft.windows.thumbnail-cache": {
                    source: "iana",
                },
                "application/vnd.miele+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.mif": {
                    source: "iana",
                    extensions: ["mif"],
                },
                "application/vnd.minisoft-hp3000-save": {
                    source: "iana",
                },
                "application/vnd.mitsubishi.misty-guard.trustweb": {
                    source: "iana",
                },
                "application/vnd.mobius.daf": {
                    source: "iana",
                    extensions: ["daf"],
                },
                "application/vnd.mobius.dis": {
                    source: "iana",
                    extensions: ["dis"],
                },
                "application/vnd.mobius.mbk": {
                    source: "iana",
                    extensions: ["mbk"],
                },
                "application/vnd.mobius.mqy": {
                    source: "iana",
                    extensions: ["mqy"],
                },
                "application/vnd.mobius.msl": {
                    source: "iana",
                    extensions: ["msl"],
                },
                "application/vnd.mobius.plc": {
                    source: "iana",
                    extensions: ["plc"],
                },
                "application/vnd.mobius.txf": {
                    source: "iana",
                    extensions: ["txf"],
                },
                "application/vnd.mophun.application": {
                    source: "iana",
                    extensions: ["mpn"],
                },
                "application/vnd.mophun.certificate": {
                    source: "iana",
                    extensions: ["mpc"],
                },
                "application/vnd.motorola.flexsuite": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.adsi": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.fis": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.gotap": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.kmr": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.ttc": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.wem": {
                    source: "iana",
                },
                "application/vnd.motorola.iprm": {
                    source: "iana",
                },
                "application/vnd.mozilla.xul+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xul"],
                },
                "application/vnd.ms-3mfdocument": {
                    source: "iana",
                },
                "application/vnd.ms-artgalry": {
                    source: "iana",
                    extensions: ["cil"],
                },
                "application/vnd.ms-asf": {
                    source: "iana",
                },
                "application/vnd.ms-cab-compressed": {
                    source: "iana",
                    extensions: ["cab"],
                },
                "application/vnd.ms-color.iccprofile": {
                    source: "apache",
                },
                "application/vnd.ms-excel": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
                },
                "application/vnd.ms-excel.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlam"],
                },
                "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsb"],
                },
                "application/vnd.ms-excel.sheet.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsm"],
                },
                "application/vnd.ms-excel.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["xltm"],
                },
                "application/vnd.ms-fontobject": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eot"],
                },
                "application/vnd.ms-htmlhelp": {
                    source: "iana",
                    extensions: ["chm"],
                },
                "application/vnd.ms-ims": {
                    source: "iana",
                    extensions: ["ims"],
                },
                "application/vnd.ms-lrm": {
                    source: "iana",
                    extensions: ["lrm"],
                },
                "application/vnd.ms-office.activex+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-officetheme": {
                    source: "iana",
                    extensions: ["thmx"],
                },
                "application/vnd.ms-opentype": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-outlook": {
                    compressible: false,
                    extensions: ["msg"],
                },
                "application/vnd.ms-package.obfuscated-opentype": {
                    source: "apache",
                },
                "application/vnd.ms-pki.seccat": {
                    source: "apache",
                    extensions: ["cat"],
                },
                "application/vnd.ms-pki.stl": {
                    source: "apache",
                    extensions: ["stl"],
                },
                "application/vnd.ms-playready.initiator+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-powerpoint": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ppt", "pps", "pot"],
                },
                "application/vnd.ms-powerpoint.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppam"],
                },
                "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
                    source: "iana",
                    extensions: ["pptm"],
                },
                "application/vnd.ms-powerpoint.slide.macroenabled.12": {
                    source: "iana",
                    extensions: ["sldm"],
                },
                "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppsm"],
                },
                "application/vnd.ms-powerpoint.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["potm"],
                },
                "application/vnd.ms-printdevicecapabilities+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-printing.printticket+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-printschematicket+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-project": {
                    source: "iana",
                    extensions: ["mpp", "mpt"],
                },
                "application/vnd.ms-tnef": {
                    source: "iana",
                },
                "application/vnd.ms-windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.nwprinting.oob": {
                    source: "iana",
                },
                "application/vnd.ms-windows.printerpairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.wsd.oob": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-resp": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-resp": {
                    source: "iana",
                },
                "application/vnd.ms-word.document.macroenabled.12": {
                    source: "iana",
                    extensions: ["docm"],
                },
                "application/vnd.ms-word.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["dotm"],
                },
                "application/vnd.ms-works": {
                    source: "iana",
                    extensions: ["wps", "wks", "wcm", "wdb"],
                },
                "application/vnd.ms-wpl": {
                    source: "iana",
                    extensions: ["wpl"],
                },
                "application/vnd.ms-xpsdocument": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xps"],
                },
                "application/vnd.msa-disk-image": {
                    source: "iana",
                },
                "application/vnd.mseq": {
                    source: "iana",
                    extensions: ["mseq"],
                },
                "application/vnd.msign": {
                    source: "iana",
                },
                "application/vnd.multiad.creator": {
                    source: "iana",
                },
                "application/vnd.multiad.creator.cif": {
                    source: "iana",
                },
                "application/vnd.music-niff": {
                    source: "iana",
                },
                "application/vnd.musician": {
                    source: "iana",
                    extensions: ["mus"],
                },
                "application/vnd.muvee.style": {
                    source: "iana",
                    extensions: ["msty"],
                },
                "application/vnd.mynfc": {
                    source: "iana",
                    extensions: ["taglet"],
                },
                "application/vnd.ncd.control": {
                    source: "iana",
                },
                "application/vnd.ncd.reference": {
                    source: "iana",
                },
                "application/vnd.nearst.inv+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nervana": {
                    source: "iana",
                },
                "application/vnd.netfpx": {
                    source: "iana",
                },
                "application/vnd.neurolanguage.nlu": {
                    source: "iana",
                    extensions: ["nlu"],
                },
                "application/vnd.nimn": {
                    source: "iana",
                },
                "application/vnd.nintendo.nitro.rom": {
                    source: "iana",
                },
                "application/vnd.nintendo.snes.rom": {
                    source: "iana",
                },
                "application/vnd.nitf": {
                    source: "iana",
                    extensions: ["ntf", "nitf"],
                },
                "application/vnd.noblenet-directory": {
                    source: "iana",
                    extensions: ["nnd"],
                },
                "application/vnd.noblenet-sealer": {
                    source: "iana",
                    extensions: ["nns"],
                },
                "application/vnd.noblenet-web": {
                    source: "iana",
                    extensions: ["nnw"],
                },
                "application/vnd.nokia.catalogs": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.iptv.config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.isds-radio-presets": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.landmarkcollection+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.n-gage.ac+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ac"],
                },
                "application/vnd.nokia.n-gage.data": {
                    source: "iana",
                    extensions: ["ngdat"],
                },
                "application/vnd.nokia.n-gage.symbian.install": {
                    source: "iana",
                    extensions: ["n-gage"],
                },
                "application/vnd.nokia.ncd": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.radio-preset": {
                    source: "iana",
                    extensions: ["rpst"],
                },
                "application/vnd.nokia.radio-presets": {
                    source: "iana",
                    extensions: ["rpss"],
                },
                "application/vnd.novadigm.edm": {
                    source: "iana",
                    extensions: ["edm"],
                },
                "application/vnd.novadigm.edx": {
                    source: "iana",
                    extensions: ["edx"],
                },
                "application/vnd.novadigm.ext": {
                    source: "iana",
                    extensions: ["ext"],
                },
                "application/vnd.ntt-local.content-share": {
                    source: "iana",
                },
                "application/vnd.ntt-local.file-transfer": {
                    source: "iana",
                },
                "application/vnd.ntt-local.ogw_remote-access": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_remote": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_tcp_stream": {
                    source: "iana",
                },
                "application/vnd.oasis.opendocument.chart": {
                    source: "iana",
                    extensions: ["odc"],
                },
                "application/vnd.oasis.opendocument.chart-template": {
                    source: "iana",
                    extensions: ["otc"],
                },
                "application/vnd.oasis.opendocument.database": {
                    source: "iana",
                    extensions: ["odb"],
                },
                "application/vnd.oasis.opendocument.formula": {
                    source: "iana",
                    extensions: ["odf"],
                },
                "application/vnd.oasis.opendocument.formula-template": {
                    source: "iana",
                    extensions: ["odft"],
                },
                "application/vnd.oasis.opendocument.graphics": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odg"],
                },
                "application/vnd.oasis.opendocument.graphics-template": {
                    source: "iana",
                    extensions: ["otg"],
                },
                "application/vnd.oasis.opendocument.image": {
                    source: "iana",
                    extensions: ["odi"],
                },
                "application/vnd.oasis.opendocument.image-template": {
                    source: "iana",
                    extensions: ["oti"],
                },
                "application/vnd.oasis.opendocument.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odp"],
                },
                "application/vnd.oasis.opendocument.presentation-template": {
                    source: "iana",
                    extensions: ["otp"],
                },
                "application/vnd.oasis.opendocument.spreadsheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ods"],
                },
                "application/vnd.oasis.opendocument.spreadsheet-template": {
                    source: "iana",
                    extensions: ["ots"],
                },
                "application/vnd.oasis.opendocument.text": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odt"],
                },
                "application/vnd.oasis.opendocument.text-master": {
                    source: "iana",
                    extensions: ["odm"],
                },
                "application/vnd.oasis.opendocument.text-template": {
                    source: "iana",
                    extensions: ["ott"],
                },
                "application/vnd.oasis.opendocument.text-web": {
                    source: "iana",
                    extensions: ["oth"],
                },
                "application/vnd.obn": {
                    source: "iana",
                },
                "application/vnd.ocf+cbor": {
                    source: "iana",
                },
                "application/vnd.oci.image.manifest.v1+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oftn.l10n+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessdownload+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessstreaming+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.cspg-hexbinary": {
                    source: "iana",
                },
                "application/vnd.oipf.dae.svg+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.dae.xhtml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.mippvcontrolmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.pae.gem": {
                    source: "iana",
                },
                "application/vnd.oipf.spdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.spdlist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.ueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.userprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.olpc-sugar": {
                    source: "iana",
                    extensions: ["xo"],
                },
                "application/vnd.oma-scws-config": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-request": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-response": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.drm-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.imd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.ltkm": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.notification+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.provisioningtrigger": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgboot": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgdd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sgdu": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.simple-symbol-container": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.smartcard-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sprov+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.stkm": {
                    source: "iana",
                },
                "application/vnd.oma.cab-address-book+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-feature-handler+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-pcc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-subs-invite+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-user-prefs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.dcd": {
                    source: "iana",
                },
                "application/vnd.oma.dcdc": {
                    source: "iana",
                },
                "application/vnd.oma.dd2+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dd2"],
                },
                "application/vnd.oma.drm.risd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.group-usage-list+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+tlv": {
                    source: "iana",
                },
                "application/vnd.oma.pal+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.detailed-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.final-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.groups+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.invocation-descriptor+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.optimized-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.push": {
                    source: "iana",
                },
                "application/vnd.oma.scidm.messages+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.xcap-directory+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.omads-email+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-file+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-folder+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omaloc-supl-init": {
                    source: "iana",
                },
                "application/vnd.onepager": {
                    source: "iana",
                },
                "application/vnd.onepagertamp": {
                    source: "iana",
                },
                "application/vnd.onepagertamx": {
                    source: "iana",
                },
                "application/vnd.onepagertat": {
                    source: "iana",
                },
                "application/vnd.onepagertatp": {
                    source: "iana",
                },
                "application/vnd.onepagertatx": {
                    source: "iana",
                },
                "application/vnd.openblox.game+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["obgx"],
                },
                "application/vnd.openblox.game-binary": {
                    source: "iana",
                },
                "application/vnd.openeye.oeb": {
                    source: "iana",
                },
                "application/vnd.openofficeorg.extension": {
                    source: "apache",
                    extensions: ["oxt"],
                },
                "application/vnd.openstreetmap.data+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osm"],
                },
                "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawing+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pptx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide": {
                    source: "iana",
                    extensions: ["sldx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
                    source: "iana",
                    extensions: ["ppsx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template": {
                    source: "iana",
                    extensions: ["potx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xlsx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
                    source: "iana",
                    extensions: ["xltx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.theme+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.vmldrawing": {
                    source: "iana",
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
                    source: "iana",
                    compressible: false,
                    extensions: ["docx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
                    source: "iana",
                    extensions: ["dotx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.core-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.relationships+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oracle.resource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.orange.indata": {
                    source: "iana",
                },
                "application/vnd.osa.netdeploy": {
                    source: "iana",
                },
                "application/vnd.osgeo.mapguide.package": {
                    source: "iana",
                    extensions: ["mgp"],
                },
                "application/vnd.osgi.bundle": {
                    source: "iana",
                },
                "application/vnd.osgi.dp": {
                    source: "iana",
                    extensions: ["dp"],
                },
                "application/vnd.osgi.subsystem": {
                    source: "iana",
                    extensions: ["esa"],
                },
                "application/vnd.otps.ct-kip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oxli.countgraph": {
                    source: "iana",
                },
                "application/vnd.pagerduty+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.palm": {
                    source: "iana",
                    extensions: ["pdb", "pqa", "oprc"],
                },
                "application/vnd.panoply": {
                    source: "iana",
                },
                "application/vnd.paos.xml": {
                    source: "iana",
                },
                "application/vnd.patentdive": {
                    source: "iana",
                },
                "application/vnd.patientecommsdoc": {
                    source: "iana",
                },
                "application/vnd.pawaafile": {
                    source: "iana",
                    extensions: ["paw"],
                },
                "application/vnd.pcos": {
                    source: "iana",
                },
                "application/vnd.pg.format": {
                    source: "iana",
                    extensions: ["str"],
                },
                "application/vnd.pg.osasli": {
                    source: "iana",
                    extensions: ["ei6"],
                },
                "application/vnd.piaccess.application-licence": {
                    source: "iana",
                },
                "application/vnd.picsel": {
                    source: "iana",
                    extensions: ["efif"],
                },
                "application/vnd.pmi.widget": {
                    source: "iana",
                    extensions: ["wg"],
                },
                "application/vnd.poc.group-advertisement+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.pocketlearn": {
                    source: "iana",
                    extensions: ["plf"],
                },
                "application/vnd.powerbuilder6": {
                    source: "iana",
                    extensions: ["pbd"],
                },
                "application/vnd.powerbuilder6-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75-s": {
                    source: "iana",
                },
                "application/vnd.preminet": {
                    source: "iana",
                },
                "application/vnd.previewsystems.box": {
                    source: "iana",
                    extensions: ["box"],
                },
                "application/vnd.proteus.magazine": {
                    source: "iana",
                    extensions: ["mgz"],
                },
                "application/vnd.psfs": {
                    source: "iana",
                },
                "application/vnd.publishare-delta-tree": {
                    source: "iana",
                    extensions: ["qps"],
                },
                "application/vnd.pvi.ptid1": {
                    source: "iana",
                    extensions: ["ptid"],
                },
                "application/vnd.pwg-multiplexed": {
                    source: "iana",
                },
                "application/vnd.pwg-xhtml-print+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.qualcomm.brew-app-res": {
                    source: "iana",
                },
                "application/vnd.quarantainenet": {
                    source: "iana",
                },
                "application/vnd.quark.quarkxpress": {
                    source: "iana",
                    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
                },
                "application/vnd.quobject-quoxdocument": {
                    source: "iana",
                },
                "application/vnd.radisys.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-stream+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-base+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-detect+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-group+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-speech+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-transform+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rainstor.data": {
                    source: "iana",
                },
                "application/vnd.rapid": {
                    source: "iana",
                },
                "application/vnd.rar": {
                    source: "iana",
                },
                "application/vnd.realvnc.bed": {
                    source: "iana",
                    extensions: ["bed"],
                },
                "application/vnd.recordare.musicxml": {
                    source: "iana",
                    extensions: ["mxl"],
                },
                "application/vnd.recordare.musicxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musicxml"],
                },
                "application/vnd.renlearn.rlprint": {
                    source: "iana",
                },
                "application/vnd.restful+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rig.cryptonote": {
                    source: "iana",
                    extensions: ["cryptonote"],
                },
                "application/vnd.rim.cod": {
                    source: "apache",
                    extensions: ["cod"],
                },
                "application/vnd.rn-realmedia": {
                    source: "apache",
                    extensions: ["rm"],
                },
                "application/vnd.rn-realmedia-vbr": {
                    source: "apache",
                    extensions: ["rmvb"],
                },
                "application/vnd.route66.link66+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["link66"],
                },
                "application/vnd.rs-274x": {
                    source: "iana",
                },
                "application/vnd.ruckus.download": {
                    source: "iana",
                },
                "application/vnd.s3sms": {
                    source: "iana",
                },
                "application/vnd.sailingtracker.track": {
                    source: "iana",
                    extensions: ["st"],
                },
                "application/vnd.sar": {
                    source: "iana",
                },
                "application/vnd.sbm.cid": {
                    source: "iana",
                },
                "application/vnd.sbm.mid2": {
                    source: "iana",
                },
                "application/vnd.scribus": {
                    source: "iana",
                },
                "application/vnd.sealed.3df": {
                    source: "iana",
                },
                "application/vnd.sealed.csf": {
                    source: "iana",
                },
                "application/vnd.sealed.doc": {
                    source: "iana",
                },
                "application/vnd.sealed.eml": {
                    source: "iana",
                },
                "application/vnd.sealed.mht": {
                    source: "iana",
                },
                "application/vnd.sealed.net": {
                    source: "iana",
                },
                "application/vnd.sealed.ppt": {
                    source: "iana",
                },
                "application/vnd.sealed.tiff": {
                    source: "iana",
                },
                "application/vnd.sealed.xls": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.html": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.pdf": {
                    source: "iana",
                },
                "application/vnd.seemail": {
                    source: "iana",
                    extensions: ["see"],
                },
                "application/vnd.sema": {
                    source: "iana",
                    extensions: ["sema"],
                },
                "application/vnd.semd": {
                    source: "iana",
                    extensions: ["semd"],
                },
                "application/vnd.semf": {
                    source: "iana",
                    extensions: ["semf"],
                },
                "application/vnd.shade-save-file": {
                    source: "iana",
                },
                "application/vnd.shana.informed.formdata": {
                    source: "iana",
                    extensions: ["ifm"],
                },
                "application/vnd.shana.informed.formtemplate": {
                    source: "iana",
                    extensions: ["itp"],
                },
                "application/vnd.shana.informed.interchange": {
                    source: "iana",
                    extensions: ["iif"],
                },
                "application/vnd.shana.informed.package": {
                    source: "iana",
                    extensions: ["ipk"],
                },
                "application/vnd.shootproof+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shopkick+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shp": {
                    source: "iana",
                },
                "application/vnd.shx": {
                    source: "iana",
                },
                "application/vnd.sigrok.session": {
                    source: "iana",
                },
                "application/vnd.simtech-mindmapper": {
                    source: "iana",
                    extensions: ["twd", "twds"],
                },
                "application/vnd.siren+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.smaf": {
                    source: "iana",
                    extensions: ["mmf"],
                },
                "application/vnd.smart.notebook": {
                    source: "iana",
                },
                "application/vnd.smart.teacher": {
                    source: "iana",
                    extensions: ["teacher"],
                },
                "application/vnd.snesdev-page-table": {
                    source: "iana",
                },
                "application/vnd.software602.filler.form+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fo"],
                },
                "application/vnd.software602.filler.form-xml-zip": {
                    source: "iana",
                },
                "application/vnd.solent.sdkm+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sdkm", "sdkd"],
                },
                "application/vnd.spotfire.dxp": {
                    source: "iana",
                    extensions: ["dxp"],
                },
                "application/vnd.spotfire.sfs": {
                    source: "iana",
                    extensions: ["sfs"],
                },
                "application/vnd.sqlite3": {
                    source: "iana",
                },
                "application/vnd.sss-cod": {
                    source: "iana",
                },
                "application/vnd.sss-dtf": {
                    source: "iana",
                },
                "application/vnd.sss-ntf": {
                    source: "iana",
                },
                "application/vnd.stardivision.calc": {
                    source: "apache",
                    extensions: ["sdc"],
                },
                "application/vnd.stardivision.draw": {
                    source: "apache",
                    extensions: ["sda"],
                },
                "application/vnd.stardivision.impress": {
                    source: "apache",
                    extensions: ["sdd"],
                },
                "application/vnd.stardivision.math": {
                    source: "apache",
                    extensions: ["smf"],
                },
                "application/vnd.stardivision.writer": {
                    source: "apache",
                    extensions: ["sdw", "vor"],
                },
                "application/vnd.stardivision.writer-global": {
                    source: "apache",
                    extensions: ["sgl"],
                },
                "application/vnd.stepmania.package": {
                    source: "iana",
                    extensions: ["smzip"],
                },
                "application/vnd.stepmania.stepchart": {
                    source: "iana",
                    extensions: ["sm"],
                },
                "application/vnd.street-stream": {
                    source: "iana",
                },
                "application/vnd.sun.wadl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wadl"],
                },
                "application/vnd.sun.xml.calc": {
                    source: "apache",
                    extensions: ["sxc"],
                },
                "application/vnd.sun.xml.calc.template": {
                    source: "apache",
                    extensions: ["stc"],
                },
                "application/vnd.sun.xml.draw": {
                    source: "apache",
                    extensions: ["sxd"],
                },
                "application/vnd.sun.xml.draw.template": {
                    source: "apache",
                    extensions: ["std"],
                },
                "application/vnd.sun.xml.impress": {
                    source: "apache",
                    extensions: ["sxi"],
                },
                "application/vnd.sun.xml.impress.template": {
                    source: "apache",
                    extensions: ["sti"],
                },
                "application/vnd.sun.xml.math": {
                    source: "apache",
                    extensions: ["sxm"],
                },
                "application/vnd.sun.xml.writer": {
                    source: "apache",
                    extensions: ["sxw"],
                },
                "application/vnd.sun.xml.writer.global": {
                    source: "apache",
                    extensions: ["sxg"],
                },
                "application/vnd.sun.xml.writer.template": {
                    source: "apache",
                    extensions: ["stw"],
                },
                "application/vnd.sus-calendar": {
                    source: "iana",
                    extensions: ["sus", "susp"],
                },
                "application/vnd.svd": {
                    source: "iana",
                    extensions: ["svd"],
                },
                "application/vnd.swiftview-ics": {
                    source: "iana",
                },
                "application/vnd.symbian.install": {
                    source: "apache",
                    extensions: ["sis", "sisx"],
                },
                "application/vnd.syncml+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xsm"],
                },
                "application/vnd.syncml.dm+wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["bdm"],
                },
                "application/vnd.syncml.dm+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xdm"],
                },
                "application/vnd.syncml.dm.notification": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["ddf"],
                },
                "application/vnd.syncml.dmtnds+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmtnds+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.syncml.ds.notification": {
                    source: "iana",
                },
                "application/vnd.tableschema+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tao.intent-module-archive": {
                    source: "iana",
                    extensions: ["tao"],
                },
                "application/vnd.tcpdump.pcap": {
                    source: "iana",
                    extensions: ["pcap", "cap", "dmp"],
                },
                "application/vnd.think-cell.ppttc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tmd.mediaflex.api+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tml": {
                    source: "iana",
                },
                "application/vnd.tmobile-livetv": {
                    source: "iana",
                    extensions: ["tmo"],
                },
                "application/vnd.tri.onesource": {
                    source: "iana",
                },
                "application/vnd.trid.tpt": {
                    source: "iana",
                    extensions: ["tpt"],
                },
                "application/vnd.triscape.mxs": {
                    source: "iana",
                    extensions: ["mxs"],
                },
                "application/vnd.trueapp": {
                    source: "iana",
                    extensions: ["tra"],
                },
                "application/vnd.truedoc": {
                    source: "iana",
                },
                "application/vnd.ubisoft.webplayer": {
                    source: "iana",
                },
                "application/vnd.ufdl": {
                    source: "iana",
                    extensions: ["ufd", "ufdl"],
                },
                "application/vnd.uiq.theme": {
                    source: "iana",
                    extensions: ["utz"],
                },
                "application/vnd.umajin": {
                    source: "iana",
                    extensions: ["umj"],
                },
                "application/vnd.unity": {
                    source: "iana",
                    extensions: ["unityweb"],
                },
                "application/vnd.uoml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uoml"],
                },
                "application/vnd.uplanet.alert": {
                    source: "iana",
                },
                "application/vnd.uplanet.alert-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.list": {
                    source: "iana",
                },
                "application/vnd.uplanet.list-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.signal": {
                    source: "iana",
                },
                "application/vnd.uri-map": {
                    source: "iana",
                },
                "application/vnd.valve.source.material": {
                    source: "iana",
                },
                "application/vnd.vcx": {
                    source: "iana",
                    extensions: ["vcx"],
                },
                "application/vnd.vd-study": {
                    source: "iana",
                },
                "application/vnd.vectorworks": {
                    source: "iana",
                },
                "application/vnd.vel+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.verimatrix.vcas": {
                    source: "iana",
                },
                "application/vnd.veryant.thin": {
                    source: "iana",
                },
                "application/vnd.ves.encrypted": {
                    source: "iana",
                },
                "application/vnd.vidsoft.vidconference": {
                    source: "iana",
                },
                "application/vnd.visio": {
                    source: "iana",
                    extensions: ["vsd", "vst", "vss", "vsw"],
                },
                "application/vnd.visionary": {
                    source: "iana",
                    extensions: ["vis"],
                },
                "application/vnd.vividence.scriptfile": {
                    source: "iana",
                },
                "application/vnd.vsf": {
                    source: "iana",
                    extensions: ["vsf"],
                },
                "application/vnd.wap.sic": {
                    source: "iana",
                },
                "application/vnd.wap.slc": {
                    source: "iana",
                },
                "application/vnd.wap.wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["wbxml"],
                },
                "application/vnd.wap.wmlc": {
                    source: "iana",
                    extensions: ["wmlc"],
                },
                "application/vnd.wap.wmlscriptc": {
                    source: "iana",
                    extensions: ["wmlsc"],
                },
                "application/vnd.webturbo": {
                    source: "iana",
                    extensions: ["wtb"],
                },
                "application/vnd.wfa.p2p": {
                    source: "iana",
                },
                "application/vnd.wfa.wsc": {
                    source: "iana",
                },
                "application/vnd.windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.wmc": {
                    source: "iana",
                },
                "application/vnd.wmf.bootstrap": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica.package": {
                    source: "iana",
                },
                "application/vnd.wolfram.player": {
                    source: "iana",
                    extensions: ["nbp"],
                },
                "application/vnd.wordperfect": {
                    source: "iana",
                    extensions: ["wpd"],
                },
                "application/vnd.wqd": {
                    source: "iana",
                    extensions: ["wqd"],
                },
                "application/vnd.wrq-hp3000-labelled": {
                    source: "iana",
                },
                "application/vnd.wt.stf": {
                    source: "iana",
                    extensions: ["stf"],
                },
                "application/vnd.wv.csp+wbxml": {
                    source: "iana",
                },
                "application/vnd.wv.csp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.wv.ssp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xacml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xara": {
                    source: "iana",
                    extensions: ["xar"],
                },
                "application/vnd.xfdl": {
                    source: "iana",
                    extensions: ["xfdl"],
                },
                "application/vnd.xfdl.webform": {
                    source: "iana",
                },
                "application/vnd.xmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xmpie.cpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.dpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.plan": {
                    source: "iana",
                },
                "application/vnd.xmpie.ppkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.xlim": {
                    source: "iana",
                },
                "application/vnd.yamaha.hv-dic": {
                    source: "iana",
                    extensions: ["hvd"],
                },
                "application/vnd.yamaha.hv-script": {
                    source: "iana",
                    extensions: ["hvs"],
                },
                "application/vnd.yamaha.hv-voice": {
                    source: "iana",
                    extensions: ["hvp"],
                },
                "application/vnd.yamaha.openscoreformat": {
                    source: "iana",
                    extensions: ["osf"],
                },
                "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osfpvg"],
                },
                "application/vnd.yamaha.remote-setup": {
                    source: "iana",
                },
                "application/vnd.yamaha.smaf-audio": {
                    source: "iana",
                    extensions: ["saf"],
                },
                "application/vnd.yamaha.smaf-phrase": {
                    source: "iana",
                    extensions: ["spf"],
                },
                "application/vnd.yamaha.through-ngn": {
                    source: "iana",
                },
                "application/vnd.yamaha.tunnel-udpencap": {
                    source: "iana",
                },
                "application/vnd.yaoweme": {
                    source: "iana",
                },
                "application/vnd.yellowriver-custom-menu": {
                    source: "iana",
                    extensions: ["cmp"],
                },
                "application/vnd.youtube.yt": {
                    source: "iana",
                },
                "application/vnd.zul": {
                    source: "iana",
                    extensions: ["zir", "zirz"],
                },
                "application/vnd.zzazz.deck+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zaz"],
                },
                "application/voicexml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vxml"],
                },
                "application/voucher-cms+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vq-rtcpxr": {
                    source: "iana",
                },
                "application/wasm": {
                    compressible: true,
                    extensions: ["wasm"],
                },
                "application/watcherinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/webpush-options+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/whoispp-query": {
                    source: "iana",
                },
                "application/whoispp-response": {
                    source: "iana",
                },
                "application/widget": {
                    source: "iana",
                    extensions: ["wgt"],
                },
                "application/winhlp": {
                    source: "apache",
                    extensions: ["hlp"],
                },
                "application/wita": {
                    source: "iana",
                },
                "application/wordperfect5.1": {
                    source: "iana",
                },
                "application/wsdl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wsdl"],
                },
                "application/wspolicy+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wspolicy"],
                },
                "application/x-7z-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["7z"],
                },
                "application/x-abiword": {
                    source: "apache",
                    extensions: ["abw"],
                },
                "application/x-ace-compressed": {
                    source: "apache",
                    extensions: ["ace"],
                },
                "application/x-amf": {
                    source: "apache",
                },
                "application/x-apple-diskimage": {
                    source: "apache",
                    extensions: ["dmg"],
                },
                "application/x-arj": {
                    compressible: false,
                    extensions: ["arj"],
                },
                "application/x-authorware-bin": {
                    source: "apache",
                    extensions: ["aab", "x32", "u32", "vox"],
                },
                "application/x-authorware-map": {
                    source: "apache",
                    extensions: ["aam"],
                },
                "application/x-authorware-seg": {
                    source: "apache",
                    extensions: ["aas"],
                },
                "application/x-bcpio": {
                    source: "apache",
                    extensions: ["bcpio"],
                },
                "application/x-bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/x-bittorrent": {
                    source: "apache",
                    extensions: ["torrent"],
                },
                "application/x-blorb": {
                    source: "apache",
                    extensions: ["blb", "blorb"],
                },
                "application/x-bzip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz"],
                },
                "application/x-bzip2": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz2", "boz"],
                },
                "application/x-cbr": {
                    source: "apache",
                    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
                },
                "application/x-cdlink": {
                    source: "apache",
                    extensions: ["vcd"],
                },
                "application/x-cfs-compressed": {
                    source: "apache",
                    extensions: ["cfs"],
                },
                "application/x-chat": {
                    source: "apache",
                    extensions: ["chat"],
                },
                "application/x-chess-pgn": {
                    source: "apache",
                    extensions: ["pgn"],
                },
                "application/x-chrome-extension": {
                    extensions: ["crx"],
                },
                "application/x-cocoa": {
                    source: "nginx",
                    extensions: ["cco"],
                },
                "application/x-compress": {
                    source: "apache",
                },
                "application/x-conference": {
                    source: "apache",
                    extensions: ["nsc"],
                },
                "application/x-cpio": {
                    source: "apache",
                    extensions: ["cpio"],
                },
                "application/x-csh": {
                    source: "apache",
                    extensions: ["csh"],
                },
                "application/x-deb": {
                    compressible: false,
                },
                "application/x-debian-package": {
                    source: "apache",
                    extensions: ["deb", "udeb"],
                },
                "application/x-dgc-compressed": {
                    source: "apache",
                    extensions: ["dgc"],
                },
                "application/x-director": {
                    source: "apache",
                    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
                },
                "application/x-doom": {
                    source: "apache",
                    extensions: ["wad"],
                },
                "application/x-dtbncx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ncx"],
                },
                "application/x-dtbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dtb"],
                },
                "application/x-dtbresource+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["res"],
                },
                "application/x-dvi": {
                    source: "apache",
                    compressible: false,
                    extensions: ["dvi"],
                },
                "application/x-envoy": {
                    source: "apache",
                    extensions: ["evy"],
                },
                "application/x-eva": {
                    source: "apache",
                    extensions: ["eva"],
                },
                "application/x-font-bdf": {
                    source: "apache",
                    extensions: ["bdf"],
                },
                "application/x-font-dos": {
                    source: "apache",
                },
                "application/x-font-framemaker": {
                    source: "apache",
                },
                "application/x-font-ghostscript": {
                    source: "apache",
                    extensions: ["gsf"],
                },
                "application/x-font-libgrx": {
                    source: "apache",
                },
                "application/x-font-linux-psf": {
                    source: "apache",
                    extensions: ["psf"],
                },
                "application/x-font-pcf": {
                    source: "apache",
                    extensions: ["pcf"],
                },
                "application/x-font-snf": {
                    source: "apache",
                    extensions: ["snf"],
                },
                "application/x-font-speedo": {
                    source: "apache",
                },
                "application/x-font-sunos-news": {
                    source: "apache",
                },
                "application/x-font-type1": {
                    source: "apache",
                    extensions: ["pfa", "pfb", "pfm", "afm"],
                },
                "application/x-font-vfont": {
                    source: "apache",
                },
                "application/x-freearc": {
                    source: "apache",
                    extensions: ["arc"],
                },
                "application/x-futuresplash": {
                    source: "apache",
                    extensions: ["spl"],
                },
                "application/x-gca-compressed": {
                    source: "apache",
                    extensions: ["gca"],
                },
                "application/x-glulx": {
                    source: "apache",
                    extensions: ["ulx"],
                },
                "application/x-gnumeric": {
                    source: "apache",
                    extensions: ["gnumeric"],
                },
                "application/x-gramps-xml": {
                    source: "apache",
                    extensions: ["gramps"],
                },
                "application/x-gtar": {
                    source: "apache",
                    extensions: ["gtar"],
                },
                "application/x-gzip": {
                    source: "apache",
                },
                "application/x-hdf": {
                    source: "apache",
                    extensions: ["hdf"],
                },
                "application/x-httpd-php": {
                    compressible: true,
                    extensions: ["php"],
                },
                "application/x-install-instructions": {
                    source: "apache",
                    extensions: ["install"],
                },
                "application/x-iso9660-image": {
                    source: "apache",
                    extensions: ["iso"],
                },
                "application/x-java-archive-diff": {
                    source: "nginx",
                    extensions: ["jardiff"],
                },
                "application/x-java-jnlp-file": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jnlp"],
                },
                "application/x-javascript": {
                    compressible: true,
                },
                "application/x-keepass2": {
                    extensions: ["kdbx"],
                },
                "application/x-latex": {
                    source: "apache",
                    compressible: false,
                    extensions: ["latex"],
                },
                "application/x-lua-bytecode": {
                    extensions: ["luac"],
                },
                "application/x-lzh-compressed": {
                    source: "apache",
                    extensions: ["lzh", "lha"],
                },
                "application/x-makeself": {
                    source: "nginx",
                    extensions: ["run"],
                },
                "application/x-mie": {
                    source: "apache",
                    extensions: ["mie"],
                },
                "application/x-mobipocket-ebook": {
                    source: "apache",
                    extensions: ["prc", "mobi"],
                },
                "application/x-mpegurl": {
                    compressible: false,
                },
                "application/x-ms-application": {
                    source: "apache",
                    extensions: ["application"],
                },
                "application/x-ms-shortcut": {
                    source: "apache",
                    extensions: ["lnk"],
                },
                "application/x-ms-wmd": {
                    source: "apache",
                    extensions: ["wmd"],
                },
                "application/x-ms-wmz": {
                    source: "apache",
                    extensions: ["wmz"],
                },
                "application/x-ms-xbap": {
                    source: "apache",
                    extensions: ["xbap"],
                },
                "application/x-msaccess": {
                    source: "apache",
                    extensions: ["mdb"],
                },
                "application/x-msbinder": {
                    source: "apache",
                    extensions: ["obd"],
                },
                "application/x-mscardfile": {
                    source: "apache",
                    extensions: ["crd"],
                },
                "application/x-msclip": {
                    source: "apache",
                    extensions: ["clp"],
                },
                "application/x-msdos-program": {
                    extensions: ["exe"],
                },
                "application/x-msdownload": {
                    source: "apache",
                    extensions: ["exe", "dll", "com", "bat", "msi"],
                },
                "application/x-msmediaview": {
                    source: "apache",
                    extensions: ["mvb", "m13", "m14"],
                },
                "application/x-msmetafile": {
                    source: "apache",
                    extensions: ["wmf", "wmz", "emf", "emz"],
                },
                "application/x-msmoney": {
                    source: "apache",
                    extensions: ["mny"],
                },
                "application/x-mspublisher": {
                    source: "apache",
                    extensions: ["pub"],
                },
                "application/x-msschedule": {
                    source: "apache",
                    extensions: ["scd"],
                },
                "application/x-msterminal": {
                    source: "apache",
                    extensions: ["trm"],
                },
                "application/x-mswrite": {
                    source: "apache",
                    extensions: ["wri"],
                },
                "application/x-netcdf": {
                    source: "apache",
                    extensions: ["nc", "cdf"],
                },
                "application/x-ns-proxy-autoconfig": {
                    compressible: true,
                    extensions: ["pac"],
                },
                "application/x-nzb": {
                    source: "apache",
                    extensions: ["nzb"],
                },
                "application/x-perl": {
                    source: "nginx",
                    extensions: ["pl", "pm"],
                },
                "application/x-pilot": {
                    source: "nginx",
                    extensions: ["prc", "pdb"],
                },
                "application/x-pkcs12": {
                    source: "apache",
                    compressible: false,
                    extensions: ["p12", "pfx"],
                },
                "application/x-pkcs7-certificates": {
                    source: "apache",
                    extensions: ["p7b", "spc"],
                },
                "application/x-pkcs7-certreqresp": {
                    source: "apache",
                    extensions: ["p7r"],
                },
                "application/x-pki-message": {
                    source: "iana",
                },
                "application/x-rar-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["rar"],
                },
                "application/x-redhat-package-manager": {
                    source: "nginx",
                    extensions: ["rpm"],
                },
                "application/x-research-info-systems": {
                    source: "apache",
                    extensions: ["ris"],
                },
                "application/x-sea": {
                    source: "nginx",
                    extensions: ["sea"],
                },
                "application/x-sh": {
                    source: "apache",
                    compressible: true,
                    extensions: ["sh"],
                },
                "application/x-shar": {
                    source: "apache",
                    extensions: ["shar"],
                },
                "application/x-shockwave-flash": {
                    source: "apache",
                    compressible: false,
                    extensions: ["swf"],
                },
                "application/x-silverlight-app": {
                    source: "apache",
                    extensions: ["xap"],
                },
                "application/x-sql": {
                    source: "apache",
                    extensions: ["sql"],
                },
                "application/x-stuffit": {
                    source: "apache",
                    compressible: false,
                    extensions: ["sit"],
                },
                "application/x-stuffitx": {
                    source: "apache",
                    extensions: ["sitx"],
                },
                "application/x-subrip": {
                    source: "apache",
                    extensions: ["srt"],
                },
                "application/x-sv4cpio": {
                    source: "apache",
                    extensions: ["sv4cpio"],
                },
                "application/x-sv4crc": {
                    source: "apache",
                    extensions: ["sv4crc"],
                },
                "application/x-t3vm-image": {
                    source: "apache",
                    extensions: ["t3"],
                },
                "application/x-tads": {
                    source: "apache",
                    extensions: ["gam"],
                },
                "application/x-tar": {
                    source: "apache",
                    compressible: true,
                    extensions: ["tar"],
                },
                "application/x-tcl": {
                    source: "apache",
                    extensions: ["tcl", "tk"],
                },
                "application/x-tex": {
                    source: "apache",
                    extensions: ["tex"],
                },
                "application/x-tex-tfm": {
                    source: "apache",
                    extensions: ["tfm"],
                },
                "application/x-texinfo": {
                    source: "apache",
                    extensions: ["texinfo", "texi"],
                },
                "application/x-tgif": {
                    source: "apache",
                    extensions: ["obj"],
                },
                "application/x-ustar": {
                    source: "apache",
                    extensions: ["ustar"],
                },
                "application/x-virtualbox-hdd": {
                    compressible: true,
                    extensions: ["hdd"],
                },
                "application/x-virtualbox-ova": {
                    compressible: true,
                    extensions: ["ova"],
                },
                "application/x-virtualbox-ovf": {
                    compressible: true,
                    extensions: ["ovf"],
                },
                "application/x-virtualbox-vbox": {
                    compressible: true,
                    extensions: ["vbox"],
                },
                "application/x-virtualbox-vbox-extpack": {
                    compressible: false,
                    extensions: ["vbox-extpack"],
                },
                "application/x-virtualbox-vdi": {
                    compressible: true,
                    extensions: ["vdi"],
                },
                "application/x-virtualbox-vhd": {
                    compressible: true,
                    extensions: ["vhd"],
                },
                "application/x-virtualbox-vmdk": {
                    compressible: true,
                    extensions: ["vmdk"],
                },
                "application/x-wais-source": {
                    source: "apache",
                    extensions: ["src"],
                },
                "application/x-web-app-manifest+json": {
                    compressible: true,
                    extensions: ["webapp"],
                },
                "application/x-www-form-urlencoded": {
                    source: "iana",
                    compressible: true,
                },
                "application/x-x509-ca-cert": {
                    source: "iana",
                    extensions: ["der", "crt", "pem"],
                },
                "application/x-x509-ca-ra-cert": {
                    source: "iana",
                },
                "application/x-x509-next-ca-cert": {
                    source: "iana",
                },
                "application/x-xfig": {
                    source: "apache",
                    extensions: ["fig"],
                },
                "application/x-xliff+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/x-xpinstall": {
                    source: "apache",
                    compressible: false,
                    extensions: ["xpi"],
                },
                "application/x-xz": {
                    source: "apache",
                    extensions: ["xz"],
                },
                "application/x-zmachine": {
                    source: "apache",
                    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
                },
                "application/x400-bp": {
                    source: "iana",
                },
                "application/xacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xaml+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xaml"],
                },
                "application/xcap-att+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xav"],
                },
                "application/xcap-caps+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xca"],
                },
                "application/xcap-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/xcap-el+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xel"],
                },
                "application/xcap-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/xcap-ns+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xns"],
                },
                "application/xcon-conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xcon-conference-info-diff+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xenc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xenc"],
                },
                "application/xhtml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xhtml", "xht"],
                },
                "application/xhtml-voice+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/xliff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml", "xsl", "xsd", "rng"],
                },
                "application/xml-dtd": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dtd"],
                },
                "application/xml-external-parsed-entity": {
                    source: "iana",
                },
                "application/xml-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xmpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xop+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xop"],
                },
                "application/xproc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xpl"],
                },
                "application/xslt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xslt"],
                },
                "application/xspf+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xspf"],
                },
                "application/xv+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mxml", "xhvml", "xvml", "xvm"],
                },
                "application/yang": {
                    source: "iana",
                    extensions: ["yang"],
                },
                "application/yang-data+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yin+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["yin"],
                },
                "application/zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["zip"],
                },
                "application/zlib": {
                    source: "iana",
                },
                "application/zstd": {
                    source: "iana",
                },
                "audio/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "audio/32kadpcm": {
                    source: "iana",
                },
                "audio/3gpp": {
                    source: "iana",
                    compressible: false,
                    extensions: ["3gpp"],
                },
                "audio/3gpp2": {
                    source: "iana",
                },
                "audio/aac": {
                    source: "iana",
                },
                "audio/ac3": {
                    source: "iana",
                },
                "audio/adpcm": {
                    source: "apache",
                    extensions: ["adp"],
                },
                "audio/amr": {
                    source: "iana",
                },
                "audio/amr-wb": {
                    source: "iana",
                },
                "audio/amr-wb+": {
                    source: "iana",
                },
                "audio/aptx": {
                    source: "iana",
                },
                "audio/asc": {
                    source: "iana",
                },
                "audio/atrac-advanced-lossless": {
                    source: "iana",
                },
                "audio/atrac-x": {
                    source: "iana",
                },
                "audio/atrac3": {
                    source: "iana",
                },
                "audio/basic": {
                    source: "iana",
                    compressible: false,
                    extensions: ["au", "snd"],
                },
                "audio/bv16": {
                    source: "iana",
                },
                "audio/bv32": {
                    source: "iana",
                },
                "audio/clearmode": {
                    source: "iana",
                },
                "audio/cn": {
                    source: "iana",
                },
                "audio/dat12": {
                    source: "iana",
                },
                "audio/dls": {
                    source: "iana",
                },
                "audio/dsr-es201108": {
                    source: "iana",
                },
                "audio/dsr-es202050": {
                    source: "iana",
                },
                "audio/dsr-es202211": {
                    source: "iana",
                },
                "audio/dsr-es202212": {
                    source: "iana",
                },
                "audio/dv": {
                    source: "iana",
                },
                "audio/dvi4": {
                    source: "iana",
                },
                "audio/eac3": {
                    source: "iana",
                },
                "audio/encaprtp": {
                    source: "iana",
                },
                "audio/evrc": {
                    source: "iana",
                },
                "audio/evrc-qcp": {
                    source: "iana",
                },
                "audio/evrc0": {
                    source: "iana",
                },
                "audio/evrc1": {
                    source: "iana",
                },
                "audio/evrcb": {
                    source: "iana",
                },
                "audio/evrcb0": {
                    source: "iana",
                },
                "audio/evrcb1": {
                    source: "iana",
                },
                "audio/evrcnw": {
                    source: "iana",
                },
                "audio/evrcnw0": {
                    source: "iana",
                },
                "audio/evrcnw1": {
                    source: "iana",
                },
                "audio/evrcwb": {
                    source: "iana",
                },
                "audio/evrcwb0": {
                    source: "iana",
                },
                "audio/evrcwb1": {
                    source: "iana",
                },
                "audio/evs": {
                    source: "iana",
                },
                "audio/flexfec": {
                    source: "iana",
                },
                "audio/fwdred": {
                    source: "iana",
                },
                "audio/g711-0": {
                    source: "iana",
                },
                "audio/g719": {
                    source: "iana",
                },
                "audio/g722": {
                    source: "iana",
                },
                "audio/g7221": {
                    source: "iana",
                },
                "audio/g723": {
                    source: "iana",
                },
                "audio/g726-16": {
                    source: "iana",
                },
                "audio/g726-24": {
                    source: "iana",
                },
                "audio/g726-32": {
                    source: "iana",
                },
                "audio/g726-40": {
                    source: "iana",
                },
                "audio/g728": {
                    source: "iana",
                },
                "audio/g729": {
                    source: "iana",
                },
                "audio/g7291": {
                    source: "iana",
                },
                "audio/g729d": {
                    source: "iana",
                },
                "audio/g729e": {
                    source: "iana",
                },
                "audio/gsm": {
                    source: "iana",
                },
                "audio/gsm-efr": {
                    source: "iana",
                },
                "audio/gsm-hr-08": {
                    source: "iana",
                },
                "audio/ilbc": {
                    source: "iana",
                },
                "audio/ip-mr_v2.5": {
                    source: "iana",
                },
                "audio/isac": {
                    source: "apache",
                },
                "audio/l16": {
                    source: "iana",
                },
                "audio/l20": {
                    source: "iana",
                },
                "audio/l24": {
                    source: "iana",
                    compressible: false,
                },
                "audio/l8": {
                    source: "iana",
                },
                "audio/lpc": {
                    source: "iana",
                },
                "audio/melp": {
                    source: "iana",
                },
                "audio/melp1200": {
                    source: "iana",
                },
                "audio/melp2400": {
                    source: "iana",
                },
                "audio/melp600": {
                    source: "iana",
                },
                "audio/mhas": {
                    source: "iana",
                },
                "audio/midi": {
                    source: "apache",
                    extensions: ["mid", "midi", "kar", "rmi"],
                },
                "audio/mobile-xmf": {
                    source: "iana",
                    extensions: ["mxmf"],
                },
                "audio/mp3": {
                    compressible: false,
                    extensions: ["mp3"],
                },
                "audio/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["m4a", "mp4a"],
                },
                "audio/mp4a-latm": {
                    source: "iana",
                },
                "audio/mpa": {
                    source: "iana",
                },
                "audio/mpa-robust": {
                    source: "iana",
                },
                "audio/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
                },
                "audio/mpeg4-generic": {
                    source: "iana",
                },
                "audio/musepack": {
                    source: "apache",
                },
                "audio/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["oga", "ogg", "spx"],
                },
                "audio/opus": {
                    source: "iana",
                },
                "audio/parityfec": {
                    source: "iana",
                },
                "audio/pcma": {
                    source: "iana",
                },
                "audio/pcma-wb": {
                    source: "iana",
                },
                "audio/pcmu": {
                    source: "iana",
                },
                "audio/pcmu-wb": {
                    source: "iana",
                },
                "audio/prs.sid": {
                    source: "iana",
                },
                "audio/qcelp": {
                    source: "iana",
                },
                "audio/raptorfec": {
                    source: "iana",
                },
                "audio/red": {
                    source: "iana",
                },
                "audio/rtp-enc-aescm128": {
                    source: "iana",
                },
                "audio/rtp-midi": {
                    source: "iana",
                },
                "audio/rtploopback": {
                    source: "iana",
                },
                "audio/rtx": {
                    source: "iana",
                },
                "audio/s3m": {
                    source: "apache",
                    extensions: ["s3m"],
                },
                "audio/silk": {
                    source: "apache",
                    extensions: ["sil"],
                },
                "audio/smv": {
                    source: "iana",
                },
                "audio/smv-qcp": {
                    source: "iana",
                },
                "audio/smv0": {
                    source: "iana",
                },
                "audio/sp-midi": {
                    source: "iana",
                },
                "audio/speex": {
                    source: "iana",
                },
                "audio/t140c": {
                    source: "iana",
                },
                "audio/t38": {
                    source: "iana",
                },
                "audio/telephone-event": {
                    source: "iana",
                },
                "audio/tetra_acelp": {
                    source: "iana",
                },
                "audio/tetra_acelp_bb": {
                    source: "iana",
                },
                "audio/tone": {
                    source: "iana",
                },
                "audio/uemclip": {
                    source: "iana",
                },
                "audio/ulpfec": {
                    source: "iana",
                },
                "audio/usac": {
                    source: "iana",
                },
                "audio/vdvi": {
                    source: "iana",
                },
                "audio/vmr-wb": {
                    source: "iana",
                },
                "audio/vnd.3gpp.iufp": {
                    source: "iana",
                },
                "audio/vnd.4sb": {
                    source: "iana",
                },
                "audio/vnd.audiokoz": {
                    source: "iana",
                },
                "audio/vnd.celp": {
                    source: "iana",
                },
                "audio/vnd.cisco.nse": {
                    source: "iana",
                },
                "audio/vnd.cmles.radio-events": {
                    source: "iana",
                },
                "audio/vnd.cns.anp1": {
                    source: "iana",
                },
                "audio/vnd.cns.inf1": {
                    source: "iana",
                },
                "audio/vnd.dece.audio": {
                    source: "iana",
                    extensions: ["uva", "uvva"],
                },
                "audio/vnd.digital-winds": {
                    source: "iana",
                    extensions: ["eol"],
                },
                "audio/vnd.dlna.adts": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.1": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.2": {
                    source: "iana",
                },
                "audio/vnd.dolby.mlp": {
                    source: "iana",
                },
                "audio/vnd.dolby.mps": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2x": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2z": {
                    source: "iana",
                },
                "audio/vnd.dolby.pulse.1": {
                    source: "iana",
                },
                "audio/vnd.dra": {
                    source: "iana",
                    extensions: ["dra"],
                },
                "audio/vnd.dts": {
                    source: "iana",
                    extensions: ["dts"],
                },
                "audio/vnd.dts.hd": {
                    source: "iana",
                    extensions: ["dtshd"],
                },
                "audio/vnd.dts.uhd": {
                    source: "iana",
                },
                "audio/vnd.dvb.file": {
                    source: "iana",
                },
                "audio/vnd.everad.plj": {
                    source: "iana",
                },
                "audio/vnd.hns.audio": {
                    source: "iana",
                },
                "audio/vnd.lucent.voice": {
                    source: "iana",
                    extensions: ["lvp"],
                },
                "audio/vnd.ms-playready.media.pya": {
                    source: "iana",
                    extensions: ["pya"],
                },
                "audio/vnd.nokia.mobile-xmf": {
                    source: "iana",
                },
                "audio/vnd.nortel.vbk": {
                    source: "iana",
                },
                "audio/vnd.nuera.ecelp4800": {
                    source: "iana",
                    extensions: ["ecelp4800"],
                },
                "audio/vnd.nuera.ecelp7470": {
                    source: "iana",
                    extensions: ["ecelp7470"],
                },
                "audio/vnd.nuera.ecelp9600": {
                    source: "iana",
                    extensions: ["ecelp9600"],
                },
                "audio/vnd.octel.sbc": {
                    source: "iana",
                },
                "audio/vnd.presonus.multitrack": {
                    source: "iana",
                },
                "audio/vnd.qcelp": {
                    source: "iana",
                },
                "audio/vnd.rhetorex.32kadpcm": {
                    source: "iana",
                },
                "audio/vnd.rip": {
                    source: "iana",
                    extensions: ["rip"],
                },
                "audio/vnd.rn-realaudio": {
                    compressible: false,
                },
                "audio/vnd.sealedmedia.softseal.mpeg": {
                    source: "iana",
                },
                "audio/vnd.vmx.cvsd": {
                    source: "iana",
                },
                "audio/vnd.wave": {
                    compressible: false,
                },
                "audio/vorbis": {
                    source: "iana",
                    compressible: false,
                },
                "audio/vorbis-config": {
                    source: "iana",
                },
                "audio/wav": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/wave": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["weba"],
                },
                "audio/x-aac": {
                    source: "apache",
                    compressible: false,
                    extensions: ["aac"],
                },
                "audio/x-aiff": {
                    source: "apache",
                    extensions: ["aif", "aiff", "aifc"],
                },
                "audio/x-caf": {
                    source: "apache",
                    compressible: false,
                    extensions: ["caf"],
                },
                "audio/x-flac": {
                    source: "apache",
                    extensions: ["flac"],
                },
                "audio/x-m4a": {
                    source: "nginx",
                    extensions: ["m4a"],
                },
                "audio/x-matroska": {
                    source: "apache",
                    extensions: ["mka"],
                },
                "audio/x-mpegurl": {
                    source: "apache",
                    extensions: ["m3u"],
                },
                "audio/x-ms-wax": {
                    source: "apache",
                    extensions: ["wax"],
                },
                "audio/x-ms-wma": {
                    source: "apache",
                    extensions: ["wma"],
                },
                "audio/x-pn-realaudio": {
                    source: "apache",
                    extensions: ["ram", "ra"],
                },
                "audio/x-pn-realaudio-plugin": {
                    source: "apache",
                    extensions: ["rmp"],
                },
                "audio/x-realaudio": {
                    source: "nginx",
                    extensions: ["ra"],
                },
                "audio/x-tta": {
                    source: "apache",
                },
                "audio/x-wav": {
                    source: "apache",
                    extensions: ["wav"],
                },
                "audio/xm": {
                    source: "apache",
                    extensions: ["xm"],
                },
                "chemical/x-cdx": {
                    source: "apache",
                    extensions: ["cdx"],
                },
                "chemical/x-cif": {
                    source: "apache",
                    extensions: ["cif"],
                },
                "chemical/x-cmdf": {
                    source: "apache",
                    extensions: ["cmdf"],
                },
                "chemical/x-cml": {
                    source: "apache",
                    extensions: ["cml"],
                },
                "chemical/x-csml": {
                    source: "apache",
                    extensions: ["csml"],
                },
                "chemical/x-pdb": {
                    source: "apache",
                },
                "chemical/x-xyz": {
                    source: "apache",
                    extensions: ["xyz"],
                },
                "font/collection": {
                    source: "iana",
                    extensions: ["ttc"],
                },
                "font/otf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["otf"],
                },
                "font/sfnt": {
                    source: "iana",
                },
                "font/ttf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttf"],
                },
                "font/woff": {
                    source: "iana",
                    extensions: ["woff"],
                },
                "font/woff2": {
                    source: "iana",
                    extensions: ["woff2"],
                },
                "image/aces": {
                    source: "iana",
                    extensions: ["exr"],
                },
                "image/apng": {
                    compressible: false,
                    extensions: ["apng"],
                },
                "image/avci": {
                    source: "iana",
                },
                "image/avcs": {
                    source: "iana",
                },
                "image/bmp": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/cgm": {
                    source: "iana",
                    extensions: ["cgm"],
                },
                "image/dicom-rle": {
                    source: "iana",
                    extensions: ["drle"],
                },
                "image/emf": {
                    source: "iana",
                    extensions: ["emf"],
                },
                "image/fits": {
                    source: "iana",
                    extensions: ["fits"],
                },
                "image/g3fax": {
                    source: "iana",
                    extensions: ["g3"],
                },
                "image/gif": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gif"],
                },
                "image/heic": {
                    source: "iana",
                    extensions: ["heic"],
                },
                "image/heic-sequence": {
                    source: "iana",
                    extensions: ["heics"],
                },
                "image/heif": {
                    source: "iana",
                    extensions: ["heif"],
                },
                "image/heif-sequence": {
                    source: "iana",
                    extensions: ["heifs"],
                },
                "image/hej2k": {
                    source: "iana",
                    extensions: ["hej2"],
                },
                "image/hsj2": {
                    source: "iana",
                    extensions: ["hsj2"],
                },
                "image/ief": {
                    source: "iana",
                    extensions: ["ief"],
                },
                "image/jls": {
                    source: "iana",
                    extensions: ["jls"],
                },
                "image/jp2": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jp2", "jpg2"],
                },
                "image/jpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpeg", "jpg", "jpe"],
                },
                "image/jph": {
                    source: "iana",
                    extensions: ["jph"],
                },
                "image/jphc": {
                    source: "iana",
                    extensions: ["jhc"],
                },
                "image/jpm": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpm"],
                },
                "image/jpx": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpx", "jpf"],
                },
                "image/jxr": {
                    source: "iana",
                    extensions: ["jxr"],
                },
                "image/jxra": {
                    source: "iana",
                    extensions: ["jxra"],
                },
                "image/jxrs": {
                    source: "iana",
                    extensions: ["jxrs"],
                },
                "image/jxs": {
                    source: "iana",
                    extensions: ["jxs"],
                },
                "image/jxsc": {
                    source: "iana",
                    extensions: ["jxsc"],
                },
                "image/jxsi": {
                    source: "iana",
                    extensions: ["jxsi"],
                },
                "image/jxss": {
                    source: "iana",
                    extensions: ["jxss"],
                },
                "image/ktx": {
                    source: "iana",
                    extensions: ["ktx"],
                },
                "image/naplps": {
                    source: "iana",
                },
                "image/pjpeg": {
                    compressible: false,
                },
                "image/png": {
                    source: "iana",
                    compressible: false,
                    extensions: ["png"],
                },
                "image/prs.btif": {
                    source: "iana",
                    extensions: ["btif"],
                },
                "image/prs.pti": {
                    source: "iana",
                    extensions: ["pti"],
                },
                "image/pwg-raster": {
                    source: "iana",
                },
                "image/sgi": {
                    source: "apache",
                    extensions: ["sgi"],
                },
                "image/svg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["svg", "svgz"],
                },
                "image/t38": {
                    source: "iana",
                    extensions: ["t38"],
                },
                "image/tiff": {
                    source: "iana",
                    compressible: false,
                    extensions: ["tif", "tiff"],
                },
                "image/tiff-fx": {
                    source: "iana",
                    extensions: ["tfx"],
                },
                "image/vnd.adobe.photoshop": {
                    source: "iana",
                    compressible: true,
                    extensions: ["psd"],
                },
                "image/vnd.airzip.accelerator.azv": {
                    source: "iana",
                    extensions: ["azv"],
                },
                "image/vnd.cns.inf2": {
                    source: "iana",
                },
                "image/vnd.dece.graphic": {
                    source: "iana",
                    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
                },
                "image/vnd.djvu": {
                    source: "iana",
                    extensions: ["djvu", "djv"],
                },
                "image/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "image/vnd.dwg": {
                    source: "iana",
                    extensions: ["dwg"],
                },
                "image/vnd.dxf": {
                    source: "iana",
                    extensions: ["dxf"],
                },
                "image/vnd.fastbidsheet": {
                    source: "iana",
                    extensions: ["fbs"],
                },
                "image/vnd.fpx": {
                    source: "iana",
                    extensions: ["fpx"],
                },
                "image/vnd.fst": {
                    source: "iana",
                    extensions: ["fst"],
                },
                "image/vnd.fujixerox.edmics-mmr": {
                    source: "iana",
                    extensions: ["mmr"],
                },
                "image/vnd.fujixerox.edmics-rlc": {
                    source: "iana",
                    extensions: ["rlc"],
                },
                "image/vnd.globalgraphics.pgb": {
                    source: "iana",
                },
                "image/vnd.microsoft.icon": {
                    source: "iana",
                    extensions: ["ico"],
                },
                "image/vnd.mix": {
                    source: "iana",
                },
                "image/vnd.mozilla.apng": {
                    source: "iana",
                },
                "image/vnd.ms-dds": {
                    extensions: ["dds"],
                },
                "image/vnd.ms-modi": {
                    source: "iana",
                    extensions: ["mdi"],
                },
                "image/vnd.ms-photo": {
                    source: "apache",
                    extensions: ["wdp"],
                },
                "image/vnd.net-fpx": {
                    source: "iana",
                    extensions: ["npx"],
                },
                "image/vnd.radiance": {
                    source: "iana",
                },
                "image/vnd.sealed.png": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.gif": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.jpg": {
                    source: "iana",
                },
                "image/vnd.svf": {
                    source: "iana",
                },
                "image/vnd.tencent.tap": {
                    source: "iana",
                    extensions: ["tap"],
                },
                "image/vnd.valve.source.texture": {
                    source: "iana",
                    extensions: ["vtf"],
                },
                "image/vnd.wap.wbmp": {
                    source: "iana",
                    extensions: ["wbmp"],
                },
                "image/vnd.xiff": {
                    source: "iana",
                    extensions: ["xif"],
                },
                "image/vnd.zbrush.pcx": {
                    source: "iana",
                    extensions: ["pcx"],
                },
                "image/webp": {
                    source: "apache",
                    extensions: ["webp"],
                },
                "image/wmf": {
                    source: "iana",
                    extensions: ["wmf"],
                },
                "image/x-3ds": {
                    source: "apache",
                    extensions: ["3ds"],
                },
                "image/x-cmu-raster": {
                    source: "apache",
                    extensions: ["ras"],
                },
                "image/x-cmx": {
                    source: "apache",
                    extensions: ["cmx"],
                },
                "image/x-freehand": {
                    source: "apache",
                    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
                },
                "image/x-icon": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ico"],
                },
                "image/x-jng": {
                    source: "nginx",
                    extensions: ["jng"],
                },
                "image/x-mrsid-image": {
                    source: "apache",
                    extensions: ["sid"],
                },
                "image/x-ms-bmp": {
                    source: "nginx",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/x-pcx": {
                    source: "apache",
                    extensions: ["pcx"],
                },
                "image/x-pict": {
                    source: "apache",
                    extensions: ["pic", "pct"],
                },
                "image/x-portable-anymap": {
                    source: "apache",
                    extensions: ["pnm"],
                },
                "image/x-portable-bitmap": {
                    source: "apache",
                    extensions: ["pbm"],
                },
                "image/x-portable-graymap": {
                    source: "apache",
                    extensions: ["pgm"],
                },
                "image/x-portable-pixmap": {
                    source: "apache",
                    extensions: ["ppm"],
                },
                "image/x-rgb": {
                    source: "apache",
                    extensions: ["rgb"],
                },
                "image/x-tga": {
                    source: "apache",
                    extensions: ["tga"],
                },
                "image/x-xbitmap": {
                    source: "apache",
                    extensions: ["xbm"],
                },
                "image/x-xcf": {
                    compressible: false,
                },
                "image/x-xpixmap": {
                    source: "apache",
                    extensions: ["xpm"],
                },
                "image/x-xwindowdump": {
                    source: "apache",
                    extensions: ["xwd"],
                },
                "message/cpim": {
                    source: "iana",
                },
                "message/delivery-status": {
                    source: "iana",
                },
                "message/disposition-notification": {
                    source: "iana",
                    extensions: ["disposition-notification"],
                },
                "message/external-body": {
                    source: "iana",
                },
                "message/feedback-report": {
                    source: "iana",
                },
                "message/global": {
                    source: "iana",
                    extensions: ["u8msg"],
                },
                "message/global-delivery-status": {
                    source: "iana",
                    extensions: ["u8dsn"],
                },
                "message/global-disposition-notification": {
                    source: "iana",
                    extensions: ["u8mdn"],
                },
                "message/global-headers": {
                    source: "iana",
                    extensions: ["u8hdr"],
                },
                "message/http": {
                    source: "iana",
                    compressible: false,
                },
                "message/imdn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "message/news": {
                    source: "iana",
                },
                "message/partial": {
                    source: "iana",
                    compressible: false,
                },
                "message/rfc822": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eml", "mime"],
                },
                "message/s-http": {
                    source: "iana",
                },
                "message/sip": {
                    source: "iana",
                },
                "message/sipfrag": {
                    source: "iana",
                },
                "message/tracking-status": {
                    source: "iana",
                },
                "message/vnd.si.simp": {
                    source: "iana",
                },
                "message/vnd.wfa.wsc": {
                    source: "iana",
                    extensions: ["wsc"],
                },
                "model/3mf": {
                    source: "iana",
                    extensions: ["3mf"],
                },
                "model/gltf+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gltf"],
                },
                "model/gltf-binary": {
                    source: "iana",
                    compressible: true,
                    extensions: ["glb"],
                },
                "model/iges": {
                    source: "iana",
                    compressible: false,
                    extensions: ["igs", "iges"],
                },
                "model/mesh": {
                    source: "iana",
                    compressible: false,
                    extensions: ["msh", "mesh", "silo"],
                },
                "model/mtl": {
                    source: "iana",
                    extensions: ["mtl"],
                },
                "model/obj": {
                    source: "iana",
                    extensions: ["obj"],
                },
                "model/stl": {
                    source: "iana",
                    extensions: ["stl"],
                },
                "model/vnd.collada+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dae"],
                },
                "model/vnd.dwf": {
                    source: "iana",
                    extensions: ["dwf"],
                },
                "model/vnd.flatland.3dml": {
                    source: "iana",
                },
                "model/vnd.gdl": {
                    source: "iana",
                    extensions: ["gdl"],
                },
                "model/vnd.gs-gdl": {
                    source: "apache",
                },
                "model/vnd.gs.gdl": {
                    source: "iana",
                },
                "model/vnd.gtw": {
                    source: "iana",
                    extensions: ["gtw"],
                },
                "model/vnd.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "model/vnd.mts": {
                    source: "iana",
                    extensions: ["mts"],
                },
                "model/vnd.opengex": {
                    source: "iana",
                    extensions: ["ogex"],
                },
                "model/vnd.parasolid.transmit.binary": {
                    source: "iana",
                    extensions: ["x_b"],
                },
                "model/vnd.parasolid.transmit.text": {
                    source: "iana",
                    extensions: ["x_t"],
                },
                "model/vnd.rosette.annotated-data-model": {
                    source: "iana",
                },
                "model/vnd.usdz+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["usdz"],
                },
                "model/vnd.valve.source.compiled-map": {
                    source: "iana",
                    extensions: ["bsp"],
                },
                "model/vnd.vtu": {
                    source: "iana",
                    extensions: ["vtu"],
                },
                "model/vrml": {
                    source: "iana",
                    compressible: false,
                    extensions: ["wrl", "vrml"],
                },
                "model/x3d+binary": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3db", "x3dbz"],
                },
                "model/x3d+fastinfoset": {
                    source: "iana",
                    extensions: ["x3db"],
                },
                "model/x3d+vrml": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3dv", "x3dvz"],
                },
                "model/x3d+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["x3d", "x3dz"],
                },
                "model/x3d-vrml": {
                    source: "iana",
                    extensions: ["x3dv"],
                },
                "multipart/alternative": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/appledouble": {
                    source: "iana",
                },
                "multipart/byteranges": {
                    source: "iana",
                },
                "multipart/digest": {
                    source: "iana",
                },
                "multipart/encrypted": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/form-data": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/header-set": {
                    source: "iana",
                },
                "multipart/mixed": {
                    source: "iana",
                },
                "multipart/multilingual": {
                    source: "iana",
                },
                "multipart/parallel": {
                    source: "iana",
                },
                "multipart/related": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/report": {
                    source: "iana",
                },
                "multipart/signed": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/vnd.bint.med-plus": {
                    source: "iana",
                },
                "multipart/voice-message": {
                    source: "iana",
                },
                "multipart/x-mixed-replace": {
                    source: "iana",
                },
                "text/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "text/cache-manifest": {
                    source: "iana",
                    compressible: true,
                    extensions: ["appcache", "manifest"],
                },
                "text/calendar": {
                    source: "iana",
                    extensions: ["ics", "ifb"],
                },
                "text/calender": {
                    compressible: true,
                },
                "text/cmd": {
                    compressible: true,
                },
                "text/coffeescript": {
                    extensions: ["coffee", "litcoffee"],
                },
                "text/css": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["css"],
                },
                "text/csv": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csv"],
                },
                "text/csv-schema": {
                    source: "iana",
                },
                "text/directory": {
                    source: "iana",
                },
                "text/dns": {
                    source: "iana",
                },
                "text/ecmascript": {
                    source: "iana",
                },
                "text/encaprtp": {
                    source: "iana",
                },
                "text/enriched": {
                    source: "iana",
                },
                "text/flexfec": {
                    source: "iana",
                },
                "text/fwdred": {
                    source: "iana",
                },
                "text/grammar-ref-list": {
                    source: "iana",
                },
                "text/html": {
                    source: "iana",
                    compressible: true,
                    extensions: ["html", "htm", "shtml"],
                },
                "text/jade": {
                    extensions: ["jade"],
                },
                "text/javascript": {
                    source: "iana",
                    compressible: true,
                },
                "text/jcr-cnd": {
                    source: "iana",
                },
                "text/jsx": {
                    compressible: true,
                    extensions: ["jsx"],
                },
                "text/less": {
                    compressible: true,
                    extensions: ["less"],
                },
                "text/markdown": {
                    source: "iana",
                    compressible: true,
                    extensions: ["markdown", "md"],
                },
                "text/mathml": {
                    source: "nginx",
                    extensions: ["mml"],
                },
                "text/mdx": {
                    compressible: true,
                    extensions: ["mdx"],
                },
                "text/mizar": {
                    source: "iana",
                },
                "text/n3": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["n3"],
                },
                "text/parameters": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/parityfec": {
                    source: "iana",
                },
                "text/plain": {
                    source: "iana",
                    compressible: true,
                    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
                },
                "text/provenance-notation": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/prs.fallenstein.rst": {
                    source: "iana",
                },
                "text/prs.lines.tag": {
                    source: "iana",
                    extensions: ["dsc"],
                },
                "text/prs.prop.logic": {
                    source: "iana",
                },
                "text/raptorfec": {
                    source: "iana",
                },
                "text/red": {
                    source: "iana",
                },
                "text/rfc822-headers": {
                    source: "iana",
                },
                "text/richtext": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtx"],
                },
                "text/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "text/rtp-enc-aescm128": {
                    source: "iana",
                },
                "text/rtploopback": {
                    source: "iana",
                },
                "text/rtx": {
                    source: "iana",
                },
                "text/sgml": {
                    source: "iana",
                    extensions: ["sgml", "sgm"],
                },
                "text/shex": {
                    extensions: ["shex"],
                },
                "text/slim": {
                    extensions: ["slim", "slm"],
                },
                "text/strings": {
                    source: "iana",
                },
                "text/stylus": {
                    extensions: ["stylus", "styl"],
                },
                "text/t140": {
                    source: "iana",
                },
                "text/tab-separated-values": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tsv"],
                },
                "text/troff": {
                    source: "iana",
                    extensions: ["t", "tr", "roff", "man", "me", "ms"],
                },
                "text/turtle": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["ttl"],
                },
                "text/ulpfec": {
                    source: "iana",
                },
                "text/uri-list": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uri", "uris", "urls"],
                },
                "text/vcard": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vcard"],
                },
                "text/vnd.a": {
                    source: "iana",
                },
                "text/vnd.abc": {
                    source: "iana",
                },
                "text/vnd.ascii-art": {
                    source: "iana",
                },
                "text/vnd.curl": {
                    source: "iana",
                    extensions: ["curl"],
                },
                "text/vnd.curl.dcurl": {
                    source: "apache",
                    extensions: ["dcurl"],
                },
                "text/vnd.curl.mcurl": {
                    source: "apache",
                    extensions: ["mcurl"],
                },
                "text/vnd.curl.scurl": {
                    source: "apache",
                    extensions: ["scurl"],
                },
                "text/vnd.debian.copyright": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.dmclientscript": {
                    source: "iana",
                },
                "text/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "text/vnd.esmertec.theme-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.ficlab.flt": {
                    source: "iana",
                },
                "text/vnd.fly": {
                    source: "iana",
                    extensions: ["fly"],
                },
                "text/vnd.fmi.flexstor": {
                    source: "iana",
                    extensions: ["flx"],
                },
                "text/vnd.gml": {
                    source: "iana",
                },
                "text/vnd.graphviz": {
                    source: "iana",
                    extensions: ["gv"],
                },
                "text/vnd.hgl": {
                    source: "iana",
                },
                "text/vnd.in3d.3dml": {
                    source: "iana",
                    extensions: ["3dml"],
                },
                "text/vnd.in3d.spot": {
                    source: "iana",
                    extensions: ["spot"],
                },
                "text/vnd.iptc.newsml": {
                    source: "iana",
                },
                "text/vnd.iptc.nitf": {
                    source: "iana",
                },
                "text/vnd.latex-z": {
                    source: "iana",
                },
                "text/vnd.motorola.reflex": {
                    source: "iana",
                },
                "text/vnd.ms-mediapackage": {
                    source: "iana",
                },
                "text/vnd.net2phone.commcenter.command": {
                    source: "iana",
                },
                "text/vnd.radisys.msml-basic-layout": {
                    source: "iana",
                },
                "text/vnd.senx.warpscript": {
                    source: "iana",
                },
                "text/vnd.si.uricatalogue": {
                    source: "iana",
                },
                "text/vnd.sosi": {
                    source: "iana",
                },
                "text/vnd.sun.j2me.app-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["jad"],
                },
                "text/vnd.trolltech.linguist": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.wap.si": {
                    source: "iana",
                },
                "text/vnd.wap.sl": {
                    source: "iana",
                },
                "text/vnd.wap.wml": {
                    source: "iana",
                    extensions: ["wml"],
                },
                "text/vnd.wap.wmlscript": {
                    source: "iana",
                    extensions: ["wmls"],
                },
                "text/vtt": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["vtt"],
                },
                "text/x-asm": {
                    source: "apache",
                    extensions: ["s", "asm"],
                },
                "text/x-c": {
                    source: "apache",
                    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
                },
                "text/x-component": {
                    source: "nginx",
                    extensions: ["htc"],
                },
                "text/x-fortran": {
                    source: "apache",
                    extensions: ["f", "for", "f77", "f90"],
                },
                "text/x-gwt-rpc": {
                    compressible: true,
                },
                "text/x-handlebars-template": {
                    extensions: ["hbs"],
                },
                "text/x-java-source": {
                    source: "apache",
                    extensions: ["java"],
                },
                "text/x-jquery-tmpl": {
                    compressible: true,
                },
                "text/x-lua": {
                    extensions: ["lua"],
                },
                "text/x-markdown": {
                    compressible: true,
                    extensions: ["mkd"],
                },
                "text/x-nfo": {
                    source: "apache",
                    extensions: ["nfo"],
                },
                "text/x-opml": {
                    source: "apache",
                    extensions: ["opml"],
                },
                "text/x-org": {
                    compressible: true,
                    extensions: ["org"],
                },
                "text/x-pascal": {
                    source: "apache",
                    extensions: ["p", "pas"],
                },
                "text/x-processing": {
                    compressible: true,
                    extensions: ["pde"],
                },
                "text/x-sass": {
                    extensions: ["sass"],
                },
                "text/x-scss": {
                    extensions: ["scss"],
                },
                "text/x-setext": {
                    source: "apache",
                    extensions: ["etx"],
                },
                "text/x-sfv": {
                    source: "apache",
                    extensions: ["sfv"],
                },
                "text/x-suse-ymp": {
                    compressible: true,
                    extensions: ["ymp"],
                },
                "text/x-uuencode": {
                    source: "apache",
                    extensions: ["uu"],
                },
                "text/x-vcalendar": {
                    source: "apache",
                    extensions: ["vcs"],
                },
                "text/x-vcard": {
                    source: "apache",
                    extensions: ["vcf"],
                },
                "text/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml"],
                },
                "text/xml-external-parsed-entity": {
                    source: "iana",
                },
                "text/yaml": {
                    extensions: ["yaml", "yml"],
                },
                "video/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "video/3gpp": {
                    source: "iana",
                    extensions: ["3gp", "3gpp"],
                },
                "video/3gpp-tt": {
                    source: "iana",
                },
                "video/3gpp2": {
                    source: "iana",
                    extensions: ["3g2"],
                },
                "video/bmpeg": {
                    source: "iana",
                },
                "video/bt656": {
                    source: "iana",
                },
                "video/celb": {
                    source: "iana",
                },
                "video/dv": {
                    source: "iana",
                },
                "video/encaprtp": {
                    source: "iana",
                },
                "video/flexfec": {
                    source: "iana",
                },
                "video/h261": {
                    source: "iana",
                    extensions: ["h261"],
                },
                "video/h263": {
                    source: "iana",
                    extensions: ["h263"],
                },
                "video/h263-1998": {
                    source: "iana",
                },
                "video/h263-2000": {
                    source: "iana",
                },
                "video/h264": {
                    source: "iana",
                    extensions: ["h264"],
                },
                "video/h264-rcdo": {
                    source: "iana",
                },
                "video/h264-svc": {
                    source: "iana",
                },
                "video/h265": {
                    source: "iana",
                },
                "video/iso.segment": {
                    source: "iana",
                },
                "video/jpeg": {
                    source: "iana",
                    extensions: ["jpgv"],
                },
                "video/jpeg2000": {
                    source: "iana",
                },
                "video/jpm": {
                    source: "apache",
                    extensions: ["jpm", "jpgm"],
                },
                "video/mj2": {
                    source: "iana",
                    extensions: ["mj2", "mjp2"],
                },
                "video/mp1s": {
                    source: "iana",
                },
                "video/mp2p": {
                    source: "iana",
                },
                "video/mp2t": {
                    source: "iana",
                    extensions: ["ts"],
                },
                "video/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mp4", "mp4v", "mpg4"],
                },
                "video/mp4v-es": {
                    source: "iana",
                },
                "video/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
                },
                "video/mpeg4-generic": {
                    source: "iana",
                },
                "video/mpv": {
                    source: "iana",
                },
                "video/nv": {
                    source: "iana",
                },
                "video/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogv"],
                },
                "video/parityfec": {
                    source: "iana",
                },
                "video/pointer": {
                    source: "iana",
                },
                "video/quicktime": {
                    source: "iana",
                    compressible: false,
                    extensions: ["qt", "mov"],
                },
                "video/raptorfec": {
                    source: "iana",
                },
                "video/raw": {
                    source: "iana",
                },
                "video/rtp-enc-aescm128": {
                    source: "iana",
                },
                "video/rtploopback": {
                    source: "iana",
                },
                "video/rtx": {
                    source: "iana",
                },
                "video/smpte291": {
                    source: "iana",
                },
                "video/smpte292m": {
                    source: "iana",
                },
                "video/ulpfec": {
                    source: "iana",
                },
                "video/vc1": {
                    source: "iana",
                },
                "video/vc2": {
                    source: "iana",
                },
                "video/vnd.cctv": {
                    source: "iana",
                },
                "video/vnd.dece.hd": {
                    source: "iana",
                    extensions: ["uvh", "uvvh"],
                },
                "video/vnd.dece.mobile": {
                    source: "iana",
                    extensions: ["uvm", "uvvm"],
                },
                "video/vnd.dece.mp4": {
                    source: "iana",
                },
                "video/vnd.dece.pd": {
                    source: "iana",
                    extensions: ["uvp", "uvvp"],
                },
                "video/vnd.dece.sd": {
                    source: "iana",
                    extensions: ["uvs", "uvvs"],
                },
                "video/vnd.dece.video": {
                    source: "iana",
                    extensions: ["uvv", "uvvv"],
                },
                "video/vnd.directv.mpeg": {
                    source: "iana",
                },
                "video/vnd.directv.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dlna.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dvb.file": {
                    source: "iana",
                    extensions: ["dvb"],
                },
                "video/vnd.fvt": {
                    source: "iana",
                    extensions: ["fvt"],
                },
                "video/vnd.hns.video": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsavc": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsmpeg2": {
                    source: "iana",
                },
                "video/vnd.motorola.video": {
                    source: "iana",
                },
                "video/vnd.motorola.videop": {
                    source: "iana",
                },
                "video/vnd.mpegurl": {
                    source: "iana",
                    extensions: ["mxu", "m4u"],
                },
                "video/vnd.ms-playready.media.pyv": {
                    source: "iana",
                    extensions: ["pyv"],
                },
                "video/vnd.nokia.interleaved-multimedia": {
                    source: "iana",
                },
                "video/vnd.nokia.mp4vr": {
                    source: "iana",
                },
                "video/vnd.nokia.videovoip": {
                    source: "iana",
                },
                "video/vnd.objectvideo": {
                    source: "iana",
                },
                "video/vnd.radgamettools.bink": {
                    source: "iana",
                },
                "video/vnd.radgamettools.smacker": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg1": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg4": {
                    source: "iana",
                },
                "video/vnd.sealed.swf": {
                    source: "iana",
                },
                "video/vnd.sealedmedia.softseal.mov": {
                    source: "iana",
                },
                "video/vnd.uvvu.mp4": {
                    source: "iana",
                    extensions: ["uvu", "uvvu"],
                },
                "video/vnd.vivo": {
                    source: "iana",
                    extensions: ["viv"],
                },
                "video/vnd.youtube.yt": {
                    source: "iana",
                },
                "video/vp8": {
                    source: "iana",
                },
                "video/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["webm"],
                },
                "video/x-f4v": {
                    source: "apache",
                    extensions: ["f4v"],
                },
                "video/x-fli": {
                    source: "apache",
                    extensions: ["fli"],
                },
                "video/x-flv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["flv"],
                },
                "video/x-m4v": {
                    source: "apache",
                    extensions: ["m4v"],
                },
                "video/x-matroska": {
                    source: "apache",
                    compressible: false,
                    extensions: ["mkv", "mk3d", "mks"],
                },
                "video/x-mng": {
                    source: "apache",
                    extensions: ["mng"],
                },
                "video/x-ms-asf": {
                    source: "apache",
                    extensions: ["asf", "asx"],
                },
                "video/x-ms-vob": {
                    source: "apache",
                    extensions: ["vob"],
                },
                "video/x-ms-wm": {
                    source: "apache",
                    extensions: ["wm"],
                },
                "video/x-ms-wmv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["wmv"],
                },
                "video/x-ms-wmx": {
                    source: "apache",
                    extensions: ["wmx"],
                },
                "video/x-ms-wvx": {
                    source: "apache",
                    extensions: ["wvx"],
                },
                "video/x-msvideo": {
                    source: "apache",
                    extensions: ["avi"],
                },
                "video/x-sgi-movie": {
                    source: "apache",
                    extensions: ["movie"],
                },
                "video/x-smv": {
                    source: "apache",
                    extensions: ["smv"],
                },
                "x-conference/x-cooltalk": {
                    source: "apache",
                    extensions: ["ice"],
                },
                "x-shader/x-fragment": {
                    compressible: true,
                },
                "x-shader/x-vertex": {
                    compressible: true,
                },
            });
        }
    };
});
System.register("https://deno.land/x/media_types@v2.4.6/deps", ["https://deno.land/std@0.67.0/path/mod"], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [
            function (mod_ts_8_1) {
                exports_32({
                    "extname": mod_ts_8_1["extname"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-types and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015 Douglas Christopher Wilson <doug@somethingdoug.com>
 * Copyright (c) 2020 the Deno authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.4.6/mod", ["https://deno.land/x/media_types@v2.4.6/db", "https://deno.land/x/media_types@v2.4.6/deps"], function (exports_33, context_33) {
    "use strict";
    var db_ts_1, deps_ts_1, EXTRACT_TYPE_REGEXP, TEXT_TYPE_REGEXP, extensions, types;
    var __moduleName = context_33 && context_33.id;
    function populateMaps(extensions, types) {
        const preference = ["nginx", "apache", undefined, "iana"];
        for (const type of Object.keys(db_ts_1.db)) {
            const mime = db_ts_1.db[type];
            const exts = mime.extensions;
            if (!exts || !exts.length) {
                continue;
            }
            extensions.set(type, exts);
            for (const ext of exts) {
                const current = types.get(ext);
                if (current) {
                    const from = preference.indexOf(db_ts_1.db[current].source);
                    const to = preference.indexOf(mime.source);
                    if (current !== "application/octet-stream" &&
                        (from > to ||
                            (from === to && current.substr(0, 12) === "application/"))) {
                        continue;
                    }
                }
                types.set(ext, type);
            }
        }
    }
    function charset(type) {
        const m = EXTRACT_TYPE_REGEXP.exec(type);
        if (!m) {
            return;
        }
        const [match] = m;
        const mime = db_ts_1.db[match.toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (TEXT_TYPE_REGEXP.test(match)) {
            return "UTF-8";
        }
    }
    exports_33("charset", charset);
    function lookup(path) {
        const extension = deps_ts_1.extname("x." + path)
            .toLowerCase()
            .substr(1);
        return types.get(extension);
    }
    exports_33("lookup", lookup);
    function contentType(str) {
        let mime = str.includes("/") ? str : lookup(str);
        if (!mime) {
            return;
        }
        if (!mime.includes("charset")) {
            const cs = charset(mime);
            if (cs) {
                mime += `; charset=${cs.toLowerCase()}`;
            }
        }
        return mime;
    }
    exports_33("contentType", contentType);
    function extension(type) {
        const match = EXTRACT_TYPE_REGEXP.exec(type);
        if (!match) {
            return;
        }
        const exts = extensions.get(match[1].toLowerCase());
        if (!exts || !exts.length) {
            return;
        }
        return exts[0];
    }
    exports_33("extension", extension);
    return {
        setters: [
            function (db_ts_1_1) {
                db_ts_1 = db_ts_1_1;
            },
            function (deps_ts_1_1) {
                deps_ts_1 = deps_ts_1_1;
            }
        ],
        execute: function () {
            EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            TEXT_TYPE_REGEXP = /^text\//i;
            exports_33("extensions", extensions = new Map());
            exports_33("types", types = new Map());
            populateMaps(extensions, types);
        }
    };
});
System.register("https://raw.githubusercontent.com/pillarjs/path-to-regexp/v6.1.0/src/index", [], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    function lexer(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                let name = "";
                let j = i + 1;
                while (j < str.length) {
                    const code = str.charCodeAt(j);
                    if ((code >= 48 && code <= 57) ||
                        (code >= 65 && code <= 90) ||
                        (code >= 97 && code <= 122) ||
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError(`Missing parameter name at ${i}`);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                let count = 1;
                let pattern = "";
                let j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError(`Pattern cannot start with "?" at ${j}`);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError(`Capturing groups are not allowed at ${j}`);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError(`Unbalanced pattern at ${i}`);
                if (!pattern)
                    throw new TypeError(`Missing pattern at ${i}`);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    function parse(str, options = {}) {
        const tokens = lexer(str);
        const { prefixes = "./" } = options;
        const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
        const result = [];
        let key = 0;
        let i = 0;
        let path = "";
        const tryConsume = (type) => {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        const mustConsume = (type) => {
            const value = tryConsume(type);
            if (value !== undefined)
                return value;
            const { type: nextType, index } = tokens[i];
            throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
        };
        const consumeText = () => {
            let result = "";
            let value;
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            const char = tryConsume("CHAR");
            const name = tryConsume("NAME");
            const pattern = tryConsume("PATTERN");
            if (name || pattern) {
                let prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            const value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            const open = tryConsume("OPEN");
            if (open) {
                const prefix = consumeText();
                const name = tryConsume("NAME") || "";
                const pattern = tryConsume("PATTERN") || "";
                const suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name || (pattern ? key++ : ""),
                    pattern: name && !pattern ? defaultPattern : pattern,
                    prefix,
                    suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    exports_34("parse", parse);
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    exports_34("compile", compile);
    function tokensToFunction(tokens, options = {}) {
        const reFlags = flags(options);
        const { encode = (x) => x, validate = true } = options;
        const matches = tokens.map(token => {
            if (typeof token === "object") {
                return new RegExp(`^(?:${token.pattern})$`, reFlags);
            }
        });
        return (data) => {
            let path = "";
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                const value = data ? data[token.name] : undefined;
                const optional = token.modifier === "?" || token.modifier === "*";
                const repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError(`Expected "${token.name}" to not be empty`);
                    }
                    for (let j = 0; j < value.length; j++) {
                        const segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    const segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                const typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
            }
            return path;
        };
    }
    exports_34("tokensToFunction", tokensToFunction);
    function match(str, options) {
        const keys = [];
        const re = pathToRegexp(str, keys, options);
        return regexpToFunction(re, keys, options);
    }
    exports_34("match", match);
    function regexpToFunction(re, keys, options = {}) {
        const { decode = (x) => x } = options;
        return function (pathname) {
            const m = re.exec(pathname);
            if (!m)
                return false;
            const { 0: path, index } = m;
            const params = Object.create(null);
            for (let i = 1; i < m.length; i++) {
                if (m[i] === undefined)
                    continue;
                const key = keys[i - 1];
                if (key.modifier === "*" || key.modifier === "+") {
                    params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {
                        return decode(value, key);
                    });
                }
                else {
                    params[key.name] = decode(m[i], key);
                }
            }
            return { path, index, params };
        };
    }
    exports_34("regexpToFunction", regexpToFunction);
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        const groups = path.source.match(/\((?!\?)/g);
        if (groups) {
            for (let i = 0; i < groups.length; i++) {
                keys.push({
                    name: i,
                    prefix: "",
                    suffix: "",
                    modifier: "",
                    pattern: ""
                });
            }
        }
        return path;
    }
    function arrayToRegexp(paths, keys, options) {
        const parts = paths.map(path => pathToRegexp(path, keys, options).source);
        return new RegExp(`(?:${parts.join("|")})`, flags(options));
    }
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options = {}) {
        const { strict = false, start = true, end = true, encode = (x) => x } = options;
        const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
        const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
        let route = start ? "^" : "";
        for (const token of tokens) {
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                const prefix = escapeString(encode(token.prefix));
                const suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            const mod = token.modifier === "*" ? "?" : "";
                            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                        }
                        else {
                            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                        }
                    }
                    else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
                else {
                    route += `(?:${prefix}${suffix})${token.modifier}`;
                }
            }
        }
        if (end) {
            if (!strict)
                route += `${delimiter}?`;
            route += !options.endsWith ? "$" : `(?=${endsWith})`;
        }
        else {
            const endToken = tokens[tokens.length - 1];
            const isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                :
                    endToken === undefined;
            if (!strict) {
                route += `(?:${delimiter}(?=${endsWith}))?`;
            }
            if (!isEndDelimited) {
                route += `(?=${delimiter}|${endsWith})`;
            }
        }
        return new RegExp(route, flags(options));
    }
    exports_34("tokensToRegexp", tokensToRegexp);
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }
    exports_34("pathToRegexp", pathToRegexp);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/deps", ["https://deno.land/std@0.67.0/bytes/mod", "https://deno.land/std@0.67.0/hash/sha1", "https://deno.land/std@0.67.0/hash/sha256", "https://deno.land/std@0.67.0/http/server", "https://deno.land/std@0.67.0/http/http_status", "https://deno.land/std@0.67.0/io/bufio", "https://deno.land/std@0.67.0/path/mod", "https://deno.land/std@0.67.0/testing/asserts", "https://deno.land/std@0.67.0/ws/mod", "https://deno.land/x/media_types@v2.4.6/mod", "https://raw.githubusercontent.com/pillarjs/path-to-regexp/v6.1.0/src/index"], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    return {
        setters: [
            function (mod_ts_9_1) {
                exports_35({
                    "copyBytes": mod_ts_9_1["copyBytes"],
                    "equal": mod_ts_9_1["equal"]
                });
            },
            function (sha1_ts_2_1) {
                exports_35({
                    "Sha1": sha1_ts_2_1["Sha1"]
                });
            },
            function (sha256_ts_1_1) {
                exports_35({
                    "HmacSha256": sha256_ts_1_1["HmacSha256"]
                });
            },
            function (server_ts_2_1) {
                exports_35({
                    "serve": server_ts_2_1["serve"],
                    "serveTLS": server_ts_2_1["serveTLS"]
                });
            },
            function (http_status_ts_2_1) {
                exports_35({
                    "Status": http_status_ts_2_1["Status"],
                    "STATUS_TEXT": http_status_ts_2_1["STATUS_TEXT"]
                });
            },
            function (bufio_ts_4_1) {
                exports_35({
                    "BufReader": bufio_ts_4_1["BufReader"],
                    "BufWriter": bufio_ts_4_1["BufWriter"]
                });
            },
            function (mod_ts_10_1) {
                exports_35({
                    "basename": mod_ts_10_1["basename"],
                    "extname": mod_ts_10_1["extname"],
                    "join": mod_ts_10_1["join"],
                    "isAbsolute": mod_ts_10_1["isAbsolute"],
                    "normalize": mod_ts_10_1["normalize"],
                    "parse": mod_ts_10_1["parse"],
                    "sep": mod_ts_10_1["sep"]
                });
            },
            function (asserts_ts_1_1) {
                exports_35({
                    "assert": asserts_ts_1_1["assert"]
                });
            },
            function (mod_ts_11_1) {
                exports_35({
                    "acceptable": mod_ts_11_1["acceptable"],
                    "acceptWebSocket": mod_ts_11_1["acceptWebSocket"]
                });
            },
            function (mod_ts_12_1) {
                exports_35({
                    "contentType": mod_ts_12_1["contentType"],
                    "extension": mod_ts_12_1["extension"],
                    "lookup": mod_ts_12_1["lookup"]
                });
            },
            function (index_ts_1_1) {
                exports_35({
                    "compile": index_ts_1_1["compile"],
                    "pathParse": index_ts_1_1["parse"],
                    "pathToRegexp": index_ts_1_1["pathToRegexp"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/tssCompare", ["https://deno.land/x/oak@v6.1.0/deps"], function (exports_36, context_36) {
    "use strict";
    var deps_ts_2;
    var __moduleName = context_36 && context_36.id;
    function compareArrayBuffer(a, b) {
        deps_ts_2.assert(a.byteLength === b.byteLength, "ArrayBuffer lengths must match.");
        const va = new DataView(a);
        const vb = new DataView(b);
        const length = va.byteLength;
        let out = 0;
        let i = -1;
        while (++i < length) {
            out |= va.getUint8(i) ^ vb.getUint8(i);
        }
        return out === 0;
    }
    function compare(a, b) {
        const key = new Uint8Array(32);
        globalThis.crypto.getRandomValues(key);
        const ah = (new deps_ts_2.HmacSha256(key)).update(a).arrayBuffer();
        const bh = (new deps_ts_2.HmacSha256(key)).update(b).arrayBuffer();
        return compareArrayBuffer(ah, bh);
    }
    exports_36("compare", compare);
    return {
        setters: [
            function (deps_ts_2_1) {
                deps_ts_2 = deps_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/keyStack", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/tssCompare"], function (exports_37, context_37) {
    "use strict";
    var deps_ts_3, tssCompare_ts_1, replacements, KeyStack;
    var __moduleName = context_37 && context_37.id;
    return {
        setters: [
            function (deps_ts_3_1) {
                deps_ts_3 = deps_ts_3_1;
            },
            function (tssCompare_ts_1_1) {
                tssCompare_ts_1 = tssCompare_ts_1_1;
            }
        ],
        execute: function () {
            replacements = {
                "/": "_",
                "+": "-",
                "=": "",
            };
            KeyStack = class KeyStack {
                constructor(keys) {
                    this.#sign = (data, key) => {
                        return btoa(String.fromCharCode.apply(undefined, new Uint8Array(new deps_ts_3.HmacSha256(key).update(data).arrayBuffer())))
                            .replace(/\/|\+|=/g, (c) => replacements[c]);
                    };
                    if (!(0 in keys)) {
                        throw new TypeError("keys must contain at least one value");
                    }
                    this.#keys = keys;
                }
                #keys;
                #sign;
                sign(data) {
                    return this.#sign(data, this.#keys[0]);
                }
                verify(data, digest) {
                    return this.indexOf(data, digest) > -1;
                }
                indexOf(data, digest) {
                    for (let i = 0; i < this.#keys.length; i++) {
                        if (tssCompare_ts_1.compare(digest, this.#sign(data, this.#keys[i]))) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
            exports_37("KeyStack", KeyStack);
        }
    };
});
/*!
 * Adapted directly from http-errors at https://github.com/jshttp/http-errors
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong me@jongleberry.com
 * Copyright (c) 2016 Douglas Christopher Wilson doug@somethingdoug.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/httpError", ["https://deno.land/x/oak@v6.1.0/deps"], function (exports_38, context_38) {
    "use strict";
    var deps_ts_4, errorStatusMap, HttpError, httpErrors;
    var __moduleName = context_38 && context_38.id;
    function createHttpErrorConstructor(status) {
        const name = `${deps_ts_4.Status[status]}Error`;
        const Ctor = class extends HttpError {
            constructor(message) {
                super();
                this.message = message || deps_ts_4.STATUS_TEXT.get(status);
                this.status = status;
                this.expose = status >= 400 && status < 500 ? true : false;
                Object.defineProperty(this, "name", {
                    configurable: true,
                    enumerable: false,
                    value: name,
                    writable: true,
                });
            }
        };
        return Ctor;
    }
    function createHttpError(status = 500, message) {
        return new httpErrors[deps_ts_4.Status[status]](message);
    }
    exports_38("createHttpError", createHttpError);
    function isHttpError(value) {
        return value instanceof HttpError;
    }
    exports_38("isHttpError", isHttpError);
    return {
        setters: [
            function (deps_ts_4_1) {
                deps_ts_4 = deps_ts_4_1;
            }
        ],
        execute: function () {
            errorStatusMap = {
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "RequestEntityTooLarge": 413,
                "RequestURITooLong": 414,
                "UnsupportedMediaType": 415,
                "RequestedRangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "Teapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HTTPVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511,
            };
            HttpError = class HttpError extends Error {
                constructor() {
                    super(...arguments);
                    this.expose = false;
                    this.status = deps_ts_4.Status.InternalServerError;
                }
            };
            exports_38("HttpError", HttpError);
            exports_38("httpErrors", httpErrors = {});
            for (const [key, value] of Object.entries(errorStatusMap)) {
                httpErrors[key] = createHttpErrorConstructor(value);
            }
        }
    };
});
/*!
 * Adapted directly from media-typer at https://github.com/jshttp/media-typer/
 * which is licensed as follows:
 *
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.1.0/mediaTyper", [], function (exports_39, context_39) {
    "use strict";
    var SUBTYPE_NAME_REGEXP, TYPE_NAME_REGEXP, TYPE_REGEXP, MediaType;
    var __moduleName = context_39 && context_39.id;
    function format(obj) {
        const { subtype, suffix, type } = obj;
        if (!TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("Invalid type.");
        }
        if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("Invalid subtype.");
        }
        let str = `${type}/${subtype}`;
        if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
                throw new TypeError("Invalid suffix.");
            }
            str += `+${suffix}`;
        }
        return str;
    }
    exports_39("format", format);
    function parse(str) {
        const match = TYPE_REGEXP.exec(str.toLowerCase());
        if (!match) {
            throw new TypeError("Invalid media type.");
        }
        let [, type, subtype] = match;
        let suffix;
        const idx = subtype.lastIndexOf("+");
        if (idx !== -1) {
            suffix = subtype.substr(idx + 1);
            subtype = subtype.substr(0, idx);
        }
        return new MediaType(type, subtype, suffix);
    }
    exports_39("parse", parse);
    return {
        setters: [],
        execute: function () {
            SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            MediaType = class MediaType {
                constructor(type, subtype, suffix) {
                    this.type = type;
                    this.subtype = subtype;
                    this.suffix = suffix;
                }
            };
        }
    };
});
/*!
 * Adapted directly from type-is at https://github.com/jshttp/type-is/
 * which is licensed as follows:
 *
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.1.0/isMediaType", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/mediaTyper"], function (exports_40, context_40) {
    "use strict";
    var deps_ts_5, mediaTyper_ts_1;
    var __moduleName = context_40 && context_40.id;
    function mimeMatch(expected, actual) {
        if (expected === undefined) {
            return false;
        }
        const actualParts = actual.split("/");
        const expectedParts = expected.split("/");
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        const [actualType, actualSubtype] = actualParts;
        const [expectedType, expectedSubtype] = expectedParts;
        if (expectedType !== "*" && expectedType !== actualType) {
            return false;
        }
        if (expectedSubtype.substr(0, 2) === "*+") {
            return (expectedSubtype.length <= actualSubtype.length + 1 &&
                expectedSubtype.substr(1) ===
                    actualSubtype.substr(1 - expectedSubtype.length));
        }
        if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
            return false;
        }
        return true;
    }
    function normalize(type) {
        switch (type) {
            case "urlencoded":
                return "application/x-www-form-urlencoded";
            case "multipart":
                return "multipart/*";
        }
        if (type[0] === "+") {
            return `*/*${type}`;
        }
        return type.includes("/") ? type : deps_ts_5.lookup(type);
    }
    function normalizeType(value) {
        try {
            const val = value.split(";");
            const type = mediaTyper_ts_1.parse(val[0]);
            return mediaTyper_ts_1.format(type);
        }
        catch {
            return;
        }
    }
    function isMediaType(value, types) {
        const val = normalizeType(value);
        if (!val) {
            return false;
        }
        if (!types.length) {
            return val;
        }
        for (const type of types) {
            if (mimeMatch(normalize(type), val)) {
                return type[0] === "+" || type.includes("*") ? val : type;
            }
        }
        return false;
    }
    exports_40("isMediaType", isMediaType);
    return {
        setters: [
            function (deps_ts_5_1) {
                deps_ts_5 = deps_ts_5_1;
            },
            function (mediaTyper_ts_1_1) {
                mediaTyper_ts_1 = mediaTyper_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/util", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/httpError"], function (exports_41, context_41) {
    "use strict";
    var deps_ts_6, httpError_ts_1, ENCODE_CHARS_REGEXP, HTAB, SPACE, CR, LF, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, UP_PATH_REGEXP;
    var __moduleName = context_41 && context_41.id;
    function decodeComponent(text) {
        try {
            return decodeURIComponent(text);
        }
        catch {
            return text;
        }
    }
    exports_41("decodeComponent", decodeComponent);
    function encodeUrl(url) {
        return String(url)
            .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
            .replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    exports_41("encodeUrl", encodeUrl);
    function getRandomFilename(prefix = "", extension = "") {
        return `${prefix}${new deps_ts_6.Sha1().update(crypto.getRandomValues(new Uint8Array(256))).hex()}${extension ? `.${extension}` : ""}`;
    }
    exports_41("getRandomFilename", getRandomFilename);
    function isErrorStatus(value) {
        return [
            deps_ts_6.Status.BadRequest,
            deps_ts_6.Status.Unauthorized,
            deps_ts_6.Status.PaymentRequired,
            deps_ts_6.Status.Forbidden,
            deps_ts_6.Status.NotFound,
            deps_ts_6.Status.MethodNotAllowed,
            deps_ts_6.Status.NotAcceptable,
            deps_ts_6.Status.ProxyAuthRequired,
            deps_ts_6.Status.RequestTimeout,
            deps_ts_6.Status.Conflict,
            deps_ts_6.Status.Gone,
            deps_ts_6.Status.LengthRequired,
            deps_ts_6.Status.PreconditionFailed,
            deps_ts_6.Status.RequestEntityTooLarge,
            deps_ts_6.Status.RequestURITooLong,
            deps_ts_6.Status.UnsupportedMediaType,
            deps_ts_6.Status.RequestedRangeNotSatisfiable,
            deps_ts_6.Status.ExpectationFailed,
            deps_ts_6.Status.Teapot,
            deps_ts_6.Status.MisdirectedRequest,
            deps_ts_6.Status.UnprocessableEntity,
            deps_ts_6.Status.Locked,
            deps_ts_6.Status.FailedDependency,
            deps_ts_6.Status.UpgradeRequired,
            deps_ts_6.Status.PreconditionRequired,
            deps_ts_6.Status.TooManyRequests,
            deps_ts_6.Status.RequestHeaderFieldsTooLarge,
            deps_ts_6.Status.UnavailableForLegalReasons,
            deps_ts_6.Status.InternalServerError,
            deps_ts_6.Status.NotImplemented,
            deps_ts_6.Status.BadGateway,
            deps_ts_6.Status.ServiceUnavailable,
            deps_ts_6.Status.GatewayTimeout,
            deps_ts_6.Status.HTTPVersionNotSupported,
            deps_ts_6.Status.VariantAlsoNegotiates,
            deps_ts_6.Status.InsufficientStorage,
            deps_ts_6.Status.LoopDetected,
            deps_ts_6.Status.NotExtended,
            deps_ts_6.Status.NetworkAuthenticationRequired,
        ].includes(value);
    }
    exports_41("isErrorStatus", isErrorStatus);
    function isRedirectStatus(value) {
        return [
            deps_ts_6.Status.MultipleChoices,
            deps_ts_6.Status.MovedPermanently,
            deps_ts_6.Status.Found,
            deps_ts_6.Status.SeeOther,
            deps_ts_6.Status.UseProxy,
            deps_ts_6.Status.TemporaryRedirect,
            deps_ts_6.Status.PermanentRedirect,
        ].includes(value);
    }
    exports_41("isRedirectStatus", isRedirectStatus);
    function isHtml(value) {
        return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
    }
    exports_41("isHtml", isHtml);
    function skipLWSPChar(u8) {
        const result = new Uint8Array(u8.length);
        let j = 0;
        for (let i = 0; i < u8.length; i++) {
            if (u8[i] === SPACE || u8[i] === HTAB)
                continue;
            result[j++] = u8[i];
        }
        return result.slice(0, j);
    }
    exports_41("skipLWSPChar", skipLWSPChar);
    function stripEol(value) {
        if (value[value.byteLength - 1] == LF) {
            let drop = 1;
            if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
                drop = 2;
            }
            return value.subarray(0, value.byteLength - drop);
        }
        return value;
    }
    exports_41("stripEol", stripEol);
    function resolvePath(rootPath, relativePath) {
        let path = relativePath;
        let root = rootPath;
        if (arguments.length === 1) {
            path = rootPath;
            root = ".";
        }
        if (path == null) {
            throw new TypeError("Argument relativePath is required.");
        }
        if (path.includes("\0")) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (deps_ts_6.isAbsolute(path)) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (UP_PATH_REGEXP.test(deps_ts_6.normalize("." + deps_ts_6.sep + path))) {
            throw httpError_ts_1.createHttpError(403);
        }
        return deps_ts_6.normalize(deps_ts_6.join(root, path));
    }
    exports_41("resolvePath", resolvePath);
    return {
        setters: [
            function (deps_ts_6_1) {
                deps_ts_6 = deps_ts_6_1;
            },
            function (httpError_ts_1_1) {
                httpError_ts_1 = httpError_ts_1_1;
            }
        ],
        execute: function () {
            ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
            UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
            UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/buf_reader", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/util"], function (exports_42, context_42) {
    "use strict";
    var deps_ts_7, util_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, BufReader;
    var __moduleName = context_42 && context_42.id;
    return {
        setters: [
            function (deps_ts_7_1) {
                deps_ts_7 = deps_ts_7_1;
            },
            function (util_ts_1_1) {
                util_ts_1 = util_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_42("BufferFullError", BufferFullError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.#posRead = 0;
                    this.#posWrite = 0;
                    this.#eof = false;
                    this.#fill = async () => {
                        if (this.#posRead > 0) {
                            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
                            this.#posWrite -= this.#posRead;
                            this.#posRead = 0;
                        }
                        if (this.#posWrite >= this.#buffer.byteLength) {
                            throw Error("bufio: tried to fill full buffer");
                        }
                        for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
                            if (rr === null) {
                                this.#eof = true;
                                return;
                            }
                            deps_ts_7.assert(rr >= 0, "negative read");
                            this.#posWrite += rr;
                            if (rr > 0) {
                                return;
                            }
                        }
                        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                    };
                    this.#reset = (buffer, reader) => {
                        this.#buffer = buffer;
                        this.#reader = reader;
                        this.#eof = false;
                    };
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this.#reset(new Uint8Array(size), rd);
                }
                #buffer;
                #reader;
                #posRead;
                #posWrite;
                #eof;
                #fill;
                #reset;
                buffered() {
                    return this.#posWrite - this.#posRead;
                }
                async readLine(strip = true) {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        deps_ts_7.assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.#eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            deps_ts_7.assert(this.#posRead > 0, "Tried to rewind past start of buffer");
                            this.#posRead--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { bytes: partial, eol: this.#eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { bytes: line, eol: true };
                    }
                    if (strip) {
                        line = util_ts_1.stripEol(line);
                    }
                    return { bytes: line, eol: true };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.#buffer.subarray(this.#posRead + s, this.#posWrite).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.#buffer.subarray(this.#posRead, this.#posRead + i + 1);
                            this.#posRead += i + 1;
                            break;
                        }
                        if (this.#eof) {
                            if (this.#posRead === this.#posWrite) {
                                return null;
                            }
                            slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                            this.#posRead = this.#posWrite;
                            break;
                        }
                        if (this.buffered() >= this.#buffer.byteLength) {
                            this.#posRead = this.#posWrite;
                            const oldbuf = this.#buffer;
                            const newbuf = this.#buffer.slice(0);
                            this.#buffer = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.#posWrite - this.#posRead;
                        try {
                            await this.#fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
            };
            exports_42("BufReader", BufReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/headers", ["https://deno.land/x/oak@v6.1.0/httpError"], function (exports_43, context_43) {
    "use strict";
    var httpError_ts_2, COLON, HTAB, SPACE, decoder;
    var __moduleName = context_43 && context_43.id;
    function toParamRegExp(attributePattern, flags) {
        return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` +
            `(` +
            `[^";\\s][^;\\s]*` +
            `|` +
            `"(?:[^"\\\\]|\\\\"?)+"?` +
            `)`, flags);
    }
    exports_43("toParamRegExp", toParamRegExp);
    async function readHeaders(body) {
        const headers = {};
        let readResult = await body.readLine();
        while (readResult) {
            const { bytes } = readResult;
            if (!bytes.length) {
                return headers;
            }
            let i = bytes.indexOf(COLON);
            if (i === -1) {
                throw new httpError_ts_2.httpErrors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
            }
            const key = decoder.decode(bytes.subarray(0, i)).trim().toLowerCase();
            if (key === "") {
                throw new httpError_ts_2.httpErrors.BadRequest("Invalid header key.");
            }
            i++;
            while (i < bytes.byteLength && (bytes[i] === SPACE || bytes[i] === HTAB)) {
                i++;
            }
            const value = decoder.decode(bytes.subarray(i)).trim();
            headers[key] = value;
            readResult = await body.readLine();
        }
        throw new httpError_ts_2.httpErrors.BadRequest("Unexpected end of body reached.");
    }
    exports_43("readHeaders", readHeaders);
    function unquote(value) {
        if (value.startsWith(`"`)) {
            const parts = value.slice(1).split(`\\"`);
            for (let i = 0; i < parts.length; ++i) {
                const quoteIndex = parts[i].indexOf(`"`);
                if (quoteIndex !== -1) {
                    parts[i] = parts[i].slice(0, quoteIndex);
                    parts.length = i + 1;
                }
                parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join(`"`);
        }
        return value;
    }
    exports_43("unquote", unquote);
    return {
        setters: [
            function (httpError_ts_2_1) {
                httpError_ts_2 = httpError_ts_2_1;
            }
        ],
        execute: function () {
            COLON = ":".charCodeAt(0);
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            decoder = new TextDecoder();
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/content_disposition", ["https://deno.land/x/oak@v6.1.0/headers"], function (exports_44, context_44) {
    "use strict";
    var headers_ts_1, needsEncodingFixup, FILENAME_STAR_REGEX, FILENAME_START_ITER_REGEX, FILENAME_REGEX;
    var __moduleName = context_44 && context_44.id;
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textDecode("utf-8", value);
            if (needsEncodingFixup) {
                value = textDecode("iso-8859-1", value);
            }
        }
        return value;
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
        }
        return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text) => {
            if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                return textDecode(charset, text);
            }
            try {
                text = atob(text);
            }
            catch { }
            return textDecode(charset, text);
        });
    }
    function rfc2231getParam(header) {
        const matches = [];
        let match;
        while ((match = FILENAME_START_ITER_REGEX.exec(header))) {
            const [, ns, quote, part] = match;
            const n = parseInt(ns, 10);
            if (n in matches) {
                if (n === 0) {
                    break;
                }
                continue;
            }
            matches[n] = [quote, part];
        }
        const parts = [];
        for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
                break;
            }
            let [quote, part] = matches[n];
            part = headers_ts_1.unquote(part);
            if (quote) {
                part = unescape(part);
                if (n === 0) {
                    part = rfc5987decode(part);
                }
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc5987decode(value) {
        const encodingEnd = value.indexOf(`'`);
        if (encodingEnd === -1) {
            return value;
        }
        const encoding = value.slice(0, encodingEnd);
        const langValue = value.slice(encodingEnd + 1);
        return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
    }
    function textDecode(encoding, value) {
        if (encoding) {
            try {
                const decoder = new TextDecoder(encoding, { fatal: true });
                const bytes = Array.from(value, (c) => c.charCodeAt(0));
                if (bytes.every((code) => code <= 0xFF)) {
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                }
            }
            catch { }
        }
        return value;
    }
    function getFilename(header) {
        needsEncodingFixup = true;
        let matches = FILENAME_STAR_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(rfc5987decode(unescape(headers_ts_1.unquote(filename)))));
        }
        const filename = rfc2231getParam(header);
        if (filename) {
            return fixupEncoding(rfc2047decode(filename));
        }
        matches = FILENAME_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(headers_ts_1.unquote(filename)));
        }
        return "";
    }
    exports_44("getFilename", getFilename);
    return {
        setters: [
            function (headers_ts_1_1) {
                headers_ts_1 = headers_ts_1_1;
            }
        ],
        execute: function () {
            needsEncodingFixup = false;
            FILENAME_STAR_REGEX = headers_ts_1.toParamRegExp("filename\\*", "i");
            FILENAME_START_ITER_REGEX = headers_ts_1.toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            FILENAME_REGEX = headers_ts_1.toParamRegExp("filename", "i");
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/multipart", ["https://deno.land/x/oak@v6.1.0/buf_reader", "https://deno.land/x/oak@v6.1.0/content_disposition", "https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/headers", "https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/util"], function (exports_45, context_45) {
    "use strict";
    var buf_reader_ts_1, content_disposition_ts_1, deps_ts_8, headers_ts_2, httpError_ts_3, util_ts_2, decoder, encoder, BOUNDARY_PARAM_REGEX, DEFAULT_BUFFER_SIZE, DEFAULT_MAX_FILE_SIZE, DEFAULT_MAX_SIZE, NAME_PARAM_REGEX, FormDataReader;
    var __moduleName = context_45 && context_45.id;
    function append(a, b) {
        const ab = new Uint8Array(a.length + b.length);
        ab.set(a, 0);
        ab.set(b, a.length);
        return ab;
    }
    function isEqual(a, b) {
        return deps_ts_8.equal(util_ts_2.skipLWSPChar(a), b);
    }
    async function readToStartOrEnd(body, start, end) {
        let lineResult;
        while ((lineResult = await body.readLine())) {
            if (isEqual(lineResult.bytes, start)) {
                return true;
            }
            if (isEqual(lineResult.bytes, end)) {
                return false;
            }
        }
        throw new httpError_ts_3.httpErrors.BadRequest("Unable to find multi-part boundary.");
    }
    async function* parts({ body, final, part, maxFileSize, maxSize, outPath, prefix }) {
        async function getFile(contentType) {
            const ext = deps_ts_8.extension(contentType);
            if (!ext) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Invalid media type for part: ${ext}`);
            }
            if (!outPath) {
                outPath = await Deno.makeTempDir();
            }
            const filename = `${outPath}/${util_ts_2.getRandomFilename(prefix, ext)}`;
            const file = await Deno.open(filename, { write: true, createNew: true });
            return [filename, file];
        }
        while (true) {
            const headers = await headers_ts_2.readHeaders(body);
            const contentType = headers["content-type"];
            const contentDisposition = headers["content-disposition"];
            if (!contentDisposition) {
                throw new httpError_ts_3.httpErrors.BadRequest("Form data part missing content-disposition header");
            }
            if (!contentDisposition.match(/^form-data;/i)) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
            }
            const matches = NAME_PARAM_REGEX.exec(contentDisposition);
            if (!matches) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unable to determine name of form body part`);
            }
            let [, name] = matches;
            name = headers_ts_2.unquote(name);
            if (contentType) {
                const originalName = content_disposition_ts_1.getFilename(contentDisposition);
                let byteLength = 0;
                let file;
                let filename;
                let buf;
                if (maxSize) {
                    buf = new Uint8Array();
                }
                else {
                    const result = await getFile(contentType);
                    filename = result[0];
                    file = result[1];
                }
                while (true) {
                    const readResult = await body.readLine(false);
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    let { bytes } = readResult;
                    const strippedBytes = util_ts_2.stripEol(bytes);
                    if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                        if (file) {
                            file.close();
                        }
                        yield [
                            name,
                            {
                                content: buf,
                                contentType,
                                name,
                                filename,
                                originalName,
                            },
                        ];
                        if (isEqual(strippedBytes, final)) {
                            return;
                        }
                        break;
                    }
                    byteLength += bytes.byteLength;
                    if (byteLength > maxFileSize) {
                        if (file) {
                            file.close();
                        }
                        throw new httpError_ts_3.httpErrors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                    }
                    if (buf) {
                        if (byteLength > maxSize) {
                            const result = await getFile(contentType);
                            filename = result[0];
                            file = result[1];
                            await Deno.writeAll(file, buf);
                            buf = undefined;
                        }
                        else {
                            buf = append(buf, bytes);
                        }
                    }
                    if (file) {
                        await Deno.writeAll(file, bytes);
                    }
                }
            }
            else {
                const lines = [];
                while (true) {
                    const readResult = await body.readLine();
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    const { bytes } = readResult;
                    if (isEqual(bytes, part) || isEqual(bytes, final)) {
                        yield [name, lines.join("\n")];
                        if (isEqual(bytes, final)) {
                            return;
                        }
                        break;
                    }
                    lines.push(decoder.decode(bytes));
                }
            }
        }
    }
    return {
        setters: [
            function (buf_reader_ts_1_1) {
                buf_reader_ts_1 = buf_reader_ts_1_1;
            },
            function (content_disposition_ts_1_1) {
                content_disposition_ts_1 = content_disposition_ts_1_1;
            },
            function (deps_ts_8_1) {
                deps_ts_8 = deps_ts_8_1;
            },
            function (headers_ts_2_1) {
                headers_ts_2 = headers_ts_2_1;
            },
            function (httpError_ts_3_1) {
                httpError_ts_3 = httpError_ts_3_1;
            },
            function (util_ts_2_1) {
                util_ts_2 = util_ts_2_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
            BOUNDARY_PARAM_REGEX = headers_ts_2.toParamRegExp("boundary", "i");
            DEFAULT_BUFFER_SIZE = 1048576;
            DEFAULT_MAX_FILE_SIZE = 10485760;
            DEFAULT_MAX_SIZE = 0;
            NAME_PARAM_REGEX = headers_ts_2.toParamRegExp("name", "i");
            FormDataReader = class FormDataReader {
                constructor(contentType, body) {
                    this.#reading = false;
                    const matches = contentType.match(BOUNDARY_PARAM_REGEX);
                    if (!matches) {
                        throw new httpError_ts_3.httpErrors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
                    }
                    let [, boundary] = matches;
                    boundary = headers_ts_2.unquote(boundary);
                    this.#boundaryPart = encoder.encode(`--${boundary}`);
                    this.#boundaryFinal = encoder.encode(`--${boundary}--`);
                    this.#body = body;
                }
                #body;
                #boundaryFinal;
                #boundaryPart;
                #reading;
                async read(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    const result = { fields: {} };
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return result;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            const [key, value] = part;
                            if (typeof value === "string") {
                                result.fields[key] = value;
                            }
                            else {
                                if (!result.files) {
                                    result.files = [];
                                }
                                result.files.push(value);
                            }
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                    return result;
                }
                async *stream(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            yield part;
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            };
            exports_45("FormDataReader", FormDataReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/body", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/isMediaType", "https://deno.land/x/oak@v6.1.0/multipart"], function (exports_46, context_46) {
    "use strict";
    var deps_ts_9, httpError_ts_4, isMediaType_ts_1, multipart_ts_1, defaultBodyContentTypes, decoder, RequestBody;
    var __moduleName = context_46 && context_46.id;
    return {
        setters: [
            function (deps_ts_9_1) {
                deps_ts_9 = deps_ts_9_1;
            },
            function (httpError_ts_4_1) {
                httpError_ts_4 = httpError_ts_4_1;
            },
            function (isMediaType_ts_1_1) {
                isMediaType_ts_1 = isMediaType_ts_1_1;
            },
            function (multipart_ts_1_1) {
                multipart_ts_1 = multipart_ts_1_1;
            }
        ],
        execute: function () {
            defaultBodyContentTypes = {
                json: ["json", "application/*+json", "application/csp-report"],
                form: ["urlencoded"],
                formData: ["multipart"],
                text: ["text"],
            };
            decoder = new TextDecoder();
            RequestBody = class RequestBody {
                constructor(request) {
                    this.#valuePromise = () => {
                        return this.#readAllBody ?? (this.#readAllBody = Deno.readAll(this.#body));
                    };
                    const { body, headers } = request;
                    this.#body = body;
                    this.#headers = headers;
                }
                #body;
                #formDataReader;
                #has;
                #headers;
                #readAllBody;
                #type;
                #valuePromise;
                get({ type, contentTypes }) {
                    if (type === "reader" && this.#type && this.#type !== "reader") {
                        throw new TypeError("Body already consumed and cannot be returned as a reader.");
                    }
                    if (type === "form-data" && this.#type && this.#type !== "form-data") {
                        throw new TypeError("Body already consumed and cannot be returned as form data.");
                    }
                    if (this.#type === "reader" && type !== "reader") {
                        throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
                    }
                    if (this.#type === "form-data" && type !== "form-data") {
                        throw new TypeError("Body already consumed as form data and can only be returned as form data.");
                    }
                    if (type && contentTypes) {
                        throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
                    }
                    if (type === "reader") {
                        this.#type = "reader";
                        return { type, value: this.#body };
                    }
                    if (!this.has()) {
                        this.#type = "undefined";
                    }
                    else if (!this.#type) {
                        const encoding = this.#headers.get("content-encoding") ?? "identity";
                        if (encoding !== "identity") {
                            throw new httpError_ts_4.httpErrors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
                        }
                    }
                    if (this.#type === "undefined") {
                        if (type) {
                            throw new TypeError(`Body is undefined and cannot be returned as "${type}".`);
                        }
                        return { type: "undefined", value: undefined };
                    }
                    if (!type) {
                        const contentType = this.#headers.get("content-type");
                        deps_ts_9.assert(contentType);
                        contentTypes = contentTypes ?? {};
                        const contentTypesJson = [
                            ...defaultBodyContentTypes.json,
                            ...(contentTypes.json ?? []),
                        ];
                        const contentTypesForm = [
                            ...defaultBodyContentTypes.form,
                            ...(contentTypes.form ?? []),
                        ];
                        const contentTypesFormData = [
                            ...defaultBodyContentTypes.formData,
                            ...(contentTypes.formData ?? []),
                        ];
                        const contentTypesText = [
                            ...defaultBodyContentTypes.text,
                            ...(contentTypes.text ?? []),
                        ];
                        if (contentTypes.raw && isMediaType_ts_1.isMediaType(contentType, contentTypes.raw)) {
                            type = "raw";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesJson)) {
                            type = "json";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesForm)) {
                            type = "form";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesFormData)) {
                            type = "form-data";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesText)) {
                            type = "text";
                        }
                        else {
                            type = "raw";
                        }
                    }
                    deps_ts_9.assert(type);
                    let value;
                    switch (type) {
                        case "form":
                            this.#type = "raw";
                            value = async () => new URLSearchParams(decoder.decode(await this.#valuePromise()).replace(/\+/g, " "));
                            break;
                        case "form-data":
                            this.#type = "form-data";
                            value = () => {
                                const contentType = this.#headers.get("content-type");
                                deps_ts_9.assert(contentType);
                                return this.#formDataReader ??
                                    (this.#formDataReader = new multipart_ts_1.FormDataReader(contentType, this.#body));
                            };
                            break;
                        case "json":
                            this.#type = "raw";
                            value = async () => JSON.parse(decoder.decode(await this.#valuePromise()));
                            break;
                        case "raw":
                            this.#type = "raw";
                            value = () => this.#valuePromise();
                            break;
                        case "text":
                            this.#type = "raw";
                            value = async () => decoder.decode(await this.#valuePromise());
                            break;
                        default:
                            throw new TypeError(`Invalid body type: "${type}"`);
                    }
                    return {
                        type,
                        get value() {
                            return value();
                        },
                    };
                }
                has() {
                    return this.#has !== undefined
                        ? this.#has
                        : (this.#has = this.#headers.get("transfer-encoding") !== null ||
                            !!parseInt(this.#headers.get("content-length") ?? "", 10));
                }
            };
            exports_46("RequestBody", RequestBody);
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/negotiation/common", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    function compareSpecs(a, b) {
        return (b.q - a.q ||
            (b.s ?? 0) - (a.s ?? 0) ||
            (a.o ?? 0) - (b.o ?? 0) ||
            a.i - b.i ||
            0);
    }
    exports_47("compareSpecs", compareSpecs);
    function isQuality(spec) {
        return spec.q > 0;
    }
    exports_47("isQuality", isQuality);
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/negotiation/charset", ["https://deno.land/x/oak@v6.1.0/negotiation/common"], function (exports_48, context_48) {
    "use strict";
    var common_ts_2, SIMPLE_CHARSET_REGEXP;
    var __moduleName = context_48 && context_48.id;
    function parseCharset(str, i) {
        const match = SIMPLE_CHARSET_REGEXP.exec(str);
        if (!match) {
            return;
        }
        const [, charset] = match;
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { charset, q, i };
    }
    function parseAcceptCharset(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                result.push(charset);
            }
        }
        return result;
    }
    function specify(charset, spec, i) {
        let s = 0;
        if (spec.charset.toLowerCase() === charset.toLocaleLowerCase()) {
            s |= 1;
        }
        else if (spec.charset !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getCharsetPriority(charset, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(charset, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredCharsets(accept = "*", provided) {
        const accepts = parseAcceptCharset(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_2.isQuality)
                .sort(common_ts_2.compareSpecs)
                .map((spec) => spec.charset);
        }
        const priorities = provided
            .map((type, index) => getCharsetPriority(type, accepts, index));
        return priorities
            .filter(common_ts_2.isQuality)
            .sort(common_ts_2.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_48("preferredCharsets", preferredCharsets);
    return {
        setters: [
            function (common_ts_2_1) {
                common_ts_2 = common_ts_2_1;
            }
        ],
        execute: function () {
            SIMPLE_CHARSET_REGEXP = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/negotiation/encoding", ["https://deno.land/x/oak@v6.1.0/negotiation/common"], function (exports_49, context_49) {
    "use strict";
    var common_ts_3, simpleEncodingRegExp;
    var __moduleName = context_49 && context_49.id;
    function parseEncoding(str, i) {
        const match = simpleEncodingRegExp.exec(str);
        if (!match) {
            return undefined;
        }
        const encoding = match[1];
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const p = param.trim().split("=");
                if (p[0] === "q") {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return { encoding, q, i };
    }
    function specify(encoding, spec, i = -1) {
        if (!spec.encoding) {
            return;
        }
        let s = 0;
        if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
            s = 1;
        }
        else if (spec.encoding !== "*") {
            return;
        }
        return {
            i,
            o: spec.i,
            q: spec.q,
            s,
        };
    }
    function parseAcceptEncoding(accept) {
        const accepts = accept.split(",");
        const parsedAccepts = [];
        let hasIdentity = false;
        let minQuality = 1;
        for (let i = 0; i < accepts.length; i++) {
            const encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                parsedAccepts.push(encoding);
                hasIdentity = hasIdentity || !!specify("identity", encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            parsedAccepts.push({
                encoding: "identity",
                q: minQuality,
                i: accepts.length - 1,
            });
        }
        return parsedAccepts;
    }
    function getEncodingPriority(encoding, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: 0 };
        for (const s of accepted) {
            const spec = specify(encoding, s, index);
            if (spec &&
                (priority.s - spec.s || priority.q - spec.q ||
                    priority.o - spec.o) <
                    0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredEncodings(accept, provided) {
        const accepts = parseAcceptEncoding(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_3.isQuality)
                .sort(common_ts_3.compareSpecs)
                .map((spec) => spec.encoding);
        }
        const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
        return priorities
            .filter(common_ts_3.isQuality)
            .sort(common_ts_3.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_49("preferredEncodings", preferredEncodings);
    return {
        setters: [
            function (common_ts_3_1) {
                common_ts_3 = common_ts_3_1;
            }
        ],
        execute: function () {
            simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/negotiation/language", ["https://deno.land/x/oak@v6.1.0/negotiation/common"], function (exports_50, context_50) {
    "use strict";
    var common_ts_4, SIMPLE_LANGUAGE_REGEXP;
    var __moduleName = context_50 && context_50.id;
    function parseLanguage(str, i) {
        const match = SIMPLE_LANGUAGE_REGEXP.exec(str);
        if (!match) {
            return undefined;
        }
        const [, prefix, suffix] = match;
        const full = suffix ? `${prefix}-${suffix}` : prefix;
        let q = 1;
        if (match[3]) {
            const params = match[3].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { prefix, suffix, full, q, i };
    }
    function parseAcceptLanguage(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                result.push(language);
            }
        }
        return result;
    }
    function specify(language, spec, i) {
        const p = parseLanguage(language, i);
        if (!p) {
            return undefined;
        }
        let s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        }
        else if (spec.prefix.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 2;
        }
        else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        }
        else if (spec.full !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getLanguagePriority(language, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(language, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredLanguages(accept = "*", provided) {
        const accepts = parseAcceptLanguage(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_4.isQuality)
                .sort(common_ts_4.compareSpecs)
                .map((spec) => spec.full);
        }
        const priorities = provided
            .map((type, index) => getLanguagePriority(type, accepts, index));
        return priorities
            .filter(common_ts_4.isQuality)
            .sort(common_ts_4.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_50("preferredLanguages", preferredLanguages);
    return {
        setters: [
            function (common_ts_4_1) {
                common_ts_4 = common_ts_4_1;
            }
        ],
        execute: function () {
            SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.1.0/negotiation/mediaType", ["https://deno.land/x/oak@v6.1.0/negotiation/common"], function (exports_51, context_51) {
    "use strict";
    var common_ts_5, simpleMediaTypeRegExp;
    var __moduleName = context_51 && context_51.id;
    function quoteCount(str) {
        let count = 0;
        let index = 0;
        while ((index = str.indexOf(`"`, index)) !== -1) {
            count++;
            index++;
        }
        return count;
    }
    function splitMediaTypes(accept) {
        const accepts = accept.split(",");
        let j = 0;
        for (let i = 1; i < accepts.length; i++) {
            if (quoteCount(accepts[j]) % 2 === 0) {
                accepts[++j] = accepts[i];
            }
            else {
                accepts[j] += `,${accepts[i]}`;
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        const parameters = str.split(";");
        let j = 0;
        for (let i = 1; i < parameters.length; i++) {
            if (quoteCount(parameters[j]) % 2 === 0) {
                parameters[++j] = parameters[i];
            }
            else {
                parameters[j] += `;${parameters[i]}`;
            }
        }
        parameters.length = j + 1;
        return parameters.map((p) => p.trim());
    }
    function splitKeyValuePair(str) {
        const [key, value] = str.split("=");
        return [key.toLowerCase(), value];
    }
    function parseMediaType(str, i) {
        const match = simpleMediaTypeRegExp.exec(str);
        if (!match) {
            return;
        }
        const params = Object.create(null);
        let q = 1;
        const [, type, subtype, parameters] = match;
        if (parameters) {
            const kvps = splitParameters(parameters).map(splitKeyValuePair);
            for (const [key, val] of kvps) {
                const value = val && val[0] === `"` && val[val.length - 1] === `"`
                    ? val.substr(1, val.length - 2)
                    : val;
                if (key === "q" && value) {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return { type, subtype, params, q, i };
    }
    function parseAccept(accept) {
        const accepts = splitMediaTypes(accept);
        const mediaTypes = [];
        for (let i = 0; i < accepts.length; i++) {
            const mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                mediaTypes.push(mediaType);
            }
        }
        return mediaTypes;
    }
    function getFullType(spec) {
        return `${spec.type}/${spec.subtype}`;
    }
    function specify(type, spec, index) {
        const p = parseMediaType(type, index);
        if (!p) {
            return;
        }
        let s = 0;
        if (spec.type.toLowerCase() === p.type.toLowerCase()) {
            s |= 4;
        }
        else if (spec.type !== "*") {
            return;
        }
        if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
            s |= 2;
        }
        else if (spec.subtype !== "*") {
            return;
        }
        const keys = Object.keys(spec.params);
        if (keys.length) {
            if (keys.every((key) => (spec.params[key] || "").toLowerCase() ===
                (p.params[key] || "").toLowerCase())) {
                s |= 1;
            }
            else {
                return;
            }
        }
        return {
            i: index,
            o: spec.o,
            q: spec.q,
            s,
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: index };
        for (const accepts of accepted) {
            const spec = specify(type, accepts, index);
            if (spec &&
                ((priority.s || 0) - (spec.s || 0) ||
                    (priority.q || 0) - (spec.q || 0) ||
                    (priority.o || 0) - (spec.o || 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredMediaTypes(accept, provided) {
        const accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
            return accepts
                .filter(common_ts_5.isQuality)
                .sort(common_ts_5.compareSpecs)
                .map(getFullType);
        }
        const priorities = provided.map((type, index) => {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities
            .filter(common_ts_5.isQuality)
            .sort(common_ts_5.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_51("preferredMediaTypes", preferredMediaTypes);
    return {
        setters: [
            function (common_ts_5_1) {
                common_ts_5 = common_ts_5_1;
            }
        ],
        execute: function () {
            simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/request", ["https://deno.land/x/oak@v6.1.0/body", "https://deno.land/x/oak@v6.1.0/negotiation/charset", "https://deno.land/x/oak@v6.1.0/negotiation/encoding", "https://deno.land/x/oak@v6.1.0/negotiation/language", "https://deno.land/x/oak@v6.1.0/negotiation/mediaType"], function (exports_52, context_52) {
    "use strict";
    var body_ts_1, charset_ts_1, encoding_ts_1, language_ts_1, mediaType_ts_1, decoder, Request;
    var __moduleName = context_52 && context_52.id;
    return {
        setters: [
            function (body_ts_1_1) {
                body_ts_1 = body_ts_1_1;
            },
            function (charset_ts_1_1) {
                charset_ts_1 = charset_ts_1_1;
            },
            function (encoding_ts_1_1) {
                encoding_ts_1 = encoding_ts_1_1;
            },
            function (language_ts_1_1) {
                language_ts_1 = language_ts_1_1;
            },
            function (mediaType_ts_1_1) {
                mediaType_ts_1 = mediaType_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            Request = class Request {
                constructor(serverRequest, proxy = false, secure = false) {
                    this.#proxy = proxy;
                    this.#secure = secure;
                    this.#serverRequest = serverRequest;
                    this.#body = new body_ts_1.RequestBody(serverRequest);
                }
                #body;
                #proxy;
                #secure;
                #serverRequest;
                #url;
                get hasBody() {
                    return this.#body.has();
                }
                get headers() {
                    return this.#serverRequest.headers;
                }
                get ip() {
                    return this.#proxy
                        ? this.ips[0]
                        : this.#serverRequest.conn.remoteAddr.hostname;
                }
                get ips() {
                    return this.#proxy
                        ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                            this.#serverRequest.conn.remoteAddr.hostname).split(/\s*,\s*/)
                        : [];
                }
                get method() {
                    return this.#serverRequest.method;
                }
                get secure() {
                    return this.#secure;
                }
                get serverRequest() {
                    return this.#serverRequest;
                }
                get url() {
                    if (!this.#url) {
                        const serverRequest = this.#serverRequest;
                        let proto;
                        let host;
                        if (this.#proxy) {
                            proto = serverRequest
                                .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                                "http";
                            host = serverRequest.headers.get("x-forwarded-host") ??
                                serverRequest.headers.get("host") ?? "";
                        }
                        else {
                            proto = this.#secure ? "https" : "http";
                            host = serverRequest.headers.get("host") ?? "";
                        }
                        this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
                    }
                    return this.#url;
                }
                accepts(...types) {
                    const acceptValue = this.#serverRequest.headers.get("Accept");
                    if (!acceptValue) {
                        return;
                    }
                    if (types.length) {
                        return mediaType_ts_1.preferredMediaTypes(acceptValue, types)[0];
                    }
                    return mediaType_ts_1.preferredMediaTypes(acceptValue);
                }
                acceptsCharsets(...charsets) {
                    const acceptCharsetValue = this.#serverRequest.headers.get("Accept-Charset");
                    if (!acceptCharsetValue) {
                        return;
                    }
                    if (charsets.length) {
                        return charset_ts_1.preferredCharsets(acceptCharsetValue, charsets)[0];
                    }
                    return charset_ts_1.preferredCharsets(acceptCharsetValue);
                }
                acceptsEncodings(...encodings) {
                    const acceptEncodingValue = this.#serverRequest.headers.get("Accept-Encoding");
                    if (!acceptEncodingValue) {
                        return;
                    }
                    if (encodings.length) {
                        return encoding_ts_1.preferredEncodings(acceptEncodingValue, encodings)[0];
                    }
                    return encoding_ts_1.preferredEncodings(acceptEncodingValue);
                }
                acceptsLanguages(...langs) {
                    const acceptLanguageValue = this.#serverRequest.headers.get("Accept-Language");
                    if (!acceptLanguageValue) {
                        return;
                    }
                    if (langs.length) {
                        return language_ts_1.preferredLanguages(acceptLanguageValue, langs)[0];
                    }
                    return language_ts_1.preferredLanguages(acceptLanguageValue);
                }
                body(options = {}) {
                    return this.#body.get(options);
                }
            };
            exports_52("Request", Request);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/response", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/util"], function (exports_53, context_53) {
    "use strict";
    var deps_ts_10, util_ts_3, REDIRECT_BACK, BODY_TYPES, encoder, Response;
    var __moduleName = context_53 && context_53.id;
    function isReader(value) {
        return value && typeof value === "object" && "read" in value &&
            typeof value.read === "function";
    }
    async function convertBody(body, type) {
        let result;
        if (BODY_TYPES.includes(typeof body)) {
            const bodyText = String(body);
            result = encoder.encode(bodyText);
            type = type ?? (util_ts_3.isHtml(bodyText) ? "html" : "text/plain");
        }
        else if (body instanceof Uint8Array || isReader(body)) {
            result = body;
        }
        else if (body && typeof body === "object") {
            result = encoder.encode(JSON.stringify(body));
            type = type ?? "json";
        }
        else if (typeof body === "function") {
            const result = body.call(null);
            return convertBody(await result, type);
        }
        else if (body) {
            throw new TypeError("Response body was set but could not convert.");
        }
        return [result, type];
    }
    return {
        setters: [
            function (deps_ts_10_1) {
                deps_ts_10 = deps_ts_10_1;
            },
            function (util_ts_3_1) {
                util_ts_3 = util_ts_3_1;
            }
        ],
        execute: function () {
            exports_53("REDIRECT_BACK", REDIRECT_BACK = Symbol("redirect backwards"));
            BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
            encoder = new TextEncoder();
            Response = class Response {
                constructor(request) {
                    this.#headers = new Headers();
                    this.#resources = [];
                    this.#writable = true;
                    this.#getBody = async () => {
                        const [body, type] = await convertBody(this.body, this.type);
                        this.type = type;
                        return body;
                    };
                    this.#setContentType = () => {
                        if (this.type) {
                            const contentTypeString = deps_ts_10.contentType(this.type);
                            if (contentTypeString && !this.headers.has("Content-Type")) {
                                this.headers.append("Content-Type", contentTypeString);
                            }
                        }
                    };
                    this.#request = request;
                }
                #body;
                #headers;
                #request;
                #resources;
                #serverResponse;
                #status;
                #type;
                #writable;
                #getBody;
                #setContentType;
                get body() {
                    return this.#body;
                }
                set body(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#body = value;
                }
                get headers() {
                    return this.#headers;
                }
                set headers(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#headers = value;
                }
                get status() {
                    if (this.#status) {
                        return this.#status;
                    }
                    const typeofbody = typeof this.body;
                    return this.body &&
                        (BODY_TYPES.includes(typeofbody) || typeofbody === "object")
                        ? deps_ts_10.Status.OK
                        : deps_ts_10.Status.NotFound;
                }
                set status(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#status = value;
                }
                get type() {
                    return this.#type;
                }
                set type(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#type = value;
                }
                get writable() {
                    return this.#writable;
                }
                addResource(rid) {
                    this.#resources.push(rid);
                }
                destroy() {
                    this.#writable = false;
                    this.#body = undefined;
                    this.#serverResponse = undefined;
                    for (const rid of this.#resources) {
                        Deno.close(rid);
                    }
                }
                redirect(url, alt = "/") {
                    if (url === REDIRECT_BACK) {
                        url = this.#request.headers.get("Referrer") ?? String(alt);
                    }
                    else if (typeof url === "object") {
                        url = String(url);
                    }
                    this.headers.set("Location", util_ts_3.encodeUrl(url));
                    if (!this.status || !util_ts_3.isRedirectStatus(this.status)) {
                        this.status = deps_ts_10.Status.Found;
                    }
                    if (this.#request.accepts("html")) {
                        url = encodeURI(url);
                        this.type = "text/html; charset=utf-8";
                        this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                        return;
                    }
                    this.type = "text/plain; charset=utf-8";
                    this.body = `Redirecting to ${url}.`;
                }
                async toServerResponse() {
                    if (this.#serverResponse) {
                        return this.#serverResponse;
                    }
                    const body = await this.#getBody();
                    this.#setContentType();
                    const { headers } = this;
                    if (!(body ||
                        headers.has("Content-Type") ||
                        headers.has("Content-Length"))) {
                        headers.append("Content-Length", "0");
                    }
                    this.#writable = false;
                    return this.#serverResponse = {
                        status: this.#status ?? (body ? deps_ts_10.Status.OK : deps_ts_10.Status.NotFound),
                        body,
                        headers,
                    };
                }
            };
            exports_53("Response", Response);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/cookies", [], function (exports_54, context_54) {
    "use strict";
    var matchCache, FIELD_CONTENT_REGEXP, KEY_REGEXP, SAME_SITE_REGEXP, Cookie, Cookies;
    var __moduleName = context_54 && context_54.id;
    function getPattern(name) {
        if (name in matchCache) {
            return matchCache[name];
        }
        return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for (let i = headers.length - 1; i >= 0; i--) {
                if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    function validateCookieProperty(key, value) {
        if (value && !FIELD_CONTENT_REGEXP.test(value)) {
            throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
        }
    }
    return {
        setters: [],
        execute: function () {
            matchCache = {};
            FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
            KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
            SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
            Cookie = class Cookie {
                constructor(name, value, attributes) {
                    this.httpOnly = true;
                    this.overwrite = false;
                    this.path = "/";
                    this.sameSite = false;
                    this.secure = false;
                    validateCookieProperty("name", name);
                    validateCookieProperty("value", value);
                    this.name = name;
                    this.value = value ?? "";
                    Object.assign(this, attributes);
                    if (!this.value) {
                        this.expires = new Date(0);
                        this.maxAge = undefined;
                    }
                    validateCookieProperty("path", this.path);
                    validateCookieProperty("domain", this.domain);
                    if (this.sameSite && typeof this.sameSite === "string" &&
                        !SAME_SITE_REGEXP.test(this.sameSite)) {
                        throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
                    }
                }
                toHeader() {
                    let header = this.toString();
                    if (this.maxAge) {
                        this.expires = new Date(Date.now() + this.maxAge);
                    }
                    if (this.path) {
                        header += `; path=${this.path}`;
                    }
                    if (this.expires) {
                        header += `; expires=${this.expires.toUTCString()}`;
                    }
                    if (this.domain) {
                        header += `; domain=${this.domain}`;
                    }
                    if (this.sameSite) {
                        header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
                    }
                    if (this.secure) {
                        header += "; secure";
                    }
                    if (this.httpOnly) {
                        header += "; httponly";
                    }
                    return header;
                }
                toString() {
                    return `${this.name}=${this.value}`;
                }
            };
            Cookies = class Cookies {
                constructor(request, response, options = {}) {
                    this.#requestKeys = () => {
                        if (this.#cookieKeys) {
                            return this.#cookieKeys;
                        }
                        const result = this.#cookieKeys = [];
                        const header = this.#request.headers.get("cookie");
                        if (!header) {
                            return result;
                        }
                        let matches;
                        while ((matches = KEY_REGEXP.exec(header))) {
                            const [, key] = matches;
                            result.push(key);
                        }
                        return result;
                    };
                    const { keys, secure } = options;
                    this.#keys = keys;
                    this.#request = request;
                    this.#response = response;
                    this.#secure = secure;
                }
                #cookieKeys;
                #keys;
                #request;
                #response;
                #secure;
                #requestKeys;
                delete(name, options = {}) {
                    this.set(name, null, options);
                    return true;
                }
                *entries() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
                forEach(callback, thisArg = null) {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            callback.call(thisArg, key, value, this);
                        }
                    }
                }
                get(name, options = {}) {
                    const signed = options.signed ?? !!this.#keys;
                    const nameSig = `${name}.sig`;
                    const header = this.#request.headers.get("cookie");
                    if (!header) {
                        return;
                    }
                    const match = header.match(getPattern(name));
                    if (!match) {
                        return;
                    }
                    const [, value] = match;
                    if (!signed) {
                        return value;
                    }
                    const digest = this.get(nameSig, { signed: false });
                    if (!digest) {
                        return;
                    }
                    const data = `${name}=${value}`;
                    if (!this.#keys) {
                        throw new TypeError("keys required for signed cookies");
                    }
                    const index = this.#keys.indexOf(data, digest);
                    if (index < 0) {
                        this.delete(nameSig, { path: "/", signed: false });
                    }
                    else {
                        if (index) {
                            this.set(nameSig, this.#keys.sign(data), { signed: false });
                        }
                        return value;
                    }
                }
                *keys() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield key;
                        }
                    }
                }
                set(name, value, options = {}) {
                    const request = this.#request;
                    const response = this.#response;
                    let headers = response.headers.get("Set-Cookie") ?? [];
                    if (typeof headers === "string") {
                        headers = [headers];
                    }
                    const secure = this.#secure !== undefined ? this.#secure : request.secure;
                    const signed = options.signed ?? !!this.#keys;
                    if (!secure && options.secure) {
                        throw new TypeError("Cannot send secure cookie over unencrypted connection.");
                    }
                    const cookie = new Cookie(name, value, options);
                    cookie.secure = options.secure ?? secure;
                    pushCookie(headers, cookie);
                    if (signed) {
                        if (!this.#keys) {
                            throw new TypeError(".keys required for signed cookies.");
                        }
                        cookie.value = this.#keys.sign(cookie.toString());
                        cookie.name += ".sig";
                        pushCookie(headers, cookie);
                    }
                    for (const header of headers) {
                        response.headers.append("Set-Cookie", header);
                    }
                    return this;
                }
                *values() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield value;
                        }
                    }
                }
                *[Symbol.iterator]() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
            };
            exports_54("Cookies", Cookies);
        }
    };
});
/*!
 * Adapted from koa-send at https://github.com/koajs/send and which is licensed
 * with the MIT license.
 */
System.register("https://deno.land/x/oak@v6.1.0/send", ["https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/util"], function (exports_55, context_55) {
    "use strict";
    var httpError_ts_5, deps_ts_11, util_ts_4;
    var __moduleName = context_55 && context_55.id;
    function isHidden(path) {
        const pathArr = path.split("/");
        for (const segment of pathArr) {
            if (segment[0] === "." && segment !== "." && segment !== "..") {
                return true;
            }
            return false;
        }
    }
    async function exists(path) {
        try {
            return (await Deno.stat(path)).isFile;
        }
        catch {
            return false;
        }
    }
    async function send({ request, response }, path, options = { root: "" }) {
        const { brotli = true, extensions, format = true, gzip = true, hidden = false, immutable = false, index, maxage = 0, root, } = options;
        const trailingSlash = path[path.length - 1] === "/";
        path = util_ts_4.decodeComponent(path.substr(deps_ts_11.parse(path).root.length));
        if (index && trailingSlash) {
            path += index;
        }
        if (!hidden && isHidden(path)) {
            throw httpError_ts_5.createHttpError(403);
        }
        path = util_ts_4.resolvePath(root, path);
        let encodingExt = "";
        if (brotli &&
            request.acceptsEncodings("br", "identity") === "br" &&
            (await exists(`${path}.br`))) {
            path = `${path}.br`;
            response.headers.set("Content-Encoding", "br");
            response.headers.delete("Content-Length");
            encodingExt = ".br";
        }
        else if (gzip &&
            request.acceptsEncodings("gzip", "identity") === "gzip" &&
            (await exists(`${path}.gz`))) {
            path = `${path}.gz`;
            response.headers.set("Content-Encoding", "gzip");
            response.headers.delete("Content-Length");
            encodingExt = ".gz";
        }
        if (extensions && !/\.[^/]*$/.exec(path)) {
            for (let ext of extensions) {
                if (!/^\./.exec(ext)) {
                    ext = `.${ext}`;
                }
                if (await exists(`${path}${ext}`)) {
                    path += ext;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await Deno.stat(path);
            if (stats.isDirectory) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await Deno.stat(path);
                }
                else {
                    return;
                }
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                throw httpError_ts_5.createHttpError(404, err.message);
            }
            throw httpError_ts_5.createHttpError(500, err.message);
        }
        response.headers.set("Content-Length", String(stats.size));
        if (!response.headers.has("Last-Modified") && stats.mtime) {
            response.headers.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!response.headers.has("Cache-Control")) {
            const directives = [`max-age=${(maxage / 1000) | 0}`];
            if (immutable) {
                directives.push("immutable");
            }
            response.headers.set("Cache-Control", directives.join(","));
        }
        if (!response.type) {
            response.type = encodingExt !== ""
                ? deps_ts_11.extname(deps_ts_11.basename(path, encodingExt))
                : deps_ts_11.extname(path);
        }
        const file = await Deno.open(path, { read: true });
        response.addResource(file.rid);
        response.body = file;
        return path;
    }
    exports_55("send", send);
    return {
        setters: [
            function (httpError_ts_5_1) {
                httpError_ts_5 = httpError_ts_5_1;
            },
            function (deps_ts_11_1) {
                deps_ts_11 = deps_ts_11_1;
            },
            function (util_ts_4_1) {
                util_ts_4 = util_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/server_sent_event", ["https://deno.land/x/oak@v6.1.0/deps"], function (exports_56, context_56) {
    "use strict";
    var deps_ts_12, encoder, CloseEvent, ServerSentEvent, response, responseHeaders, ServerSentEventTarget;
    var __moduleName = context_56 && context_56.id;
    return {
        setters: [
            function (deps_ts_12_1) {
                deps_ts_12 = deps_ts_12_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            CloseEvent = class CloseEvent extends Event {
                constructor(eventInit) {
                    super("close", eventInit);
                }
            };
            ServerSentEvent = class ServerSentEvent extends Event {
                constructor(type, data, { replacer, space, ...eventInit } = {}) {
                    super(type, eventInit);
                    this.#type = type;
                    try {
                        this.#data = typeof data === "string"
                            ? data
                            : JSON.stringify(data, replacer, space);
                    }
                    catch (e) {
                        deps_ts_12.assert(e instanceof Error);
                        throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
                    }
                    const { id } = eventInit;
                    this.#id = id;
                }
                #data;
                #id;
                #type;
                get data() {
                    return this.#data;
                }
                get id() {
                    return this.#id;
                }
                toString() {
                    const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
                    return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
                }
            };
            exports_56("ServerSentEvent", ServerSentEvent);
            response = `HTTP/1.1 200 OK\n`;
            responseHeaders = new Headers([
                ["Connection", "Keep-Alive"],
                ["Content-Type", "text/event-stream"],
                ["Cache-Control", "no-cache"],
                ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
            ]);
            ServerSentEventTarget = class ServerSentEventTarget extends EventTarget {
                constructor(app, serverRequest, { headers } = {}) {
                    super();
                    this.#closed = false;
                    this.#prev = Promise.resolve();
                    this.#send = async (payload, prev) => {
                        if (this.#closed) {
                            return;
                        }
                        if (this.#ready !== true) {
                            await this.#ready;
                            this.#ready = true;
                        }
                        try {
                            await prev;
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                        }
                    };
                    this.#setup = async (overrideHeaders) => {
                        const headers = new Headers(responseHeaders);
                        if (overrideHeaders) {
                            for (const [key, value] of overrideHeaders) {
                                headers.set(key, value);
                            }
                        }
                        let payload = response;
                        for (const [key, value] of headers) {
                            payload += `${key}: ${value}\n`;
                        }
                        payload += `\n`;
                        try {
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                            throw error;
                        }
                    };
                    this.#app = app;
                    this.#serverRequest = serverRequest;
                    this.#writer = this.#serverRequest.w;
                    this.addEventListener("close", () => {
                        this.#closed = true;
                        try {
                            this.#serverRequest.conn.close();
                        }
                        catch (error) {
                            if (!(error instanceof Deno.errors.BadResource)) {
                                const errorEvent = new ErrorEvent("error", { error });
                                this.dispatchEvent(errorEvent);
                                this.#app.dispatchEvent(errorEvent);
                            }
                        }
                    });
                    this.#ready = this.#setup(headers);
                }
                #app;
                #closed;
                #prev;
                #ready;
                #serverRequest;
                #writer;
                #send;
                #setup;
                get closed() {
                    return this.#closed;
                }
                async close() {
                    if (this.#ready !== true) {
                        await this.#ready;
                    }
                    await this.#prev;
                    this.dispatchEvent(new CloseEvent({ cancelable: false }));
                }
                dispatchComment(comment) {
                    this.#prev = this.#send(`: ${comment.split("\n").join("\n: ")}\n\n`, this.#prev);
                    return true;
                }
                dispatchMessage(data) {
                    const event = new ServerSentEvent("__message", data);
                    return this.dispatchEvent(event);
                }
                dispatchEvent(event) {
                    let dispatched = super.dispatchEvent(event);
                    if (dispatched && event instanceof ServerSentEvent) {
                        this.#prev = this.#send(String(event), this.#prev);
                    }
                    return dispatched;
                }
            };
            exports_56("ServerSentEventTarget", ServerSentEventTarget);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/context", ["https://deno.land/x/oak@v6.1.0/cookies", "https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/request", "https://deno.land/x/oak@v6.1.0/response", "https://deno.land/x/oak@v6.1.0/send", "https://deno.land/x/oak@v6.1.0/server_sent_event"], function (exports_57, context_57) {
    "use strict";
    var cookies_ts_1, deps_ts_13, httpError_ts_6, request_ts_1, response_ts_1, send_ts_1, server_sent_event_ts_1, Context;
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [
            function (cookies_ts_1_1) {
                cookies_ts_1 = cookies_ts_1_1;
            },
            function (deps_ts_13_1) {
                deps_ts_13 = deps_ts_13_1;
            },
            function (httpError_ts_6_1) {
                httpError_ts_6 = httpError_ts_6_1;
            },
            function (request_ts_1_1) {
                request_ts_1 = request_ts_1_1;
            },
            function (response_ts_1_1) {
                response_ts_1 = response_ts_1_1;
            },
            function (send_ts_1_1) {
                send_ts_1 = send_ts_1_1;
            },
            function (server_sent_event_ts_1_1) {
                server_sent_event_ts_1 = server_sent_event_ts_1_1;
            }
        ],
        execute: function () {
            Context = class Context {
                constructor(app, serverRequest, secure = false) {
                    this.app = app;
                    this.state = app.state;
                    this.request = new request_ts_1.Request(serverRequest, app.proxy, secure);
                    this.respond = true;
                    this.response = new response_ts_1.Response(this.request);
                    this.cookies = new cookies_ts_1.Cookies(this.request, this.response, {
                        keys: this.app.keys,
                        secure: this.request.secure,
                    });
                }
                #socket;
                #sse;
                get isUpgradable() {
                    return deps_ts_13.acceptable(this.request);
                }
                get socket() {
                    return this.#socket;
                }
                assert(condition, errorStatus = 500, message, props) {
                    if (condition) {
                        return;
                    }
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                send(options) {
                    const { path = this.request.url.pathname, ...sendOptions } = options;
                    return send_ts_1.send(this, path, sendOptions);
                }
                sendEvents(options) {
                    if (this.#sse) {
                        return this.#sse;
                    }
                    this.respond = false;
                    return this.#sse = new server_sent_event_ts_1.ServerSentEventTarget(this.app, this.request.serverRequest, options);
                }
                throw(errorStatus, message, props) {
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                async upgrade() {
                    if (this.#socket) {
                        return this.#socket;
                    }
                    const { conn, r: bufReader, w: bufWriter, headers } = this.request.serverRequest;
                    this.#socket = await deps_ts_13.acceptWebSocket({ conn, bufReader, bufWriter, headers });
                    this.respond = false;
                    return this.#socket;
                }
            };
            exports_57("Context", Context);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/middleware", [], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    function compose(middleware) {
        return function composedMiddleware(context, next) {
            let index = -1;
            async function dispatch(i) {
                if (i <= index) {
                    throw new Error("next() called multiple times.");
                }
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) {
                    fn = next;
                }
                if (!fn) {
                    return;
                }
                await fn(context, dispatch.bind(null, i + 1));
            }
            return dispatch(0);
        };
    }
    exports_58("compose", compose);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/application", ["https://deno.land/x/oak@v6.1.0/context", "https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/keyStack", "https://deno.land/x/oak@v6.1.0/middleware"], function (exports_59, context_59) {
    "use strict";
    var context_ts_1, deps_ts_14, keyStack_ts_1, middleware_ts_1, ADDR_REGEXP, ApplicationErrorEvent, ApplicationListenEvent, Application;
    var __moduleName = context_59 && context_59.id;
    function isOptionsTls(options) {
        return options.secure === true;
    }
    return {
        setters: [
            function (context_ts_1_1) {
                context_ts_1 = context_ts_1_1;
            },
            function (deps_ts_14_1) {
                deps_ts_14 = deps_ts_14_1;
            },
            function (keyStack_ts_1_1) {
                keyStack_ts_1 = keyStack_ts_1_1;
            },
            function (middleware_ts_1_1) {
                middleware_ts_1 = middleware_ts_1_1;
            }
        ],
        execute: function () {
            ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
            ApplicationErrorEvent = class ApplicationErrorEvent extends ErrorEvent {
                constructor(eventInitDict) {
                    super("error", eventInitDict);
                    this.context = eventInitDict.context;
                }
            };
            exports_59("ApplicationErrorEvent", ApplicationErrorEvent);
            ApplicationListenEvent = class ApplicationListenEvent extends Event {
                constructor(eventInitDict) {
                    super("listen", eventInitDict);
                    this.hostname = eventInitDict.hostname;
                    this.port = eventInitDict.port;
                    this.secure = eventInitDict.secure;
                }
            };
            exports_59("ApplicationListenEvent", ApplicationListenEvent);
            Application = class Application extends EventTarget {
                constructor(options = {}) {
                    super();
                    this.#middleware = [];
                    this.#getComposed = () => {
                        if (!this.#composedMiddleware) {
                            this.#composedMiddleware = middleware_ts_1.compose(this.#middleware);
                        }
                        return this.#composedMiddleware;
                    };
                    this.#handleError = (context, error) => {
                        if (!(error instanceof Error)) {
                            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
                        }
                        const { message } = error;
                        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
                        if (!context.response.writable) {
                            return;
                        }
                        for (const key of context.response.headers.keys()) {
                            context.response.headers.delete(key);
                        }
                        if (error.headers && error.headers instanceof Headers) {
                            for (const [key, value] of error.headers) {
                                context.response.headers.set(key, value);
                            }
                        }
                        context.response.type = "text";
                        const status = context.response.status =
                            error instanceof Deno.errors.NotFound
                                ? 404
                                : error.status && typeof error.status === "number"
                                    ? error.status
                                    : 500;
                        context.response.body = error.expose
                            ? error.message
                            : deps_ts_14.STATUS_TEXT.get(status);
                    };
                    this.#handleRequest = async (request, secure, state) => {
                        const context = new context_ts_1.Context(this, request, secure);
                        let resolve;
                        const handlingPromise = new Promise((res) => resolve = res);
                        state.handling.add(handlingPromise);
                        if (!state.closing && !state.closed) {
                            try {
                                await this.#getComposed()(context);
                            }
                            catch (err) {
                                this.#handleError(context, err);
                            }
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                            return;
                        }
                        try {
                            await request.respond(await context.response.toServerResponse());
                            if (state.closing) {
                                state.server.close();
                                state.closed = true;
                            }
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        finally {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                        }
                    };
                    this.handle = async (request, secure = false) => {
                        if (!this.#middleware.length) {
                            throw new TypeError("There is no middleware to process requests.");
                        }
                        const context = new context_ts_1.Context(this, request, secure);
                        try {
                            await this.#getComposed()(context);
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            return;
                        }
                        try {
                            const response = await context.response.toServerResponse();
                            context.response.destroy();
                            return response;
                        }
                        catch (err) {
                            this.#handleError(context, err);
                            throw err;
                        }
                    };
                    const { state, keys, proxy, serve = deps_ts_14.serve, serveTls = deps_ts_14.serveTLS, } = options;
                    this.proxy = proxy ?? false;
                    this.keys = keys;
                    this.state = state ?? {};
                    this.#serve = serve;
                    this.#serveTls = serveTls;
                }
                #composedMiddleware;
                #keys;
                #middleware;
                #serve;
                #serveTls;
                get keys() {
                    return this.#keys;
                }
                set keys(keys) {
                    if (!keys) {
                        this.#keys = undefined;
                        return;
                    }
                    else if (Array.isArray(keys)) {
                        this.#keys = new keyStack_ts_1.KeyStack(keys);
                    }
                    else {
                        this.#keys = keys;
                    }
                }
                #getComposed;
                #handleError;
                #handleRequest;
                addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                }
                async listen(options) {
                    if (!this.#middleware.length) {
                        throw new TypeError("There is no middleware to process requests.");
                    }
                    if (typeof options === "string") {
                        const match = ADDR_REGEXP.exec(options);
                        if (!match) {
                            throw TypeError(`Invalid address passed: "${options}"`);
                        }
                        const [, hostname, portStr] = match;
                        options = { hostname, port: parseInt(portStr, 10) };
                    }
                    const server = isOptionsTls(options)
                        ? this.#serveTls(options)
                        : this.#serve(options);
                    const { signal } = options;
                    const state = {
                        closed: false,
                        closing: false,
                        handling: new Set(),
                        server,
                    };
                    if (signal) {
                        signal.addEventListener("abort", () => {
                            if (!state.handling.size) {
                                server.close();
                                state.closed = true;
                            }
                            state.closing = true;
                        });
                    }
                    const { hostname, port, secure = false } = options;
                    this.dispatchEvent(new ApplicationListenEvent({ hostname, port, secure }));
                    try {
                        for await (const request of server) {
                            this.#handleRequest(request, secure, state);
                        }
                        await Promise.all(state.handling);
                    }
                    catch (error) {
                        const message = error instanceof Error
                            ? error.message
                            : "Application Error";
                        this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
                    }
                }
                use(...middleware) {
                    this.#middleware.push(...middleware);
                    this.#composedMiddleware = undefined;
                    return this;
                }
            };
            exports_59("Application", Application);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/router", ["https://deno.land/x/oak@v6.1.0/deps", "https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/middleware", "https://deno.land/x/oak@v6.1.0/util"], function (exports_60, context_60) {
    "use strict";
    var deps_ts_15, httpError_ts_7, middleware_ts_2, util_ts_5, Layer, Router;
    var __moduleName = context_60 && context_60.id;
    function toUrl(url, params = {}, options) {
        const tokens = deps_ts_15.pathParse(url);
        let replace = {};
        if (tokens.some((token) => typeof token === "object")) {
            replace = params;
        }
        else {
            options = params;
        }
        const toPath = deps_ts_15.compile(url, options);
        let replaced = toPath(replace);
        if (options && options.query) {
            const url = new URL(replaced, "http://oak");
            if (typeof options.query === "string") {
                url.search = options.query;
            }
            else {
                url.search = String(options.query instanceof URLSearchParams
                    ? options.query
                    : new URLSearchParams(options.query));
            }
            return `${url.pathname}${url.search}${url.hash}`;
        }
        return replaced;
    }
    return {
        setters: [
            function (deps_ts_15_1) {
                deps_ts_15 = deps_ts_15_1;
            },
            function (httpError_ts_7_1) {
                httpError_ts_7 = httpError_ts_7_1;
            },
            function (middleware_ts_2_1) {
                middleware_ts_2 = middleware_ts_2_1;
            },
            function (util_ts_5_1) {
                util_ts_5 = util_ts_5_1;
            }
        ],
        execute: function () {
            Layer = class Layer {
                constructor(path, methods, middleware, { name, ...opts } = {}) {
                    this.#paramNames = [];
                    this.#opts = opts;
                    this.name = name;
                    this.methods = [...methods];
                    if (this.methods.includes("GET")) {
                        this.methods.unshift("HEAD");
                    }
                    this.stack = Array.isArray(middleware) ? middleware : [middleware];
                    this.path = path;
                    this.#regexp = deps_ts_15.pathToRegexp(path, this.#paramNames, this.#opts);
                }
                #opts;
                #paramNames;
                #regexp;
                match(path) {
                    return this.#regexp.test(path);
                }
                params(captures, existingParams = {}) {
                    const params = existingParams;
                    for (let i = 0; i < captures.length; i++) {
                        if (this.#paramNames[i]) {
                            const c = captures[i];
                            params[this.#paramNames[i].name] = c ? util_ts_5.decodeComponent(c) : c;
                        }
                    }
                    return params;
                }
                captures(path) {
                    if (this.#opts.ignoreCaptures) {
                        return [];
                    }
                    return path.match(this.#regexp)?.slice(1) ?? [];
                }
                url(params = {}, options) {
                    const url = this.path.replace(/\(\.\*\)/g, "");
                    return toUrl(url, params, options);
                }
                param(param, fn) {
                    const stack = this.stack;
                    const params = this.#paramNames;
                    const middleware = function (ctx, next) {
                        const p = ctx.params[param];
                        deps_ts_15.assert(p);
                        return fn.call(this, p, ctx, next);
                    };
                    middleware.param = param;
                    const names = params.map((p) => p.name);
                    const x = names.indexOf(param);
                    if (x >= 0) {
                        for (let i = 0; i < stack.length; i++) {
                            const fn = stack[i];
                            if (!fn.param || names.indexOf(fn.param) > x) {
                                stack.splice(i, 0, middleware);
                                break;
                            }
                        }
                    }
                    return this;
                }
                setPrefix(prefix) {
                    if (this.path) {
                        this.path = this.path !== "/" || this.#opts.strict === true
                            ? `${prefix}${this.path}`
                            : prefix;
                        this.#paramNames = [];
                        this.#regexp = deps_ts_15.pathToRegexp(this.path, this.#paramNames, this.#opts);
                    }
                    return this;
                }
                toJSON() {
                    return {
                        methods: [...this.methods],
                        middleware: [...this.stack],
                        paramNames: this.#paramNames.map((key) => key.name),
                        path: this.path,
                        regexp: this.#regexp,
                        options: { ...this.#opts },
                    };
                }
            };
            Router = class Router {
                constructor(opts = {}) {
                    this.#params = {};
                    this.#stack = [];
                    this.#match = (path, method) => {
                        const matches = {
                            path: [],
                            pathAndMethod: [],
                            route: false,
                        };
                        for (const route of this.#stack) {
                            if (route.match(path)) {
                                matches.path.push(route);
                                if (route.methods.length === 0 || route.methods.includes(method)) {
                                    matches.pathAndMethod.push(route);
                                    if (route.methods.length) {
                                        matches.route = true;
                                    }
                                }
                            }
                        }
                        return matches;
                    };
                    this.#register = (path, middleware, methods, options = {}) => {
                        if (Array.isArray(path)) {
                            for (const p of path) {
                                this.#register(p, middleware, methods, options);
                            }
                            return;
                        }
                        const { end, name, sensitive, strict, ignoreCaptures } = options;
                        const route = new Layer(path, methods, middleware, {
                            end: end === false ? end : true,
                            name,
                            sensitive: sensitive ?? this.#opts.sensitive ?? false,
                            strict: strict ?? this.#opts.strict ?? false,
                            ignoreCaptures,
                        });
                        if (this.#opts.prefix) {
                            route.setPrefix(this.#opts.prefix);
                        }
                        for (const [param, mw] of Object.entries(this.#params)) {
                            route.param(param, mw);
                        }
                        this.#stack.push(route);
                    };
                    this.#route = (name) => {
                        for (const route of this.#stack) {
                            if (route.name === name) {
                                return route;
                            }
                        }
                    };
                    this.#useVerb = (nameOrPath, pathOrMiddleware, middleware, methods) => {
                        let name = undefined;
                        let path;
                        if (typeof pathOrMiddleware === "string") {
                            name = nameOrPath;
                            path = pathOrMiddleware;
                        }
                        else {
                            path = nameOrPath;
                            middleware.unshift(pathOrMiddleware);
                        }
                        this.#register(path, middleware, methods, { name });
                    };
                    this.#opts = opts;
                    this.#methods = opts.methods ?? [
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT",
                    ];
                }
                #opts;
                #methods;
                #params;
                #stack;
                #match;
                #register;
                #route;
                #useVerb;
                all(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE", "GET", "POST", "PUT"]);
                    return this;
                }
                allowedMethods(options = {}) {
                    const implemented = this.#methods;
                    const allowedMethods = async (context, next) => {
                        const ctx = context;
                        await next();
                        if (!ctx.response.status || ctx.response.status === deps_ts_15.Status.NotFound) {
                            deps_ts_15.assert(ctx.matched);
                            const allowed = new Set();
                            for (const route of ctx.matched) {
                                for (const method of route.methods) {
                                    allowed.add(method);
                                }
                            }
                            const allowedStr = [...allowed].join(", ");
                            if (!implemented.includes(ctx.request.method)) {
                                if (options.throw) {
                                    throw options.notImplemented
                                        ? options.notImplemented()
                                        : new httpError_ts_7.httpErrors.NotImplemented();
                                }
                                else {
                                    ctx.response.status = deps_ts_15.Status.NotImplemented;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                            }
                            else if (allowed.size) {
                                if (ctx.request.method === "OPTIONS") {
                                    ctx.response.status = deps_ts_15.Status.OK;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                                else if (!allowed.has(ctx.request.method)) {
                                    if (options.throw) {
                                        throw options.methodNotAllowed
                                            ? options.methodNotAllowed()
                                            : new httpError_ts_7.httpErrors.MethodNotAllowed();
                                    }
                                    else {
                                        ctx.response.status = deps_ts_15.Status.MethodNotAllowed;
                                        ctx.response.headers.set("Allowed", allowedStr);
                                    }
                                }
                            }
                        }
                    };
                    return allowedMethods;
                }
                delete(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
                    return this;
                }
                *entries() {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        yield [value, value];
                    }
                }
                forEach(callback, thisArg = null) {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        callback.call(thisArg, value, value, this);
                    }
                }
                get(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["GET"]);
                    return this;
                }
                head(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
                    return this;
                }
                *keys() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                options(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
                    return this;
                }
                param(param, middleware) {
                    this.#params[param] = middleware;
                    for (const route of this.#stack) {
                        route.param(param, middleware);
                    }
                    return this;
                }
                patch(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
                    return this;
                }
                post(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["POST"]);
                    return this;
                }
                prefix(prefix) {
                    prefix = prefix.replace(/\/$/, "");
                    this.#opts.prefix = prefix;
                    for (const route of this.#stack) {
                        route.setPrefix(prefix);
                    }
                    return this;
                }
                put(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
                    return this;
                }
                redirect(source, destination, status = deps_ts_15.Status.Found) {
                    if (source[0] !== "/") {
                        const s = this.url(source);
                        if (!s) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        source = s;
                    }
                    if (destination[0] !== "/") {
                        const d = this.url(destination);
                        if (!d) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        destination = d;
                    }
                    this.all(source, (ctx) => {
                        ctx.response.redirect(destination);
                        ctx.response.status = status;
                    });
                    return this;
                }
                routes() {
                    const dispatch = (context, next) => {
                        const ctx = context;
                        const { url: { pathname }, method } = ctx.request;
                        const path = this.#opts.routerPath ?? ctx.routerPath ??
                            decodeURIComponent(pathname);
                        const matches = this.#match(path, method);
                        if (ctx.matched) {
                            ctx.matched.push(...matches.path);
                        }
                        else {
                            ctx.matched = [...matches.path];
                        }
                        ctx.router = this;
                        if (!matches.route)
                            return next();
                        const { pathAndMethod: matchedRoutes } = matches;
                        const chain = matchedRoutes.reduce((prev, route) => [
                            ...prev,
                            (ctx, next) => {
                                ctx.captures = route.captures(path);
                                ctx.params = route.params(ctx.captures, ctx.params);
                                ctx.routeName = route.name;
                                return next();
                            },
                            ...route.stack,
                        ], []);
                        return middleware_ts_2.compose(chain)(ctx, next);
                    };
                    dispatch.router = this;
                    return dispatch;
                }
                url(name, params, options) {
                    const route = this.#route(name);
                    if (route) {
                        return route.url(params, options);
                    }
                }
                use(pathOrMiddleware, ...middleware) {
                    let path;
                    if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
                        path = pathOrMiddleware;
                    }
                    else {
                        middleware.unshift(pathOrMiddleware);
                    }
                    this.#register(path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path });
                    return this;
                }
                *values() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                *[Symbol.iterator]() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                static url(path, params, options) {
                    return toUrl(path, params, options);
                }
            };
            exports_60("Router", Router);
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/helpers", [], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    function isRouterContext(value) {
        return "params" in value;
    }
    function getQuery(ctx, { mergeParams, asMap } = {}) {
        const result = {};
        if (mergeParams && isRouterContext(ctx)) {
            Object.assign(result, ctx.params);
        }
        for (const [key, value] of ctx.request.url.searchParams) {
            result[key] = value;
        }
        return asMap ? new Map(Object.entries(result)) : result;
    }
    exports_61("getQuery", getQuery);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.1.0/mod", ["https://deno.land/x/oak@v6.1.0/application", "https://deno.land/x/oak@v6.1.0/context", "https://deno.land/x/oak@v6.1.0/helpers", "https://deno.land/x/oak@v6.1.0/cookies", "https://deno.land/x/oak@v6.1.0/httpError", "https://deno.land/x/oak@v6.1.0/middleware", "https://deno.land/x/oak@v6.1.0/multipart", "https://deno.land/x/oak@v6.1.0/request", "https://deno.land/x/oak@v6.1.0/response", "https://deno.land/x/oak@v6.1.0/router", "https://deno.land/x/oak@v6.1.0/send", "https://deno.land/x/oak@v6.1.0/server_sent_event", "https://deno.land/x/oak@v6.1.0/util", "https://deno.land/x/oak@v6.1.0/deps"], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    return {
        setters: [
            function (application_ts_1_1) {
                exports_62({
                    "Application": application_ts_1_1["Application"]
                });
            },
            function (context_ts_2_1) {
                exports_62({
                    "Context": context_ts_2_1["Context"]
                });
            },
            function (helpers_1) {
                exports_62("helpers", helpers_1);
            },
            function (cookies_ts_2_1) {
                exports_62({
                    "Cookies": cookies_ts_2_1["Cookies"]
                });
            },
            function (httpError_ts_8_1) {
                exports_62({
                    "HttpError": httpError_ts_8_1["HttpError"],
                    "httpErrors": httpError_ts_8_1["httpErrors"],
                    "isHttpError": httpError_ts_8_1["isHttpError"]
                });
            },
            function (middleware_ts_3_1) {
                exports_62({
                    "composeMiddleware": middleware_ts_3_1["compose"]
                });
            },
            function (multipart_ts_2_1) {
                exports_62({
                    "FormDataReader": multipart_ts_2_1["FormDataReader"]
                });
            },
            function (request_ts_2_1) {
                exports_62({
                    "Request": request_ts_2_1["Request"]
                });
            },
            function (response_ts_2_1) {
                exports_62({
                    "Response": response_ts_2_1["Response"],
                    "REDIRECT_BACK": response_ts_2_1["REDIRECT_BACK"]
                });
            },
            function (router_ts_1_1) {
                exports_62({
                    "Router": router_ts_1_1["Router"]
                });
            },
            function (send_ts_2_1) {
                exports_62({
                    "send": send_ts_2_1["send"]
                });
            },
            function (server_sent_event_ts_2_1) {
                exports_62({
                    "ServerSentEvent": server_sent_event_ts_2_1["ServerSentEvent"],
                    "ServerSentEventTarget": server_sent_event_ts_2_1["ServerSentEventTarget"]
                });
            },
            function (util_ts_6_1) {
                exports_62({
                    "isErrorStatus": util_ts_6_1["isErrorStatus"],
                    "isRedirectStatus": util_ts_6_1["isRedirectStatus"]
                });
            },
            function (deps_ts_16_1) {
                exports_62({
                    "Status": deps_ts_16_1["Status"],
                    "STATUS_TEXT": deps_ts_16_1["STATUS_TEXT"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.63.0/async/deferred", [], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_63("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.63.0/async/delay", [], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_64("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.63.0/async/mux_async_iterator", ["https://deno.land/std@0.63.0/async/deferred"], function (exports_65, context_65) {
    "use strict";
    var deferred_ts_4, MuxAsyncIterator;
    var __moduleName = context_65 && context_65.id;
    return {
        setters: [
            function (deferred_ts_4_1) {
                deferred_ts_4 = deferred_ts_4_1;
            }
        ],
        execute: function () {
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.throws = [];
                    this.signal = deferred_ts_4.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    try {
                        const { value, done } = await iterator.next();
                        if (done) {
                            --this.iteratorCount;
                        }
                        else {
                            this.yields.push({ iterator, value });
                        }
                    }
                    catch (e) {
                        this.throws.push(e);
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        await this.signal;
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        if (this.throws.length) {
                            for (const e of this.throws) {
                                throw e;
                            }
                            this.throws.length = 0;
                        }
                        this.yields.length = 0;
                        this.signal = deferred_ts_4.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_65("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.63.0/async/pool", [], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    function pooledMap(poolLimit, array, iteratorFn) {
        const res = new TransformStream({
            async transform(p, controller) {
                controller.enqueue(await p);
            },
        });
        (async () => {
            const writer = res.writable.getWriter();
            const executing = [];
            for await (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                writer.write(p);
                const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                executing.push(e);
                if (executing.length >= poolLimit) {
                    await Promise.race(executing);
                }
            }
            await Promise.all(executing);
            writer.close();
        })();
        return res.readable.getIterator();
    }
    exports_66("pooledMap", pooledMap);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.63.0/async/mod", ["https://deno.land/std@0.63.0/async/deferred", "https://deno.land/std@0.63.0/async/delay", "https://deno.land/std@0.63.0/async/mux_async_iterator", "https://deno.land/std@0.63.0/async/pool"], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_67(exports);
    }
    return {
        setters: [
            function (deferred_ts_5_1) {
                exportStar_3(deferred_ts_5_1);
            },
            function (delay_ts_2_1) {
                exportStar_3(delay_ts_2_1);
            },
            function (mux_async_iterator_ts_2_1) {
                exportStar_3(mux_async_iterator_ts_2_1);
            },
            function (pool_ts_2_1) {
                exportStar_3(pool_ts_2_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.63.0/encoding/utf8", [], function (exports_68, context_68) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_68 && context_68.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_68("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_68("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_68("encoder", encoder = new TextEncoder());
            exports_68("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.63.0/fmt/colors", [], function (exports_69, context_69) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_69 && context_69.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_69("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_69("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_69("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_69("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_69("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_69("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_69("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_69("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_69("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_69("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_69("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_69("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_69("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_69("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_69("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_69("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_69("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_69("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_69("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_69("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_69("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_69("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_69("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_69("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_69("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_69("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_69("bgWhite", bgWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_69("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_69("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_69("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_69("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_69("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/x/bytes_formater@v1.3.0/deps", ["https://deno.land/std@0.63.0/fmt/colors"], function (exports_70, context_70) {
    "use strict";
    var __moduleName = context_70 && context_70.id;
    return {
        setters: [
            function (colors_ts_2_1) {
                exports_70({
                    "setColorEnabled": colors_ts_2_1["setColorEnabled"],
                    "green": colors_ts_2_1["green"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bytes_formater@v1.3.0/format", ["https://deno.land/x/bytes_formater@v1.3.0/deps"], function (exports_71, context_71) {
    "use strict";
    var deps_ts_17;
    var __moduleName = context_71 && context_71.id;
    function format(data) {
        const bytes = new Uint8Array(data.buffer);
        let out = "";
        out += "         +-------------------------------------------------+\n";
        out += `         |${deps_ts_17.green("  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f ")}|\n`;
        out += "+--------+-------------------------------------------------+----------------+\n";
        const lineCount = Math.ceil(bytes.length / 16);
        for (let line = 0; line < lineCount; line++) {
            const start = line * 16;
            const addr = start.toString(16).padStart(8, "0");
            const lineBytes = bytes.slice(start, start + 16);
            out += `|${deps_ts_17.green(addr)}| `;
            lineBytes.forEach(byte => (out += byte.toString(16).padStart(2, "0") + " "));
            if (lineBytes.length < 16) {
                out += "   ".repeat(16 - lineBytes.length);
            }
            out += "|";
            lineBytes.forEach(function (byte) {
                return (out += byte > 31 && byte < 127 ? deps_ts_17.green(String.fromCharCode(byte)) : ".");
            });
            if (lineBytes.length < 16) {
                out += " ".repeat(16 - lineBytes.length);
            }
            out += "|\n";
        }
        out += "+--------+-------------------------------------------------+----------------+";
        return out;
    }
    exports_71("format", format);
    return {
        setters: [
            function (deps_ts_17_1) {
                deps_ts_17 = deps_ts_17_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bytes_formater@v1.3.0/mod", ["https://deno.land/x/bytes_formater@v1.3.0/format", "https://deno.land/x/bytes_formater@v1.3.0/deps"], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    return {
        setters: [
            function (format_ts_1_1) {
                exports_72({
                    "format": format_ts_1_1["format"]
                });
            },
            function (deps_ts_18_1) {
                exports_72({
                    "setColorEnabled": deps_ts_18_1["setColorEnabled"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/sha1", [], function (exports_73, context_73) {
    "use strict";
    var Sha1Hash;
    var __moduleName = context_73 && context_73.id;
    function binb_sha1(x, len) {
        x[len >> 5] |= 0x80 << (24 - (len % 32));
        x[(((len + 64) >> 9) << 4) + 15] = len;
        const w = [];
        let a = 1732584193;
        let b = -271733879;
        let c = -1732584194;
        let d = 271733878;
        let e = -1009589776;
        for (let i = 0; i < x.length; i += 16) {
            const olda = a;
            const oldb = b;
            const oldc = c;
            const oldd = d;
            const olde = e;
            for (let j = 0; j < 80; j++) {
                if (j < 16)
                    w[j] = x[i + j];
                else
                    w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
                e = d;
                d = c;
                c = bit_rol(b, 30);
                b = a;
                a = t;
            }
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
            e = safe_add(e, olde);
        }
        return [a, b, c, d, e];
    }
    function sha1_ft(t, b, c, d) {
        if (t < 20)
            return (b & c) | (~b & d);
        if (t < 40)
            return b ^ c ^ d;
        if (t < 60)
            return (b & c) | (b & d) | (c & d);
        return b ^ c ^ d;
    }
    function sha1_kt(t) {
        return t < 20
            ? 1518500249
            : t < 40
                ? 1859775393
                : t < 60
                    ? -1894007588
                    : -899497514;
    }
    function safe_add(x, y) {
        const lsw = (x & 0xffff) + (y & 0xffff);
        const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xffff);
    }
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
    return {
        setters: [],
        execute: function () {
            Sha1Hash = class Sha1Hash {
                digest(bytes) {
                    let data = [];
                    for (var i = 0; i < bytes.length * 8; i += 8) {
                        data[i >> 5] |= (bytes[i / 8] & 0xff) << (24 - (i % 32));
                    }
                    data = binb_sha1(data, bytes.length * 8);
                    return this.toStrBytes(data);
                }
                toStrBytes(input) {
                    let pos = 0;
                    const data = new Uint8Array(input.length * 4);
                    for (let i = 0; i < input.length * 32; i += 8) {
                        data[pos++] = (input[i >> 5] >> (24 - (i % 32))) & 0xff;
                    }
                    return data;
                }
            };
            exports_73("Sha1Hash", Sha1Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/md5", [], function (exports_74, context_74) {
    "use strict";
    var Md5Hash;
    var __moduleName = context_74 && context_74.id;
    function safeAdd(x, y) {
        const lsw = (x & 0xffff) + (y & 0xffff);
        const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xffff);
    }
    function bitRotateLeft(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
    function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
        return md5cmn((b & c) | (~b & d), a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
        return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function binlMD5(x, len) {
        x[len >> 5] |= 0x80 << len % 32;
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        let olda, oldb, oldc, oldd;
        let a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (let i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;
            a = md5ff(a, b, c, d, x[i], 7, -680876936);
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5gg(b, c, d, a, x[i], 20, -373897302);
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5hh(d, a, b, c, x[i], 11, -358537222);
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5ii(a, b, c, d, x[i], 6, -198630844);
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safeAdd(a, olda);
            b = safeAdd(b, oldb);
            c = safeAdd(c, oldc);
            d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
    }
    function md5(bytes) {
        let data = [];
        var length8 = bytes.length * 8;
        for (let i = 0; i < length8; i += 8) {
            data[i >> 5] |= (bytes[i / 8] & 0xff) << i % 32;
        }
        return binlMD5(data, bytes.length * 8);
    }
    return {
        setters: [],
        execute: function () {
            Md5Hash = class Md5Hash {
                digest(bytes) {
                    const data = md5(bytes);
                    return this.toStrBytes(data);
                }
                toStrBytes(input) {
                    const buffer = new ArrayBuffer(16);
                    new Uint32Array(buffer).set(input);
                    return new Uint8Array(buffer);
                }
            };
            exports_74("Md5Hash", Md5Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/hash", ["https://deno.land/x/checksum@1.4.0/sha1", "https://deno.land/x/checksum@1.4.0/md5"], function (exports_75, context_75) {
    "use strict";
    var sha1_ts_3, md5_ts_1, encoder, Hash;
    var __moduleName = context_75 && context_75.id;
    function hex(bytes) {
        return Array.prototype.map
            .call(bytes, (x) => x.toString(16).padStart(2, "0"))
            .join("");
    }
    exports_75("hex", hex);
    function encode(str) {
        return encoder.encode(str);
    }
    exports_75("encode", encode);
    return {
        setters: [
            function (sha1_ts_3_1) {
                sha1_ts_3 = sha1_ts_3_1;
            },
            function (md5_ts_1_1) {
                md5_ts_1 = md5_ts_1_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            Hash = class Hash {
                constructor(algorithm) {
                    this.algorithm = algorithm;
                    const algorithms = {
                        sha1: sha1_ts_3.Sha1Hash,
                        md5: md5_ts_1.Md5Hash,
                    };
                    this.instance = new algorithms[algorithm]();
                }
                digest(bytes) {
                    bytes = this.instance.digest(bytes);
                    return {
                        data: bytes,
                        hex: () => hex(bytes),
                    };
                }
                digestString(string) {
                    return this.digest(encode(string));
                }
            };
            exports_75("Hash", Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/mod", ["https://deno.land/x/checksum@1.4.0/hash"], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    return {
        setters: [
            function (hash_ts_1_1) {
                exports_76({
                    "Hash": hash_ts_1_1["Hash"],
                    "hex": hash_ts_1_1["hex"],
                    "encode": hash_ts_1_1["encode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64@v0.2.1/base", [], function (exports_77, context_77) {
    "use strict";
    var __moduleName = context_77 && context_77.id;
    function getLengths(b64) {
        const len = b64.length;
        let validLen = b64.indexOf("=");
        if (validLen === -1) {
            validLen = len;
        }
        const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
        return [validLen, placeHoldersLen];
    }
    function init(lookup, revLookup, urlsafe = false) {
        function _byteLength(validLen, placeHoldersLen) {
            return Math.floor(((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen);
        }
        function tripletToBase64(num) {
            return (lookup[(num >> 18) & 0x3f] +
                lookup[(num >> 12) & 0x3f] +
                lookup[(num >> 6) & 0x3f] +
                lookup[num & 0x3f]);
        }
        function encodeChunk(buf, start, end) {
            const out = new Array((end - start) / 3);
            for (let i = start, curTriplet = 0; i < end; i += 3) {
                out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);
            }
            return out.join("");
        }
        return {
            byteLength(b64) {
                return _byteLength.apply(null, getLengths(b64));
            },
            toUint8Array(b64) {
                const [validLen, placeHoldersLen] = getLengths(b64);
                const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));
                const len = placeHoldersLen ? validLen - 4 : validLen;
                let tmp;
                let curByte = 0;
                let i;
                for (i = 0; i < len; i += 4) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 18) |
                        (revLookup[b64.charCodeAt(i + 1)] << 12) |
                        (revLookup[b64.charCodeAt(i + 2)] << 6) |
                        revLookup[b64.charCodeAt(i + 3)];
                    buf[curByte++] = (tmp >> 16) & 0xff;
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                if (placeHoldersLen === 2) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 2) |
                        (revLookup[b64.charCodeAt(i + 1)] >> 4);
                    buf[curByte++] = tmp & 0xff;
                }
                else if (placeHoldersLen === 1) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 10) |
                        (revLookup[b64.charCodeAt(i + 1)] << 4) |
                        (revLookup[b64.charCodeAt(i + 2)] >> 2);
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                return buf;
            },
            fromUint8Array(buf) {
                const maxChunkLength = 16383;
                const len = buf.length;
                const extraBytes = len % 3;
                const len2 = len - extraBytes;
                const parts = new Array(Math.ceil(len2 / maxChunkLength) + (extraBytes ? 1 : 0));
                let curChunk = 0;
                let chunkEnd;
                for (let i = 0; i < len2; i += maxChunkLength) {
                    chunkEnd = i + maxChunkLength;
                    parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);
                }
                let tmp;
                if (extraBytes === 1) {
                    tmp = buf[len2];
                    parts[curChunk] = lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f];
                    if (!urlsafe)
                        parts[curChunk] += "==";
                }
                else if (extraBytes === 2) {
                    tmp = (buf[len2] << 8) | (buf[len2 + 1] & 0xff);
                    parts[curChunk] = lookup[tmp >> 10] +
                        lookup[(tmp >> 4) & 0x3f] +
                        lookup[(tmp << 2) & 0x3f];
                    if (!urlsafe)
                        parts[curChunk] += "=";
                }
                return parts.join("");
            },
        };
    }
    exports_77("init", init);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64@v0.2.1/base64url", ["https://deno.land/x/base64@v0.2.1/base"], function (exports_78, context_78) {
    "use strict";
    var base_ts_1, lookup, revLookup, code, _a, byteLength, toUint8Array, fromUint8Array;
    var __moduleName = context_78 && context_78.id;
    return {
        setters: [
            function (base_ts_1_1) {
                base_ts_1 = base_ts_1_1;
            }
        ],
        execute: function () {
            lookup = [];
            revLookup = [];
            code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
            for (let i = 0, l = code.length; i < l; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }
            _a = base_ts_1.init(lookup, revLookup, true), exports_78("byteLength", byteLength = _a.byteLength), exports_78("toUint8Array", toUint8Array = _a.toUint8Array), exports_78("fromUint8Array", fromUint8Array = _a.fromUint8Array);
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod", ["https://deno.land/x/base64@v0.2.1/base64url"], function (exports_79, context_79) {
    "use strict";
    var base64url_ts_1, decoder, encoder;
    var __moduleName = context_79 && context_79.id;
    function toHexString(buf) {
        return buf.reduce((hex, byte) => `${hex}${byte < 16 ? "0" : ""}${byte.toString(16)}`, "");
    }
    function fromHexString(hex) {
        const len = hex.length;
        if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {
            throw new TypeError("Invalid hex string.");
        }
        hex = hex.toLowerCase();
        const buf = new Uint8Array(Math.floor(len / 2));
        const end = len / 2;
        for (let i = 0; i < end; ++i) {
            buf[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return buf;
    }
    function decode(buf, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return decoder.decode(buf);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.fromUint8Array(buf);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return toHexString(buf);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_79("decode", decode);
    function encode(str, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return encoder.encode(str);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.toUint8Array(str);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return fromHexString(str);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_79("encode", encode);
    return {
        setters: [
            function (base64url_ts_1_1) {
                base64url_ts_1 = base64url_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
        }
    };
});
System.register("https://deno.land/x/sha256@v1.0.2/deps", ["https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod"], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    return {
        setters: [
            function (mod_ts_13_1) {
                exports_80({
                    "encode": mod_ts_13_1["encode"],
                    "decode": mod_ts_13_1["decode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/sha256@v1.0.2/mod", ["https://deno.land/x/sha256@v1.0.2/deps"], function (exports_81, context_81) {
    "use strict";
    var deps_ts_19, BYTES, SHA256;
    var __moduleName = context_81 && context_81.id;
    function sha256(msg, inputEncoding, outputEncoding) {
        return new SHA256().update(msg, inputEncoding).digest(outputEncoding);
    }
    exports_81("sha256", sha256);
    return {
        setters: [
            function (deps_ts_19_1) {
                deps_ts_19 = deps_ts_19_1;
            }
        ],
        execute: function () {
            exports_81("BYTES", BYTES = 32);
            SHA256 = class SHA256 {
                constructor() {
                    this.hashSize = BYTES;
                    this._buf = new Uint8Array(64);
                    this._K = new Uint32Array([
                        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                    ]);
                    this.init();
                }
                init() {
                    this._H = new Uint32Array([
                        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                    ]);
                    this._bufIdx = 0;
                    this._count = new Uint32Array(2);
                    this._buf.fill(0);
                    this._finalized = false;
                    return this;
                }
                update(msg, inputEncoding) {
                    if (msg === null) {
                        throw new TypeError("msg must be a string or Uint8Array.");
                    }
                    else if (typeof msg === "string") {
                        msg = deps_ts_19.encode(msg, inputEncoding);
                    }
                    for (let i = 0, len = msg.length; i < len; i++) {
                        this._buf[this._bufIdx++] = msg[i];
                        if (this._bufIdx === 64) {
                            this._transform();
                            this._bufIdx = 0;
                        }
                    }
                    const c = this._count;
                    if ((c[0] += msg.length << 3) < msg.length << 3) {
                        c[1]++;
                    }
                    c[1] += msg.length >>> 29;
                    return this;
                }
                digest(outputEncoding) {
                    if (this._finalized) {
                        throw new Error("digest has already been called.");
                    }
                    this._finalized = true;
                    const b = this._buf;
                    let idx = this._bufIdx;
                    b[idx++] = 0x80;
                    while (idx !== 56) {
                        if (idx === 64) {
                            this._transform();
                            idx = 0;
                        }
                        b[idx++] = 0;
                    }
                    const c = this._count;
                    b[56] = (c[1] >>> 24) & 0xff;
                    b[57] = (c[1] >>> 16) & 0xff;
                    b[58] = (c[1] >>> 8) & 0xff;
                    b[59] = (c[1] >>> 0) & 0xff;
                    b[60] = (c[0] >>> 24) & 0xff;
                    b[61] = (c[0] >>> 16) & 0xff;
                    b[62] = (c[0] >>> 8) & 0xff;
                    b[63] = (c[0] >>> 0) & 0xff;
                    this._transform();
                    const hash = new Uint8Array(BYTES);
                    for (let i = 0; i < 8; i++) {
                        hash[(i << 2) + 0] = (this._H[i] >>> 24) & 0xff;
                        hash[(i << 2) + 1] = (this._H[i] >>> 16) & 0xff;
                        hash[(i << 2) + 2] = (this._H[i] >>> 8) & 0xff;
                        hash[(i << 2) + 3] = (this._H[i] >>> 0) & 0xff;
                    }
                    this.init();
                    return outputEncoding ? deps_ts_19.decode(hash, outputEncoding) : hash;
                }
                _transform() {
                    const h = this._H;
                    let h0 = h[0];
                    let h1 = h[1];
                    let h2 = h[2];
                    let h3 = h[3];
                    let h4 = h[4];
                    let h5 = h[5];
                    let h6 = h[6];
                    let h7 = h[7];
                    const w = new Uint32Array(16);
                    let i;
                    for (i = 0; i < 16; i++) {
                        w[i] =
                            this._buf[(i << 2) + 3] |
                                (this._buf[(i << 2) + 2] << 8) |
                                (this._buf[(i << 2) + 1] << 16) |
                                (this._buf[i << 2] << 24);
                    }
                    for (i = 0; i < 64; i++) {
                        let tmp;
                        if (i < 16) {
                            tmp = w[i];
                        }
                        else {
                            let a = w[(i + 1) & 15];
                            let b = w[(i + 14) & 15];
                            tmp = w[i & 15] =
                                (((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
                                    ((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
                                    w[i & 15] +
                                    w[(i + 9) & 15]) |
                                    0;
                        }
                        tmp =
                            (tmp +
                                h7 +
                                ((h4 >>> 6) ^
                                    (h4 >>> 11) ^
                                    (h4 >>> 25) ^
                                    (h4 << 26) ^
                                    (h4 << 21) ^
                                    (h4 << 7)) +
                                (h6 ^ (h4 & (h5 ^ h6))) +
                                this._K[i]) |
                                0;
                        h7 = h6;
                        h6 = h5;
                        h5 = h4;
                        h4 = h3 + tmp;
                        h3 = h2;
                        h2 = h1;
                        h1 = h0;
                        h0 =
                            (tmp +
                                ((h1 & h2) ^ (h3 & (h1 ^ h2))) +
                                ((h1 >>> 2) ^
                                    (h1 >>> 13) ^
                                    (h1 >>> 22) ^
                                    (h1 << 30) ^
                                    (h1 << 19) ^
                                    (h1 << 10))) |
                                0;
                    }
                    h[0] = (h[0] + h0) | 0;
                    h[1] = (h[1] + h1) | 0;
                    h[2] = (h[2] + h2) | 0;
                    h[3] = (h[3] + h3) | 0;
                    h[4] = (h[4] + h4) | 0;
                    h[5] = (h[5] + h5) | 0;
                    h[6] = (h[6] + h6) | 0;
                    h[7] = (h[7] + h7) | 0;
                }
            };
            exports_81("SHA256", SHA256);
        }
    };
});
System.register("https://deno.land/x/sql_builder@v1.6.0/util", [], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    function replaceParams(sql, params) {
        if (!params)
            return sql;
        let paramIndex = 0;
        sql = sql.replace(/('.*')|(".*")|(\?\?)|(\?)/g, (str) => {
            if (paramIndex >= params.length)
                return str;
            if (/".*"/g.test(str) || /'.*'/g.test(str)) {
                return str;
            }
            if (str === "??") {
                const val = params[paramIndex++];
                if (val instanceof Array) {
                    return `(${val.map((item) => replaceParams("??", [item])).join(",")})`;
                }
                else if (val === "*") {
                    return val;
                }
                else if (typeof val === "string" && val.indexOf(".") > -1) {
                    const _arr = val.split(".");
                    return replaceParams(_arr.map(() => "??").join("."), _arr);
                }
                else if (typeof val === "string" &&
                    (val.toLowerCase().indexOf(" as ") > -1 ||
                        val.toLowerCase().indexOf(" AS ") > -1)) {
                    const newVal = val.replace(" as ", " AS ");
                    const _arr = newVal.split(" AS ");
                    return replaceParams(_arr.map(() => "??").join(" AS "), _arr);
                }
                else {
                    return ["`", val, "`"].join("");
                }
            }
            const val = params[paramIndex++];
            if (val === null)
                return "NULL";
            switch (typeof val) {
                case "object":
                    if (val instanceof Date)
                        return `"${formatDate(val)}"`;
                    if (val instanceof Array) {
                        return `(${val.map((item) => replaceParams("?", [item])).join(",")})`;
                    }
                case "string":
                    return `"${escapeString(val)}"`;
                case "undefined":
                    return "NULL";
                case "number":
                case "boolean":
                default:
                    return val;
            }
        });
        return sql;
    }
    exports_82("replaceParams", replaceParams);
    function formatDate(date) {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const days = date
            .getDate()
            .toString()
            .padStart(2, "0");
        const hours = date
            .getHours()
            .toString()
            .padStart(2, "0");
        const minutes = date
            .getMinutes()
            .toString()
            .padStart(2, "0");
        const seconds = date
            .getSeconds()
            .toString()
            .padStart(2, "0");
        const milliseconds = date
            .getMilliseconds()
            .toString()
            .padStart(3, "0");
        return `${year}-${month}-${days} ${hours}:${minutes}:${seconds}.${milliseconds}`;
    }
    function escapeString(str) {
        return str.replace(/"/g, '\\"');
    }
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/log/levels", [], function (exports_83, context_83) {
    "use strict";
    var LogLevels, LogLevelNames, byLevel;
    var __moduleName = context_83 && context_83.id;
    function getLevelByName(name) {
        switch (name) {
            case "NOTSET":
                return LogLevels.NOTSET;
            case "DEBUG":
                return LogLevels.DEBUG;
            case "INFO":
                return LogLevels.INFO;
            case "WARNING":
                return LogLevels.WARNING;
            case "ERROR":
                return LogLevels.ERROR;
            case "CRITICAL":
                return LogLevels.CRITICAL;
            default:
                throw new Error(`no log level found for "${name}"`);
        }
    }
    exports_83("getLevelByName", getLevelByName);
    function getLevelName(level) {
        const levelName = byLevel[level];
        if (levelName) {
            return levelName;
        }
        throw new Error(`no level name found for level: ${level}`);
    }
    exports_83("getLevelName", getLevelName);
    return {
        setters: [],
        execute: function () {
            (function (LogLevels) {
                LogLevels[LogLevels["NOTSET"] = 0] = "NOTSET";
                LogLevels[LogLevels["DEBUG"] = 10] = "DEBUG";
                LogLevels[LogLevels["INFO"] = 20] = "INFO";
                LogLevels[LogLevels["WARNING"] = 30] = "WARNING";
                LogLevels[LogLevels["ERROR"] = 40] = "ERROR";
                LogLevels[LogLevels["CRITICAL"] = 50] = "CRITICAL";
            })(LogLevels || (LogLevels = {}));
            exports_83("LogLevels", LogLevels);
            exports_83("LogLevelNames", LogLevelNames = Object.keys(LogLevels).filter((key) => isNaN(Number(key))));
            byLevel = {
                [String(LogLevels.NOTSET)]: "NOTSET",
                [String(LogLevels.DEBUG)]: "DEBUG",
                [String(LogLevels.INFO)]: "INFO",
                [String(LogLevels.WARNING)]: "WARNING",
                [String(LogLevels.ERROR)]: "ERROR",
                [String(LogLevels.CRITICAL)]: "CRITICAL",
            };
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/fmt/colors", [], function (exports_84, context_84) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_84 && context_84.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_84("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_84("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_84("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_84("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_84("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_84("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_84("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_84("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_84("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_84("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_84("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_84("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_84("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_84("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_84("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_84("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_84("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_84("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_84("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_84("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_84("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_84("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_84("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_84("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_84("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_84("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_84("bgWhite", bgWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_84("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_84("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_84("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_84("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_84("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/fs/exists", [], function (exports_85, context_85) {
    "use strict";
    var __moduleName = context_85 && context_85.id;
    async function exists(filePath) {
        try {
            await Deno.lstat(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_85("exists", exists);
    function existsSync(filePath) {
        try {
            Deno.lstatSync(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_85("existsSync", existsSync);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/bytes/mod", [], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_86("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_86("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_86("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_86("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_86("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_86("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_86("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_86("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_86("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/_util/assert", [], function (exports_87, context_87) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_87 && context_87.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_87("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_87("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/io/bufio", ["https://deno.land/x/std@0.63.0/bytes/mod", "https://deno.land/x/std@0.63.0/_util/assert"], function (exports_88, context_88) {
    "use strict";
    var mod_ts_14, assert_ts_7, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_88 && context_88.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_88("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_88("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_88("readLines", readLines);
    return {
        setters: [
            function (mod_ts_14_1) {
                mod_ts_14 = mod_ts_14_1;
            },
            function (assert_ts_7_1) {
                assert_ts_7 = assert_ts_7_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_88("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_88("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_7.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_7.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_7.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_14.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_7.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_7.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_88("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_88("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_88("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/log/handlers", ["https://deno.land/x/std@0.63.0/log/levels", "https://deno.land/x/std@0.63.0/fmt/colors", "https://deno.land/x/std@0.63.0/fs/exists", "https://deno.land/x/std@0.63.0/io/bufio"], function (exports_89, context_89) {
    "use strict";
    var levels_ts_1, colors_ts_3, exists_ts_1, bufio_ts_5, DEFAULT_FORMATTER, BaseHandler, ConsoleHandler, WriterHandler, FileHandler, RotatingFileHandler;
    var __moduleName = context_89 && context_89.id;
    return {
        setters: [
            function (levels_ts_1_1) {
                levels_ts_1 = levels_ts_1_1;
            },
            function (colors_ts_3_1) {
                colors_ts_3 = colors_ts_3_1;
            },
            function (exists_ts_1_1) {
                exists_ts_1 = exists_ts_1_1;
            },
            function (bufio_ts_5_1) {
                bufio_ts_5 = bufio_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_FORMATTER = "{levelName} {msg}";
            BaseHandler = class BaseHandler {
                constructor(levelName, options = {}) {
                    this.level = levels_ts_1.getLevelByName(levelName);
                    this.levelName = levelName;
                    this.formatter = options.formatter || DEFAULT_FORMATTER;
                }
                handle(logRecord) {
                    if (this.level > logRecord.level)
                        return;
                    const msg = this.format(logRecord);
                    return this.log(msg);
                }
                format(logRecord) {
                    if (this.formatter instanceof Function) {
                        return this.formatter(logRecord);
                    }
                    return this.formatter.replace(/{(\S+)}/g, (match, p1) => {
                        const value = logRecord[p1];
                        if (value == null) {
                            return match;
                        }
                        return String(value);
                    });
                }
                log(_msg) { }
                async setup() { }
                async destroy() { }
            };
            exports_89("BaseHandler", BaseHandler);
            ConsoleHandler = class ConsoleHandler extends BaseHandler {
                format(logRecord) {
                    let msg = super.format(logRecord);
                    switch (logRecord.level) {
                        case levels_ts_1.LogLevels.INFO:
                            msg = colors_ts_3.blue(msg);
                            break;
                        case levels_ts_1.LogLevels.WARNING:
                            msg = colors_ts_3.yellow(msg);
                            break;
                        case levels_ts_1.LogLevels.ERROR:
                            msg = colors_ts_3.red(msg);
                            break;
                        case levels_ts_1.LogLevels.CRITICAL:
                            msg = colors_ts_3.bold(colors_ts_3.red(msg));
                            break;
                        default:
                            break;
                    }
                    return msg;
                }
                log(msg) {
                    console.log(msg);
                }
            };
            exports_89("ConsoleHandler", ConsoleHandler);
            WriterHandler = class WriterHandler extends BaseHandler {
                constructor() {
                    super(...arguments);
                    this.#encoder = new TextEncoder();
                }
                #encoder;
            };
            exports_89("WriterHandler", WriterHandler);
            FileHandler = class FileHandler extends WriterHandler {
                constructor(levelName, options) {
                    super(levelName, options);
                    this._encoder = new TextEncoder();
                    this.#unloadCallback = () => this.destroy();
                    this._filename = options.filename;
                    this._mode = options.mode ? options.mode : "a";
                    this._openOptions = {
                        createNew: this._mode === "x",
                        create: this._mode !== "x",
                        append: this._mode === "a",
                        truncate: this._mode !== "a",
                        write: true,
                    };
                }
                #unloadCallback;
                async setup() {
                    this._file = await Deno.open(this._filename, this._openOptions);
                    this._writer = this._file;
                    this._buf = new bufio_ts_5.BufWriterSync(this._file);
                    addEventListener("unload", this.#unloadCallback);
                }
                handle(logRecord) {
                    super.handle(logRecord);
                    if (logRecord.level > levels_ts_1.LogLevels.ERROR) {
                        this.flush();
                    }
                }
                log(msg) {
                    this._buf.writeSync(this._encoder.encode(msg + "\n"));
                }
                flush() {
                    if (this._buf?.buffered() > 0) {
                        this._buf.flush();
                    }
                }
                destroy() {
                    this.flush();
                    this._file?.close();
                    this._file = undefined;
                    removeEventListener("unload", this.#unloadCallback);
                    return Promise.resolve();
                }
            };
            exports_89("FileHandler", FileHandler);
            RotatingFileHandler = class RotatingFileHandler extends FileHandler {
                constructor(levelName, options) {
                    super(levelName, options);
                    this.#currentFileSize = 0;
                    this.#maxBytes = options.maxBytes;
                    this.#maxBackupCount = options.maxBackupCount;
                }
                #maxBytes;
                #maxBackupCount;
                #currentFileSize;
                async setup() {
                    if (this.#maxBytes < 1) {
                        this.destroy();
                        throw new Error("maxBytes cannot be less than 1");
                    }
                    if (this.#maxBackupCount < 1) {
                        this.destroy();
                        throw new Error("maxBackupCount cannot be less than 1");
                    }
                    await super.setup();
                    if (this._mode === "w") {
                        for (let i = 1; i <= this.#maxBackupCount; i++) {
                            if (await exists_ts_1.exists(this._filename + "." + i)) {
                                await Deno.remove(this._filename + "." + i);
                            }
                        }
                    }
                    else if (this._mode === "x") {
                        for (let i = 1; i <= this.#maxBackupCount; i++) {
                            if (await exists_ts_1.exists(this._filename + "." + i)) {
                                this.destroy();
                                throw new Deno.errors.AlreadyExists("Backup log file " + this._filename + "." + i + " already exists");
                            }
                        }
                    }
                    else {
                        this.#currentFileSize = (await Deno.stat(this._filename)).size;
                    }
                }
                log(msg) {
                    const msgByteLength = this._encoder.encode(msg).byteLength + 1;
                    if (this.#currentFileSize + msgByteLength > this.#maxBytes) {
                        this.rotateLogFiles();
                        this.#currentFileSize = 0;
                    }
                    this._buf.writeSync(this._encoder.encode(msg + "\n"));
                    this.#currentFileSize += msgByteLength;
                }
                rotateLogFiles() {
                    this._buf.flush();
                    Deno.close(this._file.rid);
                    for (let i = this.#maxBackupCount - 1; i >= 0; i--) {
                        const source = this._filename + (i === 0 ? "" : "." + i);
                        const dest = this._filename + "." + (i + 1);
                        if (exists_ts_1.existsSync(source)) {
                            Deno.renameSync(source, dest);
                        }
                    }
                    this._file = Deno.openSync(this._filename, this._openOptions);
                    this._writer = this._file;
                    this._buf = new bufio_ts_5.BufWriterSync(this._file);
                }
            };
            exports_89("RotatingFileHandler", RotatingFileHandler);
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/log/logger", ["https://deno.land/x/std@0.63.0/log/levels"], function (exports_90, context_90) {
    "use strict";
    var levels_ts_2, LogRecord, Logger;
    var __moduleName = context_90 && context_90.id;
    return {
        setters: [
            function (levels_ts_2_1) {
                levels_ts_2 = levels_ts_2_1;
            }
        ],
        execute: function () {
            LogRecord = class LogRecord {
                constructor(options) {
                    this.msg = options.msg;
                    this.#args = [...options.args];
                    this.level = options.level;
                    this.loggerName = options.loggerName;
                    this.#datetime = new Date();
                    this.levelName = levels_ts_2.getLevelName(options.level);
                }
                #args;
                #datetime;
                get args() {
                    return [...this.#args];
                }
                get datetime() {
                    return new Date(this.#datetime.getTime());
                }
            };
            exports_90("LogRecord", LogRecord);
            Logger = class Logger {
                constructor(loggerName, levelName, options = {}) {
                    this.#loggerName = loggerName;
                    this.#level = levels_ts_2.getLevelByName(levelName);
                    this.#handlers = options.handlers || [];
                }
                #level;
                #handlers;
                #loggerName;
                get level() {
                    return this.#level;
                }
                set level(level) {
                    this.#level = level;
                }
                get levelName() {
                    return levels_ts_2.getLevelName(this.#level);
                }
                set levelName(levelName) {
                    this.#level = levels_ts_2.getLevelByName(levelName);
                }
                get loggerName() {
                    return this.#loggerName;
                }
                set handlers(hndls) {
                    this.#handlers = hndls;
                }
                get handlers() {
                    return this.#handlers;
                }
                _log(level, msg, ...args) {
                    if (this.level > level) {
                        return msg instanceof Function ? undefined : msg;
                    }
                    let fnResult;
                    let logMessage;
                    if (msg instanceof Function) {
                        fnResult = msg();
                        logMessage = this.asString(fnResult);
                    }
                    else {
                        logMessage = this.asString(msg);
                    }
                    const record = new LogRecord({
                        msg: logMessage,
                        args: args,
                        level: level,
                        loggerName: this.loggerName,
                    });
                    this.#handlers.forEach((handler) => {
                        handler.handle(record);
                    });
                    return msg instanceof Function ? fnResult : msg;
                }
                asString(data) {
                    if (typeof data === "string") {
                        return data;
                    }
                    else if (data === null ||
                        typeof data === "number" ||
                        typeof data === "bigint" ||
                        typeof data === "boolean" ||
                        typeof data === "undefined" ||
                        typeof data === "symbol") {
                        return String(data);
                    }
                    else if (typeof data === "object") {
                        return JSON.stringify(data);
                    }
                    return "undefined";
                }
                debug(msg, ...args) {
                    return this._log(levels_ts_2.LogLevels.DEBUG, msg, ...args);
                }
                info(msg, ...args) {
                    return this._log(levels_ts_2.LogLevels.INFO, msg, ...args);
                }
                warning(msg, ...args) {
                    return this._log(levels_ts_2.LogLevels.WARNING, msg, ...args);
                }
                error(msg, ...args) {
                    return this._log(levels_ts_2.LogLevels.ERROR, msg, ...args);
                }
                critical(msg, ...args) {
                    return this._log(levels_ts_2.LogLevels.CRITICAL, msg, ...args);
                }
            };
            exports_90("Logger", Logger);
        }
    };
});
System.register("https://deno.land/x/std@0.63.0/log/mod", ["https://deno.land/x/std@0.63.0/log/logger", "https://deno.land/x/std@0.63.0/log/handlers", "https://deno.land/x/std@0.63.0/_util/assert", "https://deno.land/x/std@0.63.0/log/levels"], function (exports_91, context_91) {
    "use strict";
    var logger_ts_1, handlers_ts_1, assert_ts_8, LoggerConfig, DEFAULT_LEVEL, DEFAULT_CONFIG, state, handlers;
    var __moduleName = context_91 && context_91.id;
    function getLogger(name) {
        if (!name) {
            const d = state.loggers.get("default");
            assert_ts_8.assert(d != null, `"default" logger must be set for getting logger without name`);
            return d;
        }
        const result = state.loggers.get(name);
        if (!result) {
            const logger = new logger_ts_1.Logger(name, "NOTSET", { handlers: [] });
            state.loggers.set(name, logger);
            return logger;
        }
        return result;
    }
    exports_91("getLogger", getLogger);
    function debug(msg, ...args) {
        if (msg instanceof Function) {
            return getLogger("default").debug(msg, ...args);
        }
        return getLogger("default").debug(msg, ...args);
    }
    exports_91("debug", debug);
    function info(msg, ...args) {
        if (msg instanceof Function) {
            return getLogger("default").info(msg, ...args);
        }
        return getLogger("default").info(msg, ...args);
    }
    exports_91("info", info);
    function warning(msg, ...args) {
        if (msg instanceof Function) {
            return getLogger("default").warning(msg, ...args);
        }
        return getLogger("default").warning(msg, ...args);
    }
    exports_91("warning", warning);
    function error(msg, ...args) {
        if (msg instanceof Function) {
            return getLogger("default").error(msg, ...args);
        }
        return getLogger("default").error(msg, ...args);
    }
    exports_91("error", error);
    function critical(msg, ...args) {
        if (msg instanceof Function) {
            return getLogger("default").critical(msg, ...args);
        }
        return getLogger("default").critical(msg, ...args);
    }
    exports_91("critical", critical);
    async function setup(config) {
        state.config = {
            handlers: { ...DEFAULT_CONFIG.handlers, ...config.handlers },
            loggers: { ...DEFAULT_CONFIG.loggers, ...config.loggers },
        };
        state.handlers.forEach((handler) => {
            handler.destroy();
        });
        state.handlers.clear();
        const handlers = state.config.handlers || {};
        for (const handlerName in handlers) {
            const handler = handlers[handlerName];
            await handler.setup();
            state.handlers.set(handlerName, handler);
        }
        state.loggers.clear();
        const loggers = state.config.loggers || {};
        for (const loggerName in loggers) {
            const loggerConfig = loggers[loggerName];
            const handlerNames = loggerConfig.handlers || [];
            const handlers = [];
            handlerNames.forEach((handlerName) => {
                const handler = state.handlers.get(handlerName);
                if (handler) {
                    handlers.push(handler);
                }
            });
            const levelName = loggerConfig.level || DEFAULT_LEVEL;
            const logger = new logger_ts_1.Logger(loggerName, levelName, { handlers: handlers });
            state.loggers.set(loggerName, logger);
        }
    }
    exports_91("setup", setup);
    return {
        setters: [
            function (logger_ts_1_1) {
                logger_ts_1 = logger_ts_1_1;
                exports_91({
                    "Logger": logger_ts_1_1["Logger"]
                });
            },
            function (handlers_ts_1_1) {
                handlers_ts_1 = handlers_ts_1_1;
            },
            function (assert_ts_8_1) {
                assert_ts_8 = assert_ts_8_1;
            },
            function (levels_ts_3_1) {
                exports_91({
                    "LogLevels": levels_ts_3_1["LogLevels"]
                });
            }
        ],
        execute: async function () {
            LoggerConfig = class LoggerConfig {
            };
            exports_91("LoggerConfig", LoggerConfig);
            DEFAULT_LEVEL = "INFO";
            DEFAULT_CONFIG = {
                handlers: {
                    default: new handlers_ts_1.ConsoleHandler(DEFAULT_LEVEL),
                },
                loggers: {
                    default: {
                        level: DEFAULT_LEVEL,
                        handlers: ["default"],
                    },
                },
            };
            state = {
                handlers: new Map(),
                loggers: new Map(),
                config: DEFAULT_CONFIG,
            };
            exports_91("handlers", handlers = {
                BaseHandler: handlers_ts_1.BaseHandler,
                ConsoleHandler: handlers_ts_1.ConsoleHandler,
                WriterHandler: handlers_ts_1.WriterHandler,
                FileHandler: handlers_ts_1.FileHandler,
                RotatingFileHandler: handlers_ts_1.RotatingFileHandler,
            });
            await setup(DEFAULT_CONFIG);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/deps", ["https://deno.land/std@0.63.0/async/mod", "https://deno.land/std@0.63.0/encoding/utf8", "https://deno.land/x/bytes_formater@v1.3.0/mod", "https://deno.land/x/checksum@1.4.0/mod", "https://deno.land/x/sha256@v1.0.2/mod", "https://deno.land/x/sql_builder@v1.6.0/util", "https://deno.land/x/std@0.63.0/log/mod"], function (exports_92, context_92) {
    "use strict";
    var __moduleName = context_92 && context_92.id;
    return {
        setters: [
            function (mod_ts_15_1) {
                exports_92({
                    "deferred": mod_ts_15_1["deferred"],
                    "delay": mod_ts_15_1["delay"]
                });
            },
            function (utf8_ts_5_1) {
                exports_92({
                    "decode": utf8_ts_5_1["decode"],
                    "encode": utf8_ts_5_1["encode"]
                });
            },
            function (mod_ts_16_1) {
                exports_92({
                    "byteFormat": mod_ts_16_1["format"]
                });
            },
            function (mod_ts_17_1) {
                exports_92({
                    "Hash": mod_ts_17_1["Hash"]
                });
            },
            function (mod_ts_18_1) {
                exports_92({
                    "sha256": mod_ts_18_1["sha256"]
                });
            },
            function (util_ts_7_1) {
                exports_92({
                    "replaceParams": util_ts_7_1["replaceParams"]
                });
            },
            function (log_1) {
                exports_92("log", log_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/constant/errors", [], function (exports_93, context_93) {
    "use strict";
    var WriteError, ResponseTimeoutError;
    var __moduleName = context_93 && context_93.id;
    return {
        setters: [],
        execute: function () {
            WriteError = class WriteError extends Error {
                constructor(msg) {
                    super(msg);
                }
            };
            exports_93("WriteError", WriteError);
            ResponseTimeoutError = class ResponseTimeoutError extends Error {
                constructor(msg) {
                    super(msg);
                }
            };
            exports_93("ResponseTimeoutError", ResponseTimeoutError);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/logger", ["https://deno.land/x/mysql@v2.4.0/deps"], function (exports_94, context_94) {
    "use strict";
    var deps_ts_20, isDebug;
    var __moduleName = context_94 && context_94.id;
    function debug(func) {
        if (isDebug) {
            func();
        }
    }
    exports_94("debug", debug);
    async function config(config) {
        isDebug = config.debug;
        await deps_ts_20.log.setup({
            handlers: {
                console: new deps_ts_20.log.handlers.ConsoleHandler(config.debug ? "DEBUG" : "INFO"),
                file: new deps_ts_20.log.handlers.FileHandler("WARNING", {
                    filename: config.logFile,
                    formatter: "{levelName} {msg}",
                }),
            },
            loggers: {
                default: {
                    level: "DEBUG",
                    handlers: ["console", "file"],
                },
            },
        });
    }
    exports_94("config", config);
    return {
        setters: [
            function (deps_ts_20_1) {
                deps_ts_20 = deps_ts_20_1;
            }
        ],
        execute: function () {
            exports_94("log", deps_ts_20.log);
            isDebug = false;
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/auth", ["https://deno.land/x/mysql@v2.4.0/deps"], function (exports_95, context_95) {
    "use strict";
    var deps_ts_21;
    var __moduleName = context_95 && context_95.id;
    function xor(a, b) {
        return a.map((byte, index) => {
            return byte ^ b[index];
        });
    }
    function mysqlNativePassword(password, seed) {
        const hash = new deps_ts_21.Hash("sha1");
        const pwd1 = hash.digest(deps_ts_21.encode(password)).data;
        const pwd2 = hash.digest(pwd1).data;
        let seedAndPwd2 = new Uint8Array(seed.length + pwd2.length);
        seedAndPwd2.set(seed);
        seedAndPwd2.set(pwd2, seed.length);
        seedAndPwd2 = hash.digest(seedAndPwd2).data;
        return xor(seedAndPwd2, pwd1);
    }
    function cachingSha2Password(password, seed) {
        const stage1 = deps_ts_21.sha256(password, "utf8");
        const stage2 = deps_ts_21.sha256(stage1);
        const stage3 = deps_ts_21.sha256(Uint8Array.from([...stage2, ...seed]));
        return xor(stage1, stage3);
    }
    function auth(authPluginName, password, seed) {
        switch (authPluginName) {
            case "mysql_native_password":
                return mysqlNativePassword(password, seed);
            case "caching_sha2_password":
            default:
                throw new Error("Not supported");
        }
    }
    exports_95("default", auth);
    return {
        setters: [
            function (deps_ts_21_1) {
                deps_ts_21 = deps_ts_21_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/buffer", ["https://deno.land/x/mysql@v2.4.0/deps"], function (exports_96, context_96) {
    "use strict";
    var deps_ts_22, BufferReader, BufferWriter;
    var __moduleName = context_96 && context_96.id;
    return {
        setters: [
            function (deps_ts_22_1) {
                deps_ts_22 = deps_ts_22_1;
            }
        ],
        execute: function () {
            BufferReader = class BufferReader {
                constructor(buffer) {
                    this.buffer = buffer;
                    this.pos = 0;
                }
                get finished() {
                    return this.pos >= this.buffer.length;
                }
                skip(len) {
                    this.pos += len;
                    return this;
                }
                readBuffer(len) {
                    const buffer = this.buffer.slice(this.pos, this.pos + len);
                    this.pos += len;
                    return buffer;
                }
                readUints(len) {
                    let num = 0;
                    for (let n = 0; n < len; n++) {
                        num += this.buffer[this.pos++] << (8 * n);
                    }
                    return num;
                }
                readUint8() {
                    return this.buffer[this.pos++];
                }
                readUint16() {
                    return this.readUints(2);
                }
                readUint32() {
                    return this.readUints(4);
                }
                readUint64() {
                    return this.readUints(8);
                }
                readNullTerminatedString() {
                    let end = this.buffer.indexOf(0x00, this.pos);
                    if (end === -1)
                        end = this.buffer.length;
                    const buf = this.buffer.slice(this.pos, end);
                    this.pos += buf.length + 1;
                    return deps_ts_22.decode(buf);
                }
                readString(len) {
                    const str = deps_ts_22.decode(this.buffer.slice(this.pos, this.pos + len));
                    this.pos += len;
                    return str;
                }
                readEncodedLen() {
                    const first = this.readUint8();
                    if (first < 251) {
                        return first;
                    }
                    else {
                        if (first == 0xfc) {
                            return this.readUint16();
                        }
                        else if (first == 0xfd) {
                            return this.readUints(3);
                        }
                        else if (first == 0xfe) {
                            return this.readUints(8);
                        }
                    }
                    return -1;
                }
                readLenCodeString() {
                    const len = this.readEncodedLen();
                    if (len == -1)
                        return null;
                    return this.readString(len);
                }
            };
            exports_96("BufferReader", BufferReader);
            BufferWriter = class BufferWriter {
                constructor(buffer) {
                    this.buffer = buffer;
                    this.pos = 0;
                }
                get wroteData() {
                    return this.buffer.slice(0, this.pos);
                }
                get length() {
                    return this.pos;
                }
                get capacity() {
                    return this.buffer.length - this.pos;
                }
                skip(len) {
                    this.pos += len;
                    return this;
                }
                writeBuffer(buffer) {
                    if (buffer.length > this.capacity) {
                        buffer = buffer.slice(0, this.capacity);
                    }
                    this.buffer.set(buffer, this.pos);
                    this.pos += buffer.length;
                    return this;
                }
                write(byte) {
                    this.buffer[this.pos++] = byte;
                    return this;
                }
                writeInt16LE(num) { }
                writeIntLE(num, len) {
                    const int = new Int32Array(1);
                    int[0] = 40;
                    console.log(int);
                }
                writeUint16(num) {
                    return this.writeUints(2, num);
                }
                writeUint32(num) {
                    return this.writeUints(4, num);
                }
                writeUint64(num) {
                    return this.writeUints(8, num);
                }
                writeUints(len, num) {
                    for (let n = 0; n < len; n++) {
                        this.buffer[this.pos++] = (num >> (n * 8)) & 0xff;
                    }
                    return this;
                }
                writeNullTerminatedString(str) {
                    return this.writeString(str).write(0x00);
                }
                writeString(str) {
                    const buf = deps_ts_22.encode(str);
                    this.buffer.set(buf, this.pos);
                    this.pos += buf.length;
                    return this;
                }
            };
            exports_96("BufferWriter", BufferWriter);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/constant/capabilities", [], function (exports_97, context_97) {
    "use strict";
    var ServerCapabilities;
    var __moduleName = context_97 && context_97.id;
    return {
        setters: [],
        execute: function () {
            (function (ServerCapabilities) {
                ServerCapabilities[ServerCapabilities["CLIENT_PROTOCOL_41"] = 512] = "CLIENT_PROTOCOL_41";
                ServerCapabilities[ServerCapabilities["CLIENT_CONNECT_WITH_DB"] = 8] = "CLIENT_CONNECT_WITH_DB";
                ServerCapabilities[ServerCapabilities["CLIENT_LONG_FLAG"] = 4] = "CLIENT_LONG_FLAG";
                ServerCapabilities[ServerCapabilities["CLIENT_DEPRECATE_EOF"] = 16777216] = "CLIENT_DEPRECATE_EOF";
                ServerCapabilities[ServerCapabilities["CLIENT_LONG_PASSWORD"] = 1] = "CLIENT_LONG_PASSWORD";
                ServerCapabilities[ServerCapabilities["CLIENT_TRANSACTIONS"] = 8192] = "CLIENT_TRANSACTIONS";
                ServerCapabilities[ServerCapabilities["CLIENT_MULTI_RESULTS"] = 131072] = "CLIENT_MULTI_RESULTS";
                ServerCapabilities[ServerCapabilities["CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA"] = 2097152] = "CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA";
                ServerCapabilities[ServerCapabilities["CLIENT_PLUGIN_AUTH"] = 524288] = "CLIENT_PLUGIN_AUTH";
                ServerCapabilities[ServerCapabilities["CLIENT_SECURE_CONNECTION"] = 32768] = "CLIENT_SECURE_CONNECTION";
                ServerCapabilities[ServerCapabilities["CLIENT_FOUND_ROWS"] = 2] = "CLIENT_FOUND_ROWS";
                ServerCapabilities[ServerCapabilities["CLIENT_CONNECT_ATTRS"] = 1048576] = "CLIENT_CONNECT_ATTRS";
            })(ServerCapabilities || (ServerCapabilities = {}));
            exports_97("default", ServerCapabilities);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/constant/charset", [], function (exports_98, context_98) {
    "use strict";
    var Charset;
    var __moduleName = context_98 && context_98.id;
    return {
        setters: [],
        execute: function () {
            (function (Charset) {
                Charset[Charset["BIG5_CHINESE_CI"] = 1] = "BIG5_CHINESE_CI";
                Charset[Charset["LATIN2_CZECH_CS"] = 2] = "LATIN2_CZECH_CS";
                Charset[Charset["DEC8_SWEDISH_CI"] = 3] = "DEC8_SWEDISH_CI";
                Charset[Charset["CP850_GENERAL_CI"] = 4] = "CP850_GENERAL_CI";
                Charset[Charset["LATIN1_GERMAN1_CI"] = 5] = "LATIN1_GERMAN1_CI";
                Charset[Charset["HP8_ENGLISH_CI"] = 6] = "HP8_ENGLISH_CI";
                Charset[Charset["KOI8R_GENERAL_CI"] = 7] = "KOI8R_GENERAL_CI";
                Charset[Charset["LATIN1_SWEDISH_CI"] = 8] = "LATIN1_SWEDISH_CI";
                Charset[Charset["LATIN2_GENERAL_CI"] = 9] = "LATIN2_GENERAL_CI";
                Charset[Charset["SWE7_SWEDISH_CI"] = 10] = "SWE7_SWEDISH_CI";
                Charset[Charset["ASCII_GENERAL_CI"] = 11] = "ASCII_GENERAL_CI";
                Charset[Charset["UJIS_JAPANESE_CI"] = 12] = "UJIS_JAPANESE_CI";
                Charset[Charset["SJIS_JAPANESE_CI"] = 13] = "SJIS_JAPANESE_CI";
                Charset[Charset["CP1251_BULGARIAN_CI"] = 14] = "CP1251_BULGARIAN_CI";
                Charset[Charset["LATIN1_DANISH_CI"] = 15] = "LATIN1_DANISH_CI";
                Charset[Charset["HEBREW_GENERAL_CI"] = 16] = "HEBREW_GENERAL_CI";
                Charset[Charset["TIS620_THAI_CI"] = 18] = "TIS620_THAI_CI";
                Charset[Charset["EUCKR_KOREAN_CI"] = 19] = "EUCKR_KOREAN_CI";
                Charset[Charset["LATIN7_ESTONIAN_CS"] = 20] = "LATIN7_ESTONIAN_CS";
                Charset[Charset["LATIN2_HUNGARIAN_CI"] = 21] = "LATIN2_HUNGARIAN_CI";
                Charset[Charset["KOI8U_GENERAL_CI"] = 22] = "KOI8U_GENERAL_CI";
                Charset[Charset["CP1251_UKRAINIAN_CI"] = 23] = "CP1251_UKRAINIAN_CI";
                Charset[Charset["GB2312_CHINESE_CI"] = 24] = "GB2312_CHINESE_CI";
                Charset[Charset["GREEK_GENERAL_CI"] = 25] = "GREEK_GENERAL_CI";
                Charset[Charset["CP1250_GENERAL_CI"] = 26] = "CP1250_GENERAL_CI";
                Charset[Charset["LATIN2_CROATIAN_CI"] = 27] = "LATIN2_CROATIAN_CI";
                Charset[Charset["GBK_CHINESE_CI"] = 28] = "GBK_CHINESE_CI";
                Charset[Charset["CP1257_LITHUANIAN_CI"] = 29] = "CP1257_LITHUANIAN_CI";
                Charset[Charset["LATIN5_TURKISH_CI"] = 30] = "LATIN5_TURKISH_CI";
                Charset[Charset["LATIN1_GERMAN2_CI"] = 31] = "LATIN1_GERMAN2_CI";
                Charset[Charset["ARMSCII8_GENERAL_CI"] = 32] = "ARMSCII8_GENERAL_CI";
                Charset[Charset["UTF8_GENERAL_CI"] = 33] = "UTF8_GENERAL_CI";
                Charset[Charset["CP1250_CZECH_CS"] = 34] = "CP1250_CZECH_CS";
                Charset[Charset["UCS2_GENERAL_CI"] = 35] = "UCS2_GENERAL_CI";
                Charset[Charset["CP866_GENERAL_CI"] = 36] = "CP866_GENERAL_CI";
                Charset[Charset["KEYBCS2_GENERAL_CI"] = 37] = "KEYBCS2_GENERAL_CI";
                Charset[Charset["MACCE_GENERAL_CI"] = 38] = "MACCE_GENERAL_CI";
                Charset[Charset["MACROMAN_GENERAL_CI"] = 39] = "MACROMAN_GENERAL_CI";
                Charset[Charset["CP852_GENERAL_CI"] = 40] = "CP852_GENERAL_CI";
                Charset[Charset["LATIN7_GENERAL_CI"] = 41] = "LATIN7_GENERAL_CI";
                Charset[Charset["LATIN7_GENERAL_CS"] = 42] = "LATIN7_GENERAL_CS";
                Charset[Charset["MACCE_BIN"] = 43] = "MACCE_BIN";
                Charset[Charset["CP1250_CROATIAN_CI"] = 44] = "CP1250_CROATIAN_CI";
                Charset[Charset["UTF8MB4_GENERAL_CI"] = 45] = "UTF8MB4_GENERAL_CI";
                Charset[Charset["UTF8MB4_BIN"] = 46] = "UTF8MB4_BIN";
                Charset[Charset["LATIN1_BIN"] = 47] = "LATIN1_BIN";
                Charset[Charset["LATIN1_GENERAL_CI"] = 48] = "LATIN1_GENERAL_CI";
                Charset[Charset["LATIN1_GENERAL_CS"] = 49] = "LATIN1_GENERAL_CS";
                Charset[Charset["CP1251_BIN"] = 50] = "CP1251_BIN";
                Charset[Charset["CP1251_GENERAL_CI"] = 51] = "CP1251_GENERAL_CI";
                Charset[Charset["CP1251_GENERAL_CS"] = 52] = "CP1251_GENERAL_CS";
                Charset[Charset["MACROMAN_BIN"] = 53] = "MACROMAN_BIN";
                Charset[Charset["UTF16_GENERAL_CI"] = 54] = "UTF16_GENERAL_CI";
                Charset[Charset["UTF16_BIN"] = 55] = "UTF16_BIN";
                Charset[Charset["UTF16LE_GENERAL_CI"] = 56] = "UTF16LE_GENERAL_CI";
                Charset[Charset["CP1256_GENERAL_CI"] = 57] = "CP1256_GENERAL_CI";
                Charset[Charset["CP1257_BIN"] = 58] = "CP1257_BIN";
                Charset[Charset["CP1257_GENERAL_CI"] = 59] = "CP1257_GENERAL_CI";
                Charset[Charset["UTF32_GENERAL_CI"] = 60] = "UTF32_GENERAL_CI";
                Charset[Charset["UTF32_BIN"] = 61] = "UTF32_BIN";
                Charset[Charset["UTF16LE_BIN"] = 62] = "UTF16LE_BIN";
                Charset[Charset["BINARY"] = 63] = "BINARY";
                Charset[Charset["ARMSCII8_BIN"] = 64] = "ARMSCII8_BIN";
                Charset[Charset["ASCII_BIN"] = 65] = "ASCII_BIN";
                Charset[Charset["CP1250_BIN"] = 66] = "CP1250_BIN";
                Charset[Charset["CP1256_BIN"] = 67] = "CP1256_BIN";
                Charset[Charset["CP866_BIN"] = 68] = "CP866_BIN";
                Charset[Charset["DEC8_BIN"] = 69] = "DEC8_BIN";
                Charset[Charset["GREEK_BIN"] = 70] = "GREEK_BIN";
                Charset[Charset["HEBREW_BIN"] = 71] = "HEBREW_BIN";
                Charset[Charset["HP8_BIN"] = 72] = "HP8_BIN";
                Charset[Charset["KEYBCS2_BIN"] = 73] = "KEYBCS2_BIN";
                Charset[Charset["KOI8R_BIN"] = 74] = "KOI8R_BIN";
                Charset[Charset["KOI8U_BIN"] = 75] = "KOI8U_BIN";
                Charset[Charset["LATIN2_BIN"] = 77] = "LATIN2_BIN";
                Charset[Charset["LATIN5_BIN"] = 78] = "LATIN5_BIN";
                Charset[Charset["LATIN7_BIN"] = 79] = "LATIN7_BIN";
                Charset[Charset["CP850_BIN"] = 80] = "CP850_BIN";
                Charset[Charset["CP852_BIN"] = 81] = "CP852_BIN";
                Charset[Charset["SWE7_BIN"] = 82] = "SWE7_BIN";
                Charset[Charset["UTF8_BIN"] = 83] = "UTF8_BIN";
                Charset[Charset["BIG5_BIN"] = 84] = "BIG5_BIN";
                Charset[Charset["EUCKR_BIN"] = 85] = "EUCKR_BIN";
                Charset[Charset["GB2312_BIN"] = 86] = "GB2312_BIN";
                Charset[Charset["GBK_BIN"] = 87] = "GBK_BIN";
                Charset[Charset["SJIS_BIN"] = 88] = "SJIS_BIN";
                Charset[Charset["TIS620_BIN"] = 89] = "TIS620_BIN";
                Charset[Charset["UCS2_BIN"] = 90] = "UCS2_BIN";
                Charset[Charset["UJIS_BIN"] = 91] = "UJIS_BIN";
                Charset[Charset["GEOSTD8_GENERAL_CI"] = 92] = "GEOSTD8_GENERAL_CI";
                Charset[Charset["GEOSTD8_BIN"] = 93] = "GEOSTD8_BIN";
                Charset[Charset["LATIN1_SPANISH_CI"] = 94] = "LATIN1_SPANISH_CI";
                Charset[Charset["CP932_JAPANESE_CI"] = 95] = "CP932_JAPANESE_CI";
                Charset[Charset["CP932_BIN"] = 96] = "CP932_BIN";
                Charset[Charset["EUCJPMS_JAPANESE_CI"] = 97] = "EUCJPMS_JAPANESE_CI";
                Charset[Charset["EUCJPMS_BIN"] = 98] = "EUCJPMS_BIN";
                Charset[Charset["CP1250_POLISH_CI"] = 99] = "CP1250_POLISH_CI";
                Charset[Charset["UTF16_UNICODE_CI"] = 101] = "UTF16_UNICODE_CI";
                Charset[Charset["UTF16_ICELANDIC_CI"] = 102] = "UTF16_ICELANDIC_CI";
                Charset[Charset["UTF16_LATVIAN_CI"] = 103] = "UTF16_LATVIAN_CI";
                Charset[Charset["UTF16_ROMANIAN_CI"] = 104] = "UTF16_ROMANIAN_CI";
                Charset[Charset["UTF16_SLOVENIAN_CI"] = 105] = "UTF16_SLOVENIAN_CI";
                Charset[Charset["UTF16_POLISH_CI"] = 106] = "UTF16_POLISH_CI";
                Charset[Charset["UTF16_ESTONIAN_CI"] = 107] = "UTF16_ESTONIAN_CI";
                Charset[Charset["UTF16_SPANISH_CI"] = 108] = "UTF16_SPANISH_CI";
                Charset[Charset["UTF16_SWEDISH_CI"] = 109] = "UTF16_SWEDISH_CI";
                Charset[Charset["UTF16_TURKISH_CI"] = 110] = "UTF16_TURKISH_CI";
                Charset[Charset["UTF16_CZECH_CI"] = 111] = "UTF16_CZECH_CI";
                Charset[Charset["UTF16_DANISH_CI"] = 112] = "UTF16_DANISH_CI";
                Charset[Charset["UTF16_LITHUANIAN_CI"] = 113] = "UTF16_LITHUANIAN_CI";
                Charset[Charset["UTF16_SLOVAK_CI"] = 114] = "UTF16_SLOVAK_CI";
                Charset[Charset["UTF16_SPANISH2_CI"] = 115] = "UTF16_SPANISH2_CI";
                Charset[Charset["UTF16_ROMAN_CI"] = 116] = "UTF16_ROMAN_CI";
                Charset[Charset["UTF16_PERSIAN_CI"] = 117] = "UTF16_PERSIAN_CI";
                Charset[Charset["UTF16_ESPERANTO_CI"] = 118] = "UTF16_ESPERANTO_CI";
                Charset[Charset["UTF16_HUNGARIAN_CI"] = 119] = "UTF16_HUNGARIAN_CI";
                Charset[Charset["UTF16_SINHALA_CI"] = 120] = "UTF16_SINHALA_CI";
                Charset[Charset["UTF16_GERMAN2_CI"] = 121] = "UTF16_GERMAN2_CI";
                Charset[Charset["UTF16_CROATIAN_MYSQL561_CI"] = 122] = "UTF16_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF16_UNICODE_520_CI"] = 123] = "UTF16_UNICODE_520_CI";
                Charset[Charset["UTF16_VIETNAMESE_CI"] = 124] = "UTF16_VIETNAMESE_CI";
                Charset[Charset["UCS2_UNICODE_CI"] = 128] = "UCS2_UNICODE_CI";
                Charset[Charset["UCS2_ICELANDIC_CI"] = 129] = "UCS2_ICELANDIC_CI";
                Charset[Charset["UCS2_LATVIAN_CI"] = 130] = "UCS2_LATVIAN_CI";
                Charset[Charset["UCS2_ROMANIAN_CI"] = 131] = "UCS2_ROMANIAN_CI";
                Charset[Charset["UCS2_SLOVENIAN_CI"] = 132] = "UCS2_SLOVENIAN_CI";
                Charset[Charset["UCS2_POLISH_CI"] = 133] = "UCS2_POLISH_CI";
                Charset[Charset["UCS2_ESTONIAN_CI"] = 134] = "UCS2_ESTONIAN_CI";
                Charset[Charset["UCS2_SPANISH_CI"] = 135] = "UCS2_SPANISH_CI";
                Charset[Charset["UCS2_SWEDISH_CI"] = 136] = "UCS2_SWEDISH_CI";
                Charset[Charset["UCS2_TURKISH_CI"] = 137] = "UCS2_TURKISH_CI";
                Charset[Charset["UCS2_CZECH_CI"] = 138] = "UCS2_CZECH_CI";
                Charset[Charset["UCS2_DANISH_CI"] = 139] = "UCS2_DANISH_CI";
                Charset[Charset["UCS2_LITHUANIAN_CI"] = 140] = "UCS2_LITHUANIAN_CI";
                Charset[Charset["UCS2_SLOVAK_CI"] = 141] = "UCS2_SLOVAK_CI";
                Charset[Charset["UCS2_SPANISH2_CI"] = 142] = "UCS2_SPANISH2_CI";
                Charset[Charset["UCS2_ROMAN_CI"] = 143] = "UCS2_ROMAN_CI";
                Charset[Charset["UCS2_PERSIAN_CI"] = 144] = "UCS2_PERSIAN_CI";
                Charset[Charset["UCS2_ESPERANTO_CI"] = 145] = "UCS2_ESPERANTO_CI";
                Charset[Charset["UCS2_HUNGARIAN_CI"] = 146] = "UCS2_HUNGARIAN_CI";
                Charset[Charset["UCS2_SINHALA_CI"] = 147] = "UCS2_SINHALA_CI";
                Charset[Charset["UCS2_GERMAN2_CI"] = 148] = "UCS2_GERMAN2_CI";
                Charset[Charset["UCS2_CROATIAN_MYSQL561_CI"] = 149] = "UCS2_CROATIAN_MYSQL561_CI";
                Charset[Charset["UCS2_UNICODE_520_CI"] = 150] = "UCS2_UNICODE_520_CI";
                Charset[Charset["UCS2_VIETNAMESE_CI"] = 151] = "UCS2_VIETNAMESE_CI";
                Charset[Charset["UCS2_GENERAL_MYSQL500_CI"] = 159] = "UCS2_GENERAL_MYSQL500_CI";
                Charset[Charset["UTF32_UNICODE_CI"] = 160] = "UTF32_UNICODE_CI";
                Charset[Charset["UTF32_ICELANDIC_CI"] = 161] = "UTF32_ICELANDIC_CI";
                Charset[Charset["UTF32_LATVIAN_CI"] = 162] = "UTF32_LATVIAN_CI";
                Charset[Charset["UTF32_ROMANIAN_CI"] = 163] = "UTF32_ROMANIAN_CI";
                Charset[Charset["UTF32_SLOVENIAN_CI"] = 164] = "UTF32_SLOVENIAN_CI";
                Charset[Charset["UTF32_POLISH_CI"] = 165] = "UTF32_POLISH_CI";
                Charset[Charset["UTF32_ESTONIAN_CI"] = 166] = "UTF32_ESTONIAN_CI";
                Charset[Charset["UTF32_SPANISH_CI"] = 167] = "UTF32_SPANISH_CI";
                Charset[Charset["UTF32_SWEDISH_CI"] = 168] = "UTF32_SWEDISH_CI";
                Charset[Charset["UTF32_TURKISH_CI"] = 169] = "UTF32_TURKISH_CI";
                Charset[Charset["UTF32_CZECH_CI"] = 170] = "UTF32_CZECH_CI";
                Charset[Charset["UTF32_DANISH_CI"] = 171] = "UTF32_DANISH_CI";
                Charset[Charset["UTF32_LITHUANIAN_CI"] = 172] = "UTF32_LITHUANIAN_CI";
                Charset[Charset["UTF32_SLOVAK_CI"] = 173] = "UTF32_SLOVAK_CI";
                Charset[Charset["UTF32_SPANISH2_CI"] = 174] = "UTF32_SPANISH2_CI";
                Charset[Charset["UTF32_ROMAN_CI"] = 175] = "UTF32_ROMAN_CI";
                Charset[Charset["UTF32_PERSIAN_CI"] = 176] = "UTF32_PERSIAN_CI";
                Charset[Charset["UTF32_ESPERANTO_CI"] = 177] = "UTF32_ESPERANTO_CI";
                Charset[Charset["UTF32_HUNGARIAN_CI"] = 178] = "UTF32_HUNGARIAN_CI";
                Charset[Charset["UTF32_SINHALA_CI"] = 179] = "UTF32_SINHALA_CI";
                Charset[Charset["UTF32_GERMAN2_CI"] = 180] = "UTF32_GERMAN2_CI";
                Charset[Charset["UTF32_CROATIAN_MYSQL561_CI"] = 181] = "UTF32_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF32_UNICODE_520_CI"] = 182] = "UTF32_UNICODE_520_CI";
                Charset[Charset["UTF32_VIETNAMESE_CI"] = 183] = "UTF32_VIETNAMESE_CI";
                Charset[Charset["UTF8_UNICODE_CI"] = 192] = "UTF8_UNICODE_CI";
                Charset[Charset["UTF8_ICELANDIC_CI"] = 193] = "UTF8_ICELANDIC_CI";
                Charset[Charset["UTF8_LATVIAN_CI"] = 194] = "UTF8_LATVIAN_CI";
                Charset[Charset["UTF8_ROMANIAN_CI"] = 195] = "UTF8_ROMANIAN_CI";
                Charset[Charset["UTF8_SLOVENIAN_CI"] = 196] = "UTF8_SLOVENIAN_CI";
                Charset[Charset["UTF8_POLISH_CI"] = 197] = "UTF8_POLISH_CI";
                Charset[Charset["UTF8_ESTONIAN_CI"] = 198] = "UTF8_ESTONIAN_CI";
                Charset[Charset["UTF8_SPANISH_CI"] = 199] = "UTF8_SPANISH_CI";
                Charset[Charset["UTF8_SWEDISH_CI"] = 200] = "UTF8_SWEDISH_CI";
                Charset[Charset["UTF8_TURKISH_CI"] = 201] = "UTF8_TURKISH_CI";
                Charset[Charset["UTF8_CZECH_CI"] = 202] = "UTF8_CZECH_CI";
                Charset[Charset["UTF8_DANISH_CI"] = 203] = "UTF8_DANISH_CI";
                Charset[Charset["UTF8_LITHUANIAN_CI"] = 204] = "UTF8_LITHUANIAN_CI";
                Charset[Charset["UTF8_SLOVAK_CI"] = 205] = "UTF8_SLOVAK_CI";
                Charset[Charset["UTF8_SPANISH2_CI"] = 206] = "UTF8_SPANISH2_CI";
                Charset[Charset["UTF8_ROMAN_CI"] = 207] = "UTF8_ROMAN_CI";
                Charset[Charset["UTF8_PERSIAN_CI"] = 208] = "UTF8_PERSIAN_CI";
                Charset[Charset["UTF8_ESPERANTO_CI"] = 209] = "UTF8_ESPERANTO_CI";
                Charset[Charset["UTF8_HUNGARIAN_CI"] = 210] = "UTF8_HUNGARIAN_CI";
                Charset[Charset["UTF8_SINHALA_CI"] = 211] = "UTF8_SINHALA_CI";
                Charset[Charset["UTF8_GERMAN2_CI"] = 212] = "UTF8_GERMAN2_CI";
                Charset[Charset["UTF8_CROATIAN_MYSQL561_CI"] = 213] = "UTF8_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF8_UNICODE_520_CI"] = 214] = "UTF8_UNICODE_520_CI";
                Charset[Charset["UTF8_VIETNAMESE_CI"] = 215] = "UTF8_VIETNAMESE_CI";
                Charset[Charset["UTF8_GENERAL_MYSQL500_CI"] = 223] = "UTF8_GENERAL_MYSQL500_CI";
                Charset[Charset["UTF8MB4_UNICODE_CI"] = 224] = "UTF8MB4_UNICODE_CI";
                Charset[Charset["UTF8MB4_ICELANDIC_CI"] = 225] = "UTF8MB4_ICELANDIC_CI";
                Charset[Charset["UTF8MB4_LATVIAN_CI"] = 226] = "UTF8MB4_LATVIAN_CI";
                Charset[Charset["UTF8MB4_ROMANIAN_CI"] = 227] = "UTF8MB4_ROMANIAN_CI";
                Charset[Charset["UTF8MB4_SLOVENIAN_CI"] = 228] = "UTF8MB4_SLOVENIAN_CI";
                Charset[Charset["UTF8MB4_POLISH_CI"] = 229] = "UTF8MB4_POLISH_CI";
                Charset[Charset["UTF8MB4_ESTONIAN_CI"] = 230] = "UTF8MB4_ESTONIAN_CI";
                Charset[Charset["UTF8MB4_SPANISH_CI"] = 231] = "UTF8MB4_SPANISH_CI";
                Charset[Charset["UTF8MB4_SWEDISH_CI"] = 232] = "UTF8MB4_SWEDISH_CI";
                Charset[Charset["UTF8MB4_TURKISH_CI"] = 233] = "UTF8MB4_TURKISH_CI";
                Charset[Charset["UTF8MB4_CZECH_CI"] = 234] = "UTF8MB4_CZECH_CI";
                Charset[Charset["UTF8MB4_DANISH_CI"] = 235] = "UTF8MB4_DANISH_CI";
                Charset[Charset["UTF8MB4_LITHUANIAN_CI"] = 236] = "UTF8MB4_LITHUANIAN_CI";
                Charset[Charset["UTF8MB4_SLOVAK_CI"] = 237] = "UTF8MB4_SLOVAK_CI";
                Charset[Charset["UTF8MB4_SPANISH2_CI"] = 238] = "UTF8MB4_SPANISH2_CI";
                Charset[Charset["UTF8MB4_ROMAN_CI"] = 239] = "UTF8MB4_ROMAN_CI";
                Charset[Charset["UTF8MB4_PERSIAN_CI"] = 240] = "UTF8MB4_PERSIAN_CI";
                Charset[Charset["UTF8MB4_ESPERANTO_CI"] = 241] = "UTF8MB4_ESPERANTO_CI";
                Charset[Charset["UTF8MB4_HUNGARIAN_CI"] = 242] = "UTF8MB4_HUNGARIAN_CI";
                Charset[Charset["UTF8MB4_SINHALA_CI"] = 243] = "UTF8MB4_SINHALA_CI";
                Charset[Charset["UTF8MB4_GERMAN2_CI"] = 244] = "UTF8MB4_GERMAN2_CI";
                Charset[Charset["UTF8MB4_CROATIAN_MYSQL561_CI"] = 245] = "UTF8MB4_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF8MB4_UNICODE_520_CI"] = 246] = "UTF8MB4_UNICODE_520_CI";
                Charset[Charset["UTF8MB4_VIETNAMESE_CI"] = 247] = "UTF8MB4_VIETNAMESE_CI";
                Charset[Charset["UTF8_GENERAL50_CI"] = 253] = "UTF8_GENERAL50_CI";
                Charset[Charset["ARMSCII8"] = 32] = "ARMSCII8";
                Charset[Charset["ASCII"] = 11] = "ASCII";
                Charset[Charset["BIG5"] = 1] = "BIG5";
                Charset[Charset["CP1250"] = 26] = "CP1250";
                Charset[Charset["CP1251"] = 51] = "CP1251";
                Charset[Charset["CP1256"] = 57] = "CP1256";
                Charset[Charset["CP1257"] = 59] = "CP1257";
                Charset[Charset["CP866"] = 36] = "CP866";
                Charset[Charset["CP850"] = 4] = "CP850";
                Charset[Charset["CP852"] = 40] = "CP852";
                Charset[Charset["CP932"] = 95] = "CP932";
                Charset[Charset["DEC8"] = 3] = "DEC8";
                Charset[Charset["EUCJPMS"] = 97] = "EUCJPMS";
                Charset[Charset["EUCKR"] = 19] = "EUCKR";
                Charset[Charset["GB2312"] = 24] = "GB2312";
                Charset[Charset["GBK"] = 28] = "GBK";
                Charset[Charset["GEOSTD8"] = 92] = "GEOSTD8";
                Charset[Charset["GREEK"] = 25] = "GREEK";
                Charset[Charset["HEBREW"] = 16] = "HEBREW";
                Charset[Charset["HP8"] = 6] = "HP8";
                Charset[Charset["KEYBCS2"] = 37] = "KEYBCS2";
                Charset[Charset["KOI8R"] = 7] = "KOI8R";
                Charset[Charset["KOI8U"] = 22] = "KOI8U";
                Charset[Charset["LATIN1"] = 8] = "LATIN1";
                Charset[Charset["LATIN2"] = 9] = "LATIN2";
                Charset[Charset["LATIN5"] = 30] = "LATIN5";
                Charset[Charset["LATIN7"] = 41] = "LATIN7";
                Charset[Charset["MACCE"] = 38] = "MACCE";
                Charset[Charset["MACROMAN"] = 39] = "MACROMAN";
                Charset[Charset["SJIS"] = 13] = "SJIS";
                Charset[Charset["SWE7"] = 10] = "SWE7";
                Charset[Charset["TIS620"] = 18] = "TIS620";
                Charset[Charset["UCS2"] = 35] = "UCS2";
                Charset[Charset["UJIS"] = 12] = "UJIS";
                Charset[Charset["UTF16"] = 54] = "UTF16";
                Charset[Charset["UTF16LE"] = 56] = "UTF16LE";
                Charset[Charset["UTF8"] = 33] = "UTF8";
                Charset[Charset["UTF8MB4"] = 45] = "UTF8MB4";
                Charset[Charset["UTF32"] = 60] = "UTF32";
            })(Charset || (Charset = {}));
            exports_98("Charset", Charset);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/parsers/handshake", ["https://deno.land/x/mysql@v2.4.0/src/buffer", "https://deno.land/x/mysql@v2.4.0/src/constant/capabilities"], function (exports_99, context_99) {
    "use strict";
    var buffer_ts_1, capabilities_ts_1;
    var __moduleName = context_99 && context_99.id;
    function parseHandshake(reader) {
        const protocolVersion = reader.readUint8();
        const serverVersion = reader.readNullTerminatedString();
        const threadId = reader.readUint32();
        const seedWriter = new buffer_ts_1.BufferWriter(new Uint8Array(20));
        seedWriter.writeBuffer(reader.readBuffer(8));
        reader.skip(1);
        let serverCapabilities = reader.readUint16();
        let characterSet = 0, statusFlags = 0, authPluginDataLength = 0, authPluginName = "";
        if (!reader.finished) {
            characterSet = reader.readUint8();
            statusFlags = reader.readUint16();
            serverCapabilities |= reader.readUint16() << 16;
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_PLUGIN_AUTH) != 0) {
                authPluginDataLength = reader.readUint8();
            }
            else {
                reader.skip(1);
            }
            reader.skip(10);
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_SECURE_CONNECTION) !=
                0) {
                seedWriter.writeBuffer(reader.readBuffer(Math.max(13, authPluginDataLength - 8)));
            }
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_PLUGIN_AUTH) != 0) {
                authPluginName = reader.readNullTerminatedString();
            }
        }
        return {
            protocolVersion,
            serverVersion,
            threadId,
            seed: seedWriter.buffer,
            serverCapabilities,
            characterSet,
            statusFlags,
            authPluginName,
        };
    }
    exports_99("parseHandshake", parseHandshake);
    return {
        setters: [
            function (buffer_ts_1_1) {
                buffer_ts_1 = buffer_ts_1_1;
            },
            function (capabilities_ts_1_1) {
                capabilities_ts_1 = capabilities_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/builders/auth", ["https://deno.land/x/mysql@v2.4.0/src/auth", "https://deno.land/x/mysql@v2.4.0/src/buffer", "https://deno.land/x/mysql@v2.4.0/src/constant/capabilities", "https://deno.land/x/mysql@v2.4.0/src/constant/charset"], function (exports_100, context_100) {
    "use strict";
    var auth_ts_1, buffer_ts_2, capabilities_ts_2, charset_ts_2;
    var __moduleName = context_100 && context_100.id;
    function buildAuth(packet, params) {
        let clientParam = (params.db ? capabilities_ts_2.default.CLIENT_CONNECT_WITH_DB : 0) |
            capabilities_ts_2.default.CLIENT_PLUGIN_AUTH |
            capabilities_ts_2.default.CLIENT_LONG_PASSWORD |
            capabilities_ts_2.default.CLIENT_PROTOCOL_41 |
            capabilities_ts_2.default.CLIENT_TRANSACTIONS |
            capabilities_ts_2.default.CLIENT_MULTI_RESULTS |
            capabilities_ts_2.default.CLIENT_SECURE_CONNECTION;
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_LONG_FLAG) {
            clientParam |= capabilities_ts_2.default.CLIENT_LONG_FLAG;
        }
        if (packet.serverCapabilities &
            capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
            clientParam |= capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA;
        }
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_DEPRECATE_EOF) {
            clientParam |= capabilities_ts_2.default.CLIENT_DEPRECATE_EOF;
        }
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_PLUGIN_AUTH) {
            const writer = new buffer_ts_2.BufferWriter(new Uint8Array(1000));
            writer
                .writeUint32(clientParam)
                .writeUint32(2 ** 24 - 1)
                .write(charset_ts_2.Charset.UTF8_GENERAL_CI)
                .skip(23)
                .writeNullTerminatedString(params.username);
            if (params.password) {
                const authData = auth_ts_1.default(packet.authPluginName, params.password, packet.seed);
                if (clientParam &
                    capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA ||
                    clientParam & capabilities_ts_2.default.CLIENT_SECURE_CONNECTION) {
                    writer.write(authData.length);
                    writer.writeBuffer(authData);
                }
                else {
                    writer.writeBuffer(authData);
                    writer.write(0);
                }
            }
            else {
                writer.write(0);
            }
            if (clientParam & capabilities_ts_2.default.CLIENT_CONNECT_WITH_DB && params.db) {
                writer.writeNullTerminatedString(params.db);
            }
            if (clientParam & capabilities_ts_2.default.CLIENT_PLUGIN_AUTH) {
                writer.writeNullTerminatedString(packet.authPluginName);
            }
            return writer.wroteData;
        }
        return Uint8Array.from([]);
    }
    exports_100("buildAuth", buildAuth);
    return {
        setters: [
            function (auth_ts_1_1) {
                auth_ts_1 = auth_ts_1_1;
            },
            function (buffer_ts_2_1) {
                buffer_ts_2 = buffer_ts_2_1;
            },
            function (capabilities_ts_2_1) {
                capabilities_ts_2 = capabilities_ts_2_1;
            },
            function (charset_ts_2_1) {
                charset_ts_2 = charset_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/builders/query", ["https://deno.land/x/mysql@v2.4.0/deps", "https://deno.land/x/mysql@v2.4.0/src/buffer"], function (exports_101, context_101) {
    "use strict";
    var deps_ts_23, buffer_ts_3;
    var __moduleName = context_101 && context_101.id;
    function buildQuery(sql, params = []) {
        const data = deps_ts_23.encode(deps_ts_23.replaceParams(sql, params));
        const writer = new buffer_ts_3.BufferWriter(new Uint8Array(data.length + 1));
        writer.write(0x03);
        writer.writeBuffer(data);
        return writer.buffer;
    }
    exports_101("buildQuery", buildQuery);
    return {
        setters: [
            function (deps_ts_23_1) {
                deps_ts_23 = deps_ts_23_1;
            },
            function (buffer_ts_3_1) {
                buffer_ts_3 = buffer_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/packet", ["https://deno.land/x/mysql@v2.4.0/deps", "https://deno.land/x/mysql@v2.4.0/src/buffer", "https://deno.land/x/mysql@v2.4.0/src/constant/errors", "https://deno.land/x/mysql@v2.4.0/src/logger"], function (exports_102, context_102) {
    "use strict";
    var deps_ts_24, buffer_ts_4, errors_ts_1, logger_ts_2, SendPacket, ReceivePacket;
    var __moduleName = context_102 && context_102.id;
    return {
        setters: [
            function (deps_ts_24_1) {
                deps_ts_24 = deps_ts_24_1;
            },
            function (buffer_ts_4_1) {
                buffer_ts_4 = buffer_ts_4_1;
            },
            function (errors_ts_1_1) {
                errors_ts_1 = errors_ts_1_1;
            },
            function (logger_ts_2_1) {
                logger_ts_2 = logger_ts_2_1;
            }
        ],
        execute: function () {
            SendPacket = class SendPacket {
                constructor(body, no) {
                    this.body = body;
                    this.header = { size: body.length, no };
                }
                async send(conn) {
                    const body = this.body;
                    const data = new buffer_ts_4.BufferWriter(new Uint8Array(4 + body.length));
                    data.writeUints(3, this.header.size);
                    data.write(this.header.no);
                    data.writeBuffer(body);
                    logger_ts_2.log.debug(`send: ${data.length}B \n${deps_ts_24.byteFormat(data.buffer)}\n`);
                    try {
                        await conn.write(data.buffer);
                    }
                    catch (error) {
                        throw new errors_ts_1.WriteError(error.message);
                    }
                }
            };
            exports_102("SendPacket", SendPacket);
            ReceivePacket = class ReceivePacket {
                async parse(reader) {
                    const header = new buffer_ts_4.BufferReader(new Uint8Array(4));
                    let readCount = 0;
                    let nread = await reader.read(header.buffer);
                    if (nread === null)
                        return null;
                    readCount = nread;
                    this.header = {
                        size: header.readUints(3),
                        no: header.readUint8(),
                    };
                    this.body = new buffer_ts_4.BufferReader(new Uint8Array(this.header.size));
                    nread = await reader.read(this.body.buffer);
                    if (nread === null)
                        return null;
                    readCount += nread;
                    switch (this.body.buffer[0]) {
                        case 0x00:
                            this.type = "OK";
                            break;
                        case 0xff:
                            this.type = "ERR";
                            break;
                        case 0xfe:
                            this.type = "EOF";
                            break;
                        default:
                            this.type = "RESULT";
                            break;
                    }
                    logger_ts_2.debug(() => {
                        const data = new Uint8Array(readCount);
                        data.set(header.buffer);
                        data.set(this.body.buffer, 4);
                        logger_ts_2.log.debug(`receive: ${readCount}B, size = ${this.header.size}, no = ${this.header.no} \n${deps_ts_24.byteFormat(data)}\n`);
                    });
                    return this;
                }
            };
            exports_102("ReceivePacket", ReceivePacket);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/parsers/err", ["https://deno.land/x/mysql@v2.4.0/src/constant/capabilities"], function (exports_103, context_103) {
    "use strict";
    var capabilities_ts_3;
    var __moduleName = context_103 && context_103.id;
    function parseError(reader, conn) {
        const code = reader.readUint16();
        const packet = {
            code,
            message: "",
        };
        if (conn.capabilities & capabilities_ts_3.default.CLIENT_PROTOCOL_41) {
            packet.sqlStateMarker = reader.readUint8();
            packet.sqlState = reader.readUints(5);
        }
        packet.message = reader.readNullTerminatedString();
        return packet;
    }
    exports_103("parseError", parseError);
    return {
        setters: [
            function (capabilities_ts_3_1) {
                capabilities_ts_3 = capabilities_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/constant/mysql_types", [], function (exports_104, context_104) {
    "use strict";
    var MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY, MYSQL_TYPE_SHORT, MYSQL_TYPE_LONG, MYSQL_TYPE_FLOAT, MYSQL_TYPE_DOUBLE, MYSQL_TYPE_NULL, MYSQL_TYPE_TIMESTAMP, MYSQL_TYPE_LONGLONG, MYSQL_TYPE_INT24, MYSQL_TYPE_DATE, MYSQL_TYPE_TIME, MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR, MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR, MYSQL_TYPE_BIT, MYSQL_TYPE_TIMESTAMP2, MYSQL_TYPE_DATETIME2, MYSQL_TYPE_TIME2, MYSQL_TYPE_NEWDECIMAL, MYSQL_TYPE_ENUM, MYSQL_TYPE_SET, MYSQL_TYPE_TINY_BLOB, MYSQL_TYPE_MEDIUM_BLOB, MYSQL_TYPE_LONG_BLOB, MYSQL_TYPE_BLOB, MYSQL_TYPE_VAR_STRING, MYSQL_TYPE_STRING, MYSQL_TYPE_GEOMETRY;
    var __moduleName = context_104 && context_104.id;
    return {
        setters: [],
        execute: function () {
            exports_104("MYSQL_TYPE_DECIMAL", MYSQL_TYPE_DECIMAL = 0x00);
            exports_104("MYSQL_TYPE_TINY", MYSQL_TYPE_TINY = 0x01);
            exports_104("MYSQL_TYPE_SHORT", MYSQL_TYPE_SHORT = 0x02);
            exports_104("MYSQL_TYPE_LONG", MYSQL_TYPE_LONG = 0x03);
            exports_104("MYSQL_TYPE_FLOAT", MYSQL_TYPE_FLOAT = 0x04);
            exports_104("MYSQL_TYPE_DOUBLE", MYSQL_TYPE_DOUBLE = 0x05);
            exports_104("MYSQL_TYPE_NULL", MYSQL_TYPE_NULL = 0x06);
            exports_104("MYSQL_TYPE_TIMESTAMP", MYSQL_TYPE_TIMESTAMP = 0x07);
            exports_104("MYSQL_TYPE_LONGLONG", MYSQL_TYPE_LONGLONG = 0x08);
            exports_104("MYSQL_TYPE_INT24", MYSQL_TYPE_INT24 = 0x09);
            exports_104("MYSQL_TYPE_DATE", MYSQL_TYPE_DATE = 0x0a);
            exports_104("MYSQL_TYPE_TIME", MYSQL_TYPE_TIME = 0x0b);
            exports_104("MYSQL_TYPE_DATETIME", MYSQL_TYPE_DATETIME = 0x0c);
            exports_104("MYSQL_TYPE_YEAR", MYSQL_TYPE_YEAR = 0x0d);
            exports_104("MYSQL_TYPE_NEWDATE", MYSQL_TYPE_NEWDATE = 0x0e);
            exports_104("MYSQL_TYPE_VARCHAR", MYSQL_TYPE_VARCHAR = 0x0f);
            exports_104("MYSQL_TYPE_BIT", MYSQL_TYPE_BIT = 0x10);
            exports_104("MYSQL_TYPE_TIMESTAMP2", MYSQL_TYPE_TIMESTAMP2 = 0x11);
            exports_104("MYSQL_TYPE_DATETIME2", MYSQL_TYPE_DATETIME2 = 0x12);
            exports_104("MYSQL_TYPE_TIME2", MYSQL_TYPE_TIME2 = 0x13);
            exports_104("MYSQL_TYPE_NEWDECIMAL", MYSQL_TYPE_NEWDECIMAL = 0xf6);
            exports_104("MYSQL_TYPE_ENUM", MYSQL_TYPE_ENUM = 0xf7);
            exports_104("MYSQL_TYPE_SET", MYSQL_TYPE_SET = 0xf8);
            exports_104("MYSQL_TYPE_TINY_BLOB", MYSQL_TYPE_TINY_BLOB = 0xf9);
            exports_104("MYSQL_TYPE_MEDIUM_BLOB", MYSQL_TYPE_MEDIUM_BLOB = 0xfa);
            exports_104("MYSQL_TYPE_LONG_BLOB", MYSQL_TYPE_LONG_BLOB = 0xfb);
            exports_104("MYSQL_TYPE_BLOB", MYSQL_TYPE_BLOB = 0xfc);
            exports_104("MYSQL_TYPE_VAR_STRING", MYSQL_TYPE_VAR_STRING = 0xfd);
            exports_104("MYSQL_TYPE_STRING", MYSQL_TYPE_STRING = 0xfe);
            exports_104("MYSQL_TYPE_GEOMETRY", MYSQL_TYPE_GEOMETRY = 0xff);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/packets/parsers/result", ["https://deno.land/x/mysql@v2.4.0/src/constant/mysql_types"], function (exports_105, context_105) {
    "use strict";
    var mysql_types_ts_1;
    var __moduleName = context_105 && context_105.id;
    function parseField(reader) {
        const catalog = reader.readLenCodeString();
        const schema = reader.readLenCodeString();
        const table = reader.readLenCodeString();
        const originTable = reader.readLenCodeString();
        const name = reader.readLenCodeString();
        const originName = reader.readLenCodeString();
        reader.skip(1);
        const encoding = reader.readUint16();
        const fieldLen = reader.readUint32();
        const fieldType = reader.readUint8();
        const fieldFlag = reader.readUint16();
        const decimals = reader.readUint8();
        reader.skip(1);
        const defaultVal = reader.readLenCodeString();
        return {
            catalog,
            schema,
            table,
            originName,
            fieldFlag,
            originTable,
            fieldLen,
            name,
            fieldType,
            encoding,
            decimals,
            defaultVal,
        };
    }
    exports_105("parseField", parseField);
    function parseRow(reader, fileds) {
        const row = {};
        for (let i = 0; i < fileds.length; i++) {
            const name = fileds[i].name;
            const val = reader.readLenCodeString();
            row[name] = val === null ? null : convertType(fileds[i], val);
        }
        return row;
    }
    exports_105("parseRow", parseRow);
    function convertType(field, val) {
        const { fieldType, fieldLen } = field;
        if (fieldType === mysql_types_ts_1.MYSQL_TYPE_TINY && fieldLen === 1) {
            return !!parseInt(val);
        }
        switch (fieldType) {
            case mysql_types_ts_1.MYSQL_TYPE_DECIMAL:
            case mysql_types_ts_1.MYSQL_TYPE_DOUBLE:
            case mysql_types_ts_1.MYSQL_TYPE_FLOAT:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME2:
                return parseFloat(val);
            case mysql_types_ts_1.MYSQL_TYPE_NEWDECIMAL:
                return val;
            case mysql_types_ts_1.MYSQL_TYPE_TINY:
            case mysql_types_ts_1.MYSQL_TYPE_SHORT:
            case mysql_types_ts_1.MYSQL_TYPE_LONG:
            case mysql_types_ts_1.MYSQL_TYPE_INT24:
                return parseInt(val);
            case mysql_types_ts_1.MYSQL_TYPE_LONGLONG:
                if (Number(val) < Number.MIN_SAFE_INTEGER ||
                    Number(val) > Number.MAX_SAFE_INTEGER) {
                    return BigInt(val);
                }
                else {
                    return parseInt(val);
                }
            case mysql_types_ts_1.MYSQL_TYPE_VARCHAR:
            case mysql_types_ts_1.MYSQL_TYPE_VAR_STRING:
            case mysql_types_ts_1.MYSQL_TYPE_STRING:
            case mysql_types_ts_1.MYSQL_TYPE_TIME:
            case mysql_types_ts_1.MYSQL_TYPE_TIME2:
                return val;
            case mysql_types_ts_1.MYSQL_TYPE_DATE:
            case mysql_types_ts_1.MYSQL_TYPE_TIMESTAMP:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME:
            case mysql_types_ts_1.MYSQL_TYPE_NEWDATE:
            case mysql_types_ts_1.MYSQL_TYPE_TIMESTAMP2:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME2:
                return new Date(val);
            default:
                return val;
        }
    }
    return {
        setters: [
            function (mysql_types_ts_1_1) {
                mysql_types_ts_1 = mysql_types_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/connection", ["https://deno.land/x/mysql@v2.4.0/deps", "https://deno.land/x/mysql@v2.4.0/src/constant/errors", "https://deno.land/x/mysql@v2.4.0/src/logger", "https://deno.land/x/mysql@v2.4.0/src/packets/builders/auth", "https://deno.land/x/mysql@v2.4.0/src/packets/builders/query", "https://deno.land/x/mysql@v2.4.0/src/packets/packet", "https://deno.land/x/mysql@v2.4.0/src/packets/parsers/err", "https://deno.land/x/mysql@v2.4.0/src/packets/parsers/handshake", "https://deno.land/x/mysql@v2.4.0/src/packets/parsers/result"], function (exports_106, context_106) {
    "use strict";
    var deps_ts_25, errors_ts_2, logger_ts_3, auth_ts_2, query_ts_1, packet_ts_1, err_ts_1, handshake_ts_1, result_ts_1, ConnectionState, Connection;
    var __moduleName = context_106 && context_106.id;
    return {
        setters: [
            function (deps_ts_25_1) {
                deps_ts_25 = deps_ts_25_1;
            },
            function (errors_ts_2_1) {
                errors_ts_2 = errors_ts_2_1;
            },
            function (logger_ts_3_1) {
                logger_ts_3 = logger_ts_3_1;
            },
            function (auth_ts_2_1) {
                auth_ts_2 = auth_ts_2_1;
            },
            function (query_ts_1_1) {
                query_ts_1 = query_ts_1_1;
            },
            function (packet_ts_1_1) {
                packet_ts_1 = packet_ts_1_1;
            },
            function (err_ts_1_1) {
                err_ts_1 = err_ts_1_1;
            },
            function (handshake_ts_1_1) {
                handshake_ts_1 = handshake_ts_1_1;
            },
            function (result_ts_1_1) {
                result_ts_1 = result_ts_1_1;
            }
        ],
        execute: function () {
            (function (ConnectionState) {
                ConnectionState[ConnectionState["CONNECTING"] = 0] = "CONNECTING";
                ConnectionState[ConnectionState["CONNECTED"] = 1] = "CONNECTED";
                ConnectionState[ConnectionState["COLSING"] = 2] = "COLSING";
                ConnectionState[ConnectionState["CLOSED"] = 3] = "CLOSED";
            })(ConnectionState || (ConnectionState = {}));
            exports_106("ConnectionState", ConnectionState);
            Connection = class Connection {
                constructor(client) {
                    this.client = client;
                    this.state = ConnectionState.CONNECTING;
                    this.capabilities = 0;
                    this.serverVersion = "";
                }
                async _connect() {
                    const { hostname, port = 3306 } = this.client.config;
                    logger_ts_3.log.info(`connecting ${hostname}:${port}`);
                    this.conn = await Deno.connect({
                        hostname,
                        port,
                        transport: "tcp",
                    });
                    let receive = await this.nextPacket();
                    const handshakePacket = handshake_ts_1.parseHandshake(receive.body);
                    const data = auth_ts_2.buildAuth(handshakePacket, {
                        username: this.client.config.username ?? "",
                        password: this.client.config.password,
                        db: this.client.config.db,
                    });
                    await new packet_ts_1.SendPacket(data, 0x1).send(this.conn);
                    this.state = ConnectionState.CONNECTING;
                    this.serverVersion = handshakePacket.serverVersion;
                    this.capabilities = handshakePacket.serverCapabilities;
                    receive = await this.nextPacket();
                    const header = receive.body.readUint8();
                    if (header === 0xff) {
                        const error = err_ts_1.parseError(receive.body, this);
                        logger_ts_3.log.error(`connect error(${error.code}): ${error.message}`);
                        this.close();
                        throw new Error(error.message);
                    }
                    else {
                        logger_ts_3.log.info(`connected to ${this.client.config.hostname}`);
                        this.state = ConnectionState.CONNECTED;
                    }
                    if (this.client.config.charset) {
                        await this.execute(`SET NAMES ${this.client.config.charset}`);
                    }
                }
                async connect() {
                    await this._connect();
                }
                async nextPacket() {
                    let eofCount = 0;
                    const timeout = this.client.config.timeout || 1000;
                    while (this.conn) {
                        const packet = await new packet_ts_1.ReceivePacket().parse(this.conn);
                        if (packet) {
                            if (packet.type === "ERR") {
                                packet.body.skip(1);
                                const error = err_ts_1.parseError(packet.body, this);
                                throw new Error(error.message);
                            }
                            return packet;
                        }
                        else {
                            await deps_ts_25.delay(100);
                            if (eofCount++ * 100 >= timeout) {
                                throw new errors_ts_2.ResponseTimeoutError("Read packet timeout");
                            }
                        }
                    }
                    throw new Error("Not connected");
                }
                lessThan57() {
                    const version = this.serverVersion;
                    if (!version.includes("MariaDB"))
                        return version < "5.7.0";
                    const segments = version.split("-");
                    if (segments[1] === "MariaDB")
                        return segments[0] < "5.7.0";
                    return false;
                }
                close() {
                    logger_ts_3.log.info("close connection");
                    this.state = ConnectionState.COLSING;
                    this.conn && this.conn.close();
                    this.state = ConnectionState.CLOSED;
                }
                async query(sql, params) {
                    const result = await this.execute(sql, params);
                    if (result && result.rows) {
                        return result.rows;
                    }
                    else {
                        return result;
                    }
                }
                async execute(sql, params) {
                    if (!this.conn) {
                        throw new Error("Must be connected first");
                    }
                    const data = query_ts_1.buildQuery(sql, params);
                    await new packet_ts_1.SendPacket(data, 0).send(this.conn);
                    let receive = await this.nextPacket();
                    if (receive.type === "OK") {
                        receive.body.skip(1);
                        return {
                            affectedRows: receive.body.readEncodedLen(),
                            lastInsertId: receive.body.readEncodedLen(),
                        };
                    }
                    let fieldCount = receive.body.readEncodedLen();
                    const fields = [];
                    while (fieldCount--) {
                        const packet = await this.nextPacket();
                        if (packet) {
                            const field = result_ts_1.parseField(packet.body);
                            fields.push(field);
                        }
                    }
                    const rows = [];
                    if (this.lessThan57()) {
                        receive = await this.nextPacket();
                    }
                    while (true) {
                        receive = await this.nextPacket();
                        if (receive.type === "EOF") {
                            break;
                        }
                        else {
                            const row = result_ts_1.parseRow(receive.body, fields);
                            rows.push(row);
                        }
                    }
                    return { rows, fields };
                }
            };
            exports_106("Connection", Connection);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/deferred", ["https://deno.land/x/mysql@v2.4.0/deps"], function (exports_107, context_107) {
    "use strict";
    var deps_ts_26, DeferredStack;
    var __moduleName = context_107 && context_107.id;
    return {
        setters: [
            function (deps_ts_26_1) {
                deps_ts_26 = deps_ts_26_1;
            }
        ],
        execute: function () {
            DeferredStack = class DeferredStack {
                constructor(_maxSize, _array = [], creator) {
                    this._maxSize = _maxSize;
                    this._array = _array;
                    this.creator = creator;
                    this._queue = [];
                    this._size = 0;
                    this._size = _array.length;
                }
                get size() {
                    return this._size;
                }
                get maxSize() {
                    return this._maxSize;
                }
                get available() {
                    return this._array.length;
                }
                async pop() {
                    if (this._array.length) {
                        return this._array.pop();
                    }
                    else if (this._size < this._maxSize) {
                        this._size++;
                        const item = await this.creator();
                        return item;
                    }
                    const defer = deps_ts_26.deferred();
                    this._queue.push(defer);
                    await defer;
                    return this._array.pop();
                }
                async push(item) {
                    this._array.push(item);
                    if (this._queue.length) {
                        this._queue.shift().resolve();
                    }
                }
                reduceSize() {
                    this._size--;
                }
            };
            exports_107("DeferredStack", DeferredStack);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/src/client", ["https://deno.land/x/mysql@v2.4.0/src/connection", "https://deno.land/x/mysql@v2.4.0/src/constant/errors", "https://deno.land/x/mysql@v2.4.0/src/deferred", "https://deno.land/x/mysql@v2.4.0/src/logger"], function (exports_108, context_108) {
    "use strict";
    var connection_ts_1, errors_ts_3, deferred_ts_6, logger_ts_4, Client;
    var __moduleName = context_108 && context_108.id;
    return {
        setters: [
            function (connection_ts_1_1) {
                connection_ts_1 = connection_ts_1_1;
            },
            function (errors_ts_3_1) {
                errors_ts_3 = errors_ts_3_1;
            },
            function (deferred_ts_6_1) {
                deferred_ts_6 = deferred_ts_6_1;
            },
            function (logger_ts_4_1) {
                logger_ts_4 = logger_ts_4_1;
            }
        ],
        execute: function () {
            Client = class Client {
                constructor() {
                    this.config = {};
                    this._connections = [];
                }
                async createConnection() {
                    let connection = new connection_ts_1.Connection(this);
                    await connection.connect();
                    return connection;
                }
                get pool() {
                    if (this._pool) {
                        return {
                            size: this._pool.size,
                            maxSize: this._pool.maxSize,
                            available: this._pool.available,
                        };
                    }
                }
                async connect(config) {
                    this.config = {
                        hostname: "127.0.0.1",
                        username: "root",
                        port: 3306,
                        poolSize: 1,
                        ...config,
                    };
                    Object.freeze(this.config);
                    this._connections = [];
                    this._pool = new deferred_ts_6.DeferredStack(this.config.poolSize || 10, this._connections, this.createConnection.bind(this));
                    return this;
                }
                async query(sql, params) {
                    return await this.useConnection(async (connection) => {
                        return await connection.query(sql, params);
                    });
                }
                async execute(sql, params) {
                    return await this.useConnection(async (connection) => {
                        return await connection.execute(sql, params);
                    });
                }
                async useConnection(fn) {
                    if (!this._pool) {
                        throw new Error("Unconnected");
                    }
                    const connection = await this._pool.pop();
                    try {
                        const result = await fn(connection);
                        this._pool.push(connection);
                        return result;
                    }
                    catch (error) {
                        if (error instanceof errors_ts_3.WriteError ||
                            error instanceof errors_ts_3.ResponseTimeoutError) {
                            this._pool.reduceSize();
                        }
                        else {
                            this._pool.push(connection);
                        }
                        throw error;
                    }
                }
                async transaction(processor) {
                    return await this.useConnection(async (connection) => {
                        try {
                            await connection.execute("BEGIN");
                            const result = await processor(connection);
                            await connection.execute("COMMIT");
                            return result;
                        }
                        catch (error) {
                            logger_ts_4.log.info(`ROLLBACK: ${error.message}`);
                            await connection.execute("ROLLBACK");
                            throw error;
                        }
                    });
                }
                async close() {
                    await Promise.all(this._connections.map((conn) => conn.close()));
                }
            };
            exports_108("Client", Client);
        }
    };
});
System.register("https://deno.land/x/mysql@v2.4.0/mod", ["https://deno.land/x/mysql@v2.4.0/src/client", "https://deno.land/x/mysql@v2.4.0/src/connection"], function (exports_109, context_109) {
    "use strict";
    var __moduleName = context_109 && context_109.id;
    return {
        setters: [
            function (client_ts_1_1) {
                exports_109({
                    "Client": client_ts_1_1["Client"]
                });
            },
            function (connection_ts_2_1) {
                exports_109({
                    "Connection": connection_ts_2_1["Connection"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.68.0/fmt/printf", [], function (exports_110, context_110) {
    "use strict";
    var State, WorP, Flags, min, UNICODE_REPLACEMENT_CHARACTER, DEFAULT_PRECISION, FLOAT_REGEXP, F, Printf;
    var __moduleName = context_110 && context_110.id;
    function sprintf(format, ...args) {
        const printf = new Printf(format, ...args);
        return printf.doPrintf();
    }
    exports_110("sprintf", sprintf);
    function printf(format, ...args) {
        const s = sprintf(format, ...args);
        Deno.stdout.writeSync(new TextEncoder().encode(s));
    }
    exports_110("printf", printf);
    return {
        setters: [],
        execute: function () {
            (function (State) {
                State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
                State[State["PERCENT"] = 1] = "PERCENT";
                State[State["POSITIONAL"] = 2] = "POSITIONAL";
                State[State["PRECISION"] = 3] = "PRECISION";
                State[State["WIDTH"] = 4] = "WIDTH";
            })(State || (State = {}));
            (function (WorP) {
                WorP[WorP["WIDTH"] = 0] = "WIDTH";
                WorP[WorP["PRECISION"] = 1] = "PRECISION";
            })(WorP || (WorP = {}));
            Flags = class Flags {
                constructor() {
                    this.width = -1;
                    this.precision = -1;
                }
            };
            min = Math.min;
            UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
            DEFAULT_PRECISION = 6;
            FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
            (function (F) {
                F[F["sign"] = 1] = "sign";
                F[F["mantissa"] = 2] = "mantissa";
                F[F["fractional"] = 3] = "fractional";
                F[F["esign"] = 4] = "esign";
                F[F["exponent"] = 5] = "exponent";
            })(F || (F = {}));
            Printf = class Printf {
                constructor(format, ...args) {
                    this.state = State.PASSTHROUGH;
                    this.verb = "";
                    this.buf = "";
                    this.argNum = 0;
                    this.flags = new Flags();
                    this.format = format;
                    this.args = args;
                    this.haveSeen = new Array(args.length);
                    this.i = 0;
                }
                doPrintf() {
                    for (; this.i < this.format.length; ++this.i) {
                        const c = this.format[this.i];
                        switch (this.state) {
                            case State.PASSTHROUGH:
                                if (c === "%") {
                                    this.state = State.PERCENT;
                                }
                                else {
                                    this.buf += c;
                                }
                                break;
                            case State.PERCENT:
                                if (c === "%") {
                                    this.buf += c;
                                    this.state = State.PASSTHROUGH;
                                }
                                else {
                                    this.handleFormat();
                                }
                                break;
                            default:
                                throw Error("Should be unreachable, certainly a bug in the lib.");
                        }
                    }
                    let extras = false;
                    let err = "%!(EXTRA";
                    for (let i = 0; i !== this.haveSeen.length; ++i) {
                        if (!this.haveSeen[i]) {
                            extras = true;
                            err += ` '${Deno.inspect(this.args[i])}'`;
                        }
                    }
                    err += ")";
                    if (extras) {
                        this.buf += err;
                    }
                    return this.buf;
                }
                handleFormat() {
                    this.flags = new Flags();
                    const flags = this.flags;
                    for (; this.i < this.format.length; ++this.i) {
                        const c = this.format[this.i];
                        switch (this.state) {
                            case State.PERCENT:
                                switch (c) {
                                    case "[":
                                        this.handlePositional();
                                        this.state = State.POSITIONAL;
                                        break;
                                    case "+":
                                        flags.plus = true;
                                        break;
                                    case "<":
                                        flags.lessthan = true;
                                        break;
                                    case "-":
                                        flags.dash = true;
                                        flags.zero = false;
                                        break;
                                    case "#":
                                        flags.sharp = true;
                                        break;
                                    case " ":
                                        flags.space = true;
                                        break;
                                    case "0":
                                        flags.zero = !flags.dash;
                                        break;
                                    default:
                                        if (("1" <= c && c <= "9") || c === "." || c === "*") {
                                            if (c === ".") {
                                                this.flags.precision = 0;
                                                this.state = State.PRECISION;
                                                this.i++;
                                            }
                                            else {
                                                this.state = State.WIDTH;
                                            }
                                            this.handleWidthAndPrecision(flags);
                                        }
                                        else {
                                            this.handleVerb();
                                            return;
                                        }
                                }
                                break;
                            case State.POSITIONAL:
                                if (c === "*") {
                                    const worp = this.flags.precision === -1
                                        ? WorP.WIDTH
                                        : WorP.PRECISION;
                                    this.handleWidthOrPrecisionRef(worp);
                                    this.state = State.PERCENT;
                                    break;
                                }
                                else {
                                    this.handleVerb();
                                    return;
                                }
                            default:
                                throw new Error(`Should not be here ${this.state}, library bug!`);
                        }
                    }
                }
                handleWidthOrPrecisionRef(wOrP) {
                    if (this.argNum >= this.args.length) {
                        return;
                    }
                    const arg = this.args[this.argNum];
                    this.haveSeen[this.argNum] = true;
                    if (typeof arg === "number") {
                        switch (wOrP) {
                            case WorP.WIDTH:
                                this.flags.width = arg;
                                break;
                            default:
                                this.flags.precision = arg;
                        }
                    }
                    else {
                        const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
                        this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
                    }
                    this.argNum++;
                }
                handleWidthAndPrecision(flags) {
                    const fmt = this.format;
                    for (; this.i !== this.format.length; ++this.i) {
                        const c = fmt[this.i];
                        switch (this.state) {
                            case State.WIDTH:
                                switch (c) {
                                    case ".":
                                        this.flags.precision = 0;
                                        this.state = State.PRECISION;
                                        break;
                                    case "*":
                                        this.handleWidthOrPrecisionRef(WorP.WIDTH);
                                        break;
                                    default:
                                        const val = parseInt(c);
                                        if (isNaN(val)) {
                                            this.i--;
                                            this.state = State.PERCENT;
                                            return;
                                        }
                                        flags.width = flags.width == -1 ? 0 : flags.width;
                                        flags.width *= 10;
                                        flags.width += val;
                                }
                                break;
                            case State.PRECISION: {
                                if (c === "*") {
                                    this.handleWidthOrPrecisionRef(WorP.PRECISION);
                                    break;
                                }
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.precision *= 10;
                                flags.precision += val;
                                break;
                            }
                            default:
                                throw new Error("can't be here. bug.");
                        }
                    }
                }
                handlePositional() {
                    if (this.format[this.i] !== "[") {
                        throw new Error("Can't happen? Bug.");
                    }
                    let positional = 0;
                    const format = this.format;
                    this.i++;
                    let err = false;
                    for (; this.i !== this.format.length; ++this.i) {
                        if (format[this.i] === "]") {
                            break;
                        }
                        positional *= 10;
                        const val = parseInt(format[this.i]);
                        if (isNaN(val)) {
                            this.tmpError = "%!(BAD INDEX)";
                            err = true;
                        }
                        positional += val;
                    }
                    if (positional - 1 >= this.args.length) {
                        this.tmpError = "%!(BAD INDEX)";
                        err = true;
                    }
                    this.argNum = err ? this.argNum : positional - 1;
                    return;
                }
                handleLessThan() {
                    const arg = this.args[this.argNum];
                    if ((arg || {}).constructor.name !== "Array") {
                        throw new Error(`arg ${arg} is not an array. Todo better error handling`);
                    }
                    let str = "[ ";
                    for (let i = 0; i !== arg.length; ++i) {
                        if (i !== 0)
                            str += ", ";
                        str += this._handleVerb(arg[i]);
                    }
                    return str + " ]";
                }
                handleVerb() {
                    const verb = this.format[this.i];
                    this.verb = verb;
                    if (this.tmpError) {
                        this.buf += this.tmpError;
                        this.tmpError = undefined;
                        if (this.argNum < this.haveSeen.length) {
                            this.haveSeen[this.argNum] = true;
                        }
                    }
                    else if (this.args.length <= this.argNum) {
                        this.buf += `%!(MISSING '${verb}')`;
                    }
                    else {
                        const arg = this.args[this.argNum];
                        this.haveSeen[this.argNum] = true;
                        if (this.flags.lessthan) {
                            this.buf += this.handleLessThan();
                        }
                        else {
                            this.buf += this._handleVerb(arg);
                        }
                    }
                    this.argNum++;
                    this.state = State.PASSTHROUGH;
                }
                _handleVerb(arg) {
                    switch (this.verb) {
                        case "t":
                            return this.pad(arg.toString());
                        case "b":
                            return this.fmtNumber(arg, 2);
                        case "c":
                            return this.fmtNumberCodePoint(arg);
                        case "d":
                            return this.fmtNumber(arg, 10);
                        case "o":
                            return this.fmtNumber(arg, 8);
                        case "x":
                            return this.fmtHex(arg);
                        case "X":
                            return this.fmtHex(arg, true);
                        case "e":
                            return this.fmtFloatE(arg);
                        case "E":
                            return this.fmtFloatE(arg, true);
                        case "f":
                        case "F":
                            return this.fmtFloatF(arg);
                        case "g":
                            return this.fmtFloatG(arg);
                        case "G":
                            return this.fmtFloatG(arg, true);
                        case "s":
                            return this.fmtString(arg);
                        case "T":
                            return this.fmtString(typeof arg);
                        case "v":
                            return this.fmtV(arg);
                        case "j":
                            return this.fmtJ(arg);
                        default:
                            return `%!(BAD VERB '${this.verb}')`;
                    }
                }
                pad(s) {
                    const padding = this.flags.zero ? "0" : " ";
                    if (this.flags.dash) {
                        return s.padEnd(this.flags.width, padding);
                    }
                    return s.padStart(this.flags.width, padding);
                }
                padNum(nStr, neg) {
                    let sign;
                    if (neg) {
                        sign = "-";
                    }
                    else if (this.flags.plus || this.flags.space) {
                        sign = this.flags.plus ? "+" : " ";
                    }
                    else {
                        sign = "";
                    }
                    const zero = this.flags.zero;
                    if (!zero) {
                        nStr = sign + nStr;
                    }
                    const pad = zero ? "0" : " ";
                    const len = zero ? this.flags.width - sign.length : this.flags.width;
                    if (this.flags.dash) {
                        nStr = nStr.padEnd(len, pad);
                    }
                    else {
                        nStr = nStr.padStart(len, pad);
                    }
                    if (zero) {
                        nStr = sign + nStr;
                    }
                    return nStr;
                }
                fmtNumber(n, radix, upcase = false) {
                    let num = Math.abs(n).toString(radix);
                    const prec = this.flags.precision;
                    if (prec !== -1) {
                        this.flags.zero = false;
                        num = n === 0 && prec === 0 ? "" : num;
                        while (num.length < prec) {
                            num = "0" + num;
                        }
                    }
                    let prefix = "";
                    if (this.flags.sharp) {
                        switch (radix) {
                            case 2:
                                prefix += "0b";
                                break;
                            case 8:
                                prefix += num.startsWith("0") ? "" : "0";
                                break;
                            case 16:
                                prefix += "0x";
                                break;
                            default:
                                throw new Error("cannot handle base: " + radix);
                        }
                    }
                    num = num.length === 0 ? num : prefix + num;
                    if (upcase) {
                        num = num.toUpperCase();
                    }
                    return this.padNum(num, n < 0);
                }
                fmtNumberCodePoint(n) {
                    let s = "";
                    try {
                        s = String.fromCodePoint(n);
                    }
                    catch (RangeError) {
                        s = UNICODE_REPLACEMENT_CHARACTER;
                    }
                    return this.pad(s);
                }
                fmtFloatSpecial(n) {
                    if (isNaN(n)) {
                        this.flags.zero = false;
                        return this.padNum("NaN", false);
                    }
                    if (n === Number.POSITIVE_INFINITY) {
                        this.flags.zero = false;
                        this.flags.plus = true;
                        return this.padNum("Inf", false);
                    }
                    if (n === Number.NEGATIVE_INFINITY) {
                        this.flags.zero = false;
                        return this.padNum("Inf", true);
                    }
                    return "";
                }
                roundFractionToPrecision(fractional, precision) {
                    if (fractional.length > precision) {
                        fractional = "1" + fractional;
                        let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
                        tmp = Math.round(tmp);
                        fractional = Math.floor(tmp).toString();
                        fractional = fractional.substr(1);
                    }
                    else {
                        while (fractional.length < precision) {
                            fractional += "0";
                        }
                    }
                    return fractional;
                }
                fmtFloatE(n, upcase = false) {
                    const special = this.fmtFloatSpecial(n);
                    if (special !== "") {
                        return special;
                    }
                    const m = n.toExponential().match(FLOAT_REGEXP);
                    if (!m) {
                        throw Error("can't happen, bug");
                    }
                    let fractional = m[F.fractional];
                    const precision = this.flags.precision !== -1
                        ? this.flags.precision
                        : DEFAULT_PRECISION;
                    fractional = this.roundFractionToPrecision(fractional, precision);
                    let e = m[F.exponent];
                    e = e.length == 1 ? "0" + e : e;
                    const val = `${m[F.mantissa]}.${fractional}${upcase ? "E" : "e"}${m[F.esign]}${e}`;
                    return this.padNum(val, n < 0);
                }
                fmtFloatF(n) {
                    const special = this.fmtFloatSpecial(n);
                    if (special !== "") {
                        return special;
                    }
                    function expandNumber(n) {
                        if (Number.isSafeInteger(n)) {
                            return n.toString() + ".";
                        }
                        const t = n.toExponential().split("e");
                        let m = t[0].replace(".", "");
                        const e = parseInt(t[1]);
                        if (e < 0) {
                            let nStr = "0.";
                            for (let i = 0; i !== Math.abs(e) - 1; ++i) {
                                nStr += "0";
                            }
                            return (nStr += m);
                        }
                        else {
                            const splIdx = e + 1;
                            while (m.length < splIdx) {
                                m += "0";
                            }
                            return m.substr(0, splIdx) + "." + m.substr(splIdx);
                        }
                    }
                    const val = expandNumber(Math.abs(n));
                    const arr = val.split(".");
                    const dig = arr[0];
                    let fractional = arr[1];
                    const precision = this.flags.precision !== -1
                        ? this.flags.precision
                        : DEFAULT_PRECISION;
                    fractional = this.roundFractionToPrecision(fractional, precision);
                    return this.padNum(`${dig}.${fractional}`, n < 0);
                }
                fmtFloatG(n, upcase = false) {
                    const special = this.fmtFloatSpecial(n);
                    if (special !== "") {
                        return special;
                    }
                    let P = this.flags.precision !== -1
                        ? this.flags.precision
                        : DEFAULT_PRECISION;
                    P = P === 0 ? 1 : P;
                    const m = n.toExponential().match(FLOAT_REGEXP);
                    if (!m) {
                        throw Error("can't happen");
                    }
                    const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
                    let nStr = "";
                    if (P > X && X >= -4) {
                        this.flags.precision = P - (X + 1);
                        nStr = this.fmtFloatF(n);
                        if (!this.flags.sharp) {
                            nStr = nStr.replace(/\.?0*$/, "");
                        }
                    }
                    else {
                        this.flags.precision = P - 1;
                        nStr = this.fmtFloatE(n);
                        if (!this.flags.sharp) {
                            nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
                        }
                    }
                    return nStr;
                }
                fmtString(s) {
                    if (this.flags.precision !== -1) {
                        s = s.substr(0, this.flags.precision);
                    }
                    return this.pad(s);
                }
                fmtHex(val, upper = false) {
                    switch (typeof val) {
                        case "number":
                            return this.fmtNumber(val, 16, upper);
                        case "string": {
                            const sharp = this.flags.sharp && val.length !== 0;
                            let hex = sharp ? "0x" : "";
                            const prec = this.flags.precision;
                            const end = prec !== -1 ? min(prec, val.length) : val.length;
                            for (let i = 0; i !== end; ++i) {
                                if (i !== 0 && this.flags.space) {
                                    hex += sharp ? " 0x" : " ";
                                }
                                const c = (val.charCodeAt(i) & 0xff).toString(16);
                                hex += c.length === 1 ? `0${c}` : c;
                            }
                            if (upper) {
                                hex = hex.toUpperCase();
                            }
                            return this.pad(hex);
                        }
                        default:
                            throw new Error("currently only number and string are implemented for hex");
                    }
                }
                fmtV(val) {
                    if (this.flags.sharp) {
                        const options = this.flags.precision !== -1
                            ? { depth: this.flags.precision }
                            : {};
                        return this.pad(Deno.inspect(val, options));
                    }
                    else {
                        const p = this.flags.precision;
                        return p === -1 ? val.toString() : val.toString().substr(0, p);
                    }
                }
                fmtJ(val) {
                    return JSON.stringify(val);
                }
            };
        }
    };
});
;
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            global.moment = factory();
}(window || this, (function () {
    'use strict';
    var hookCallback;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }
    function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        }
        else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }
    function isUndefined(input) {
        return input === void 0;
    }
    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    }
    else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;
            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    var updateInProgress = false;
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        }
        else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !== 'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2);
                    }
                    else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }
    function set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            }
            else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                }
                else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                }
                else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    }
    else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }
    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({ unit: u, priority: priorities[u] });
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            }
            else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match3to4 = /\d\d\d\d?/;
    var match5to6 = /\d\d\d\d\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;
    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addUnitPriority('year', 1);
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            }
            else {
                return get(this, unit);
            }
        };
    }
    function get(mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        }
        else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    function mod(n, x) {
        return ((n % x) + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    }
    else {
        indexOf = function (o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }
    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addUnitPriority('month', 8);
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        }
        else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
            else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
        else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
            else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            }
            else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            }
            else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            }
            else {
                value = mom.localeData().monthsParse(value);
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        }
        else {
            return get(this, 'Month');
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            }
            else {
                return this._monthsShortRegex;
            }
        }
        else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    var defaultMonthsRegex = matchWord;
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            }
            else {
                return this._monthsRegex;
            }
        }
        else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        }
        else {
            date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
    }
    function createUTCDate(y) {
        var date;
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        }
        else {
            date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        }
        else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        }
        else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        }
        else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        }
        else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        }
        else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
            else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
            else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
        else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
            else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
            else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            }
            else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            }
            else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            }
            else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        }
        else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        }
        else {
            return this.day() || 7;
        }
    }
    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            }
            else {
                return this._weekdaysRegex;
            }
        }
        else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            }
            else {
                return this._weekdaysShortRegex;
            }
        }
        else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }
    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            }
            else {
                return this._weekdaysMinRegex;
            }
        }
        else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    addUnitPriority('hour', 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        }
        else {
            return isLower ? 'am' : 'AM';
        }
    }
    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {};
    var localeFamilies = {};
    var globalLocale;
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            }
            catch (e) { }
        }
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            }
            else {
                if ((typeof console !== 'undefined') && console.warn) {
                    console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                }
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            }
            else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                }
                else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    }
                    else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }
            getSetGlobalLocale(name);
            return locales[name];
        }
        else {
            delete locales[name];
            return null;
        }
    }
    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
            getSetGlobalLocale(name);
        }
        else {
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                }
                else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                    a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                        a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                            a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                    a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }
        if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        }
        else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            var curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            }
            else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            }
            else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        }
        else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        }
        else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                }
                else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        }
        else {
            config._isValid = false;
        }
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
        return result;
    }
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        }
        else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        }
        else if (militaryOffset) {
            return 0;
        }
        else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
        }
        else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        }
        else {
            return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        }
        else {
            return;
        }
        hooks.createFromInputFallback(config);
    }
    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });
    hooks.ISO_8601 = function () { };
    hooks.RFC_2822 = function () { };
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        }
        else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        }
        else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, 'd');
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }
        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        }
        else if (isDate(input)) {
            config._d = input;
        }
        else if (isArray(format)) {
            configFromStringAndArray(config);
        }
        else if (format) {
            configFromStringAndFormat(config);
        }
        else {
            configFromInput(config);
        }
        if (!isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        }
        else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        }
        else if (typeof input === 'string') {
            configFromString(config);
        }
        else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        }
        else if (isObject(input)) {
            configFromObject(config);
        }
        else if (isNumber(input)) {
            config._d = new Date(input);
        }
        else {
            hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }
        if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        }
        else {
            return createInvalid();
        }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        }
        else {
            return createInvalid();
        }
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
    }
    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };
    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }
        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
        return true;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds +
            seconds * 1e3 +
            minutes * 6e4 +
            hours * 1000 * 60 * 60;
        this._days = +days +
            weeks * 7;
        this._months = +months +
            quarters * 3 +
            years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        }
        else {
            return Math.round(number);
        }
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);
        if (matches === null) {
            return null;
        }
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ?
            0 :
            parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        }
        else {
            return createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    hooks.updateOffset = function () { };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            }
            else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                }
                else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        }
        else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        }
        else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        }
        else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return (this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset());
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        }
        else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        }
        else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            }
            else {
                duration.milliseconds = input;
            }
        }
        else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign
            };
        }
        else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        }
        else if (duration == null) {
            duration = {};
        }
        else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }
        return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        }
        else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                    'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                        diff < 2 ? 'nextDay' :
                            diff < 7 ? 'nextWeek' : 'sameElse';
    }
    function calendar$1(time, formats) {
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf('day'), format = hooks.calendarFormat(this, sod) || 'sameElse';
        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        }
        else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        }
        else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        }
        else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break;
            case 'minute':
                output = (this - that) / 6e4;
                break;
            case 'hour':
                output = (this - that) / 36e5;
                break;
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break;
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break;
            default: output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            adjust = (b - anchor) / (anchor - anchor2);
        }
        else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
                return this.toDate().toISOString();
            }
            else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        }
        else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        }
        else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        }
        else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
            return this.localeData();
        }
        else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        }
        else {
            return new Date(y, m, d).valueOf();
        }
    }
    function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        }
        else {
            return Date.UTC(y, m, d);
        }
    }
    function startOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function endOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function valueOf() {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }
    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        }
        else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken('Q', 0, 'Qo', 'quarter');
    addUnitAlias('quarter', 'Q');
    addUnitPriority('quarter', 7);
    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addUnitPriority('date', 9);
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ?
            (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
            locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addUnitPriority('dayOfYear', 4);
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addUnitPriority('minute', 14);
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addUnitPriority('second', 15);
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });
    addUnitAlias('millisecond', 'ms');
    addUnitPriority('millisecond', 16);
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
    function createUnix(input) {
        return createLocal(input * 1000);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }
        format = format || '';
        if (index != null) {
            return get$1(format, index, field, 'month');
        }
        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        }
        else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        }
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }
        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }
    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10, output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                    (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });
    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;
    function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        }
        else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month': return months;
                case 'quarter': return months / 3;
                case 'year': return months / 12;
            }
        }
        else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week': return days / 7 + milliseconds / 6048e5;
                case 'day': return days + milliseconds / 864e5;
                case 'hour': return days * 24 + milliseconds / 36e5;
                case 'minute': return days * 1440 + milliseconds / 6e4;
                case 'second': return days * 86400 + milliseconds / 1000;
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6);
    }
    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');
    function clone$1() {
        return createDuration(this);
    }
    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }
    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));
        var a = seconds <= thresholds.ss && ['s', seconds] ||
            seconds < thresholds.s && ['ss', seconds] ||
            minutes <= 1 && ['m'] ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours <= 1 && ['h'] ||
            hours < thresholds.h && ['hh', hours] ||
            days <= 1 && ['d'] ||
            days < thresholds.d && ['dd', days] ||
            months <= 1 && ['M'] ||
            months < thresholds.M && ['MM', months] ||
            years <= 1 && ['y'] || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof (roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    function humanize(withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1000;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();
        if (!total) {
            return 'P0D';
        }
        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });
    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        DATE: 'YYYY-MM-DD',
        TIME: 'HH:mm',
        TIME_SECONDS: 'HH:mm:ss',
        TIME_MS: 'HH:mm:ss.SSS',
        WEEK: 'GGGG-[W]WW',
        MONTH: 'YYYY-MM'
    };
    return hooks;
})));
System.register("https://raw.githubusercontent.com/denjucks/organ/master/deps/deno_moment/moment", ["https://raw.githubusercontent.com/denjucks/organ/master/deps/deno_moment/vendor/moment"], function (exports_111, context_111) {
    "use strict";
    var moment;
    var __moduleName = context_111 && context_111.id;
    return {
        setters: [
            function (_1) {
            }
        ],
        execute: function () {
            moment = window.moment;
            exports_111("moment", moment);
        }
    };
});
System.register("https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/deps/safe-buffer/deps/jspm-core/nodelibs/buffer", [], function (exports_112, context_112) {
    "use strict";
    var r, t, e, n, o, a, h, a$1, e$1, n$1, i, o$1, j, Y, Buffer, INSPECT_MAX_BYTES, kMaxLength;
    var __moduleName = context_112 && context_112.id;
    function u(r) { var t = r.length; if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4"); var e = r.indexOf("="); return -1 === e && (e = t), [e, e === t ? 0 : 4 - e % 4]; }
    function c(r, e, n) { for (var o, a, h = [], u = e; u < n; u += 3)
        o = (r[u] << 16 & 16711680) + (r[u + 1] << 8 & 65280) + (255 & r[u + 2]), h.push(t[(a = o) >> 18 & 63] + t[a >> 12 & 63] + t[a >> 6 & 63] + t[63 & a]); return h.join(""); }
    function f(t) { if (t > 2147483647)
        throw new RangeError('The value "' + t + '" is invalid for option "size"'); var r = new Uint8Array(t); return Object.setPrototypeOf(r, u$1.prototype), r; }
    function u$1(t, r, e) { if ("number" == typeof t) {
        if ("string" == typeof r)
            throw new TypeError('The "string" argument must be of type string. Received type number');
        return a$2(t);
    } return s(t, r, e); }
    function s(t, r, e) { if ("string" == typeof t)
        return function (t, r) { "string" == typeof r && "" !== r || (r = "utf8"); if (!u$1.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r); var e = 0 | y(t, r), n = f(e), i = n.write(t, r); i !== e && (n = n.slice(0, i)); return n; }(t, r); if (ArrayBuffer.isView(t))
        return p(t); if (null == t)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (F(t, ArrayBuffer) || t && F(t.buffer, ArrayBuffer))
        return c$1(t, r, e); if ("undefined" != typeof SharedArrayBuffer && (F(t, SharedArrayBuffer) || t && F(t.buffer, SharedArrayBuffer)))
        return c$1(t, r, e); if ("number" == typeof t)
        throw new TypeError('The "value" argument must not be of type number. Received type number'); var n = t.valueOf && t.valueOf(); if (null != n && n !== t)
        return u$1.from(n, r, e); var i = function (t) { if (u$1.isBuffer(t)) {
        var r = 0 | l(t.length), e = f(r);
        return 0 === e.length || t.copy(e, 0, 0, r), e;
    } if (void 0 !== t.length)
        return "number" != typeof t.length || N(t.length) ? f(0) : p(t); if ("Buffer" === t.type && Array.isArray(t.data))
        return p(t.data); }(t); if (i)
        return i; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
        return u$1.from(t[Symbol.toPrimitive]("string"), r, e); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); }
    function h$1(t) { if ("number" != typeof t)
        throw new TypeError('"size" argument must be of type number'); if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"'); }
    function a$2(t) { return h$1(t), f(t < 0 ? 0 : 0 | l(t)); }
    function p(t) { for (var r = t.length < 0 ? 0 : 0 | l(t.length), e = f(r), n = 0; n < r; n += 1)
        e[n] = 255 & t[n]; return e; }
    function c$1(t, r, e) { if (r < 0 || t.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < r + (e || 0))
        throw new RangeError('"length" is outside of buffer bounds'); var n; return n = void 0 === r && void 0 === e ? new Uint8Array(t) : void 0 === e ? new Uint8Array(t, r) : new Uint8Array(t, r, e), Object.setPrototypeOf(n, u$1.prototype), n; }
    function l(t) { if (t >= 2147483647)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes"); return 0 | t; }
    function y(t, r) { if (u$1.isBuffer(t))
        return t.length; if (ArrayBuffer.isView(t) || F(t, ArrayBuffer))
        return t.byteLength; if ("string" != typeof t)
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); var e = t.length, n = arguments.length > 2 && !0 === arguments[2]; if (!n && 0 === e)
        return 0; for (var i = !1;;)
        switch (r) {
            case "ascii":
            case "latin1":
            case "binary": return e;
            case "utf8":
            case "utf-8": return _(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le": return 2 * e;
            case "hex": return e >>> 1;
            case "base64": return z(t).length;
            default:
                if (i)
                    return n ? -1 : _(t).length;
                r = ("" + r).toLowerCase(), i = !0;
        } }
    function g(t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length)
        return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0)
        return ""; if ((e >>>= 0) <= (r >>>= 0))
        return ""; for (t || (t = "utf8");;)
        switch (t) {
            case "hex": return O(this, r, e);
            case "utf8":
            case "utf-8": return I(this, r, e);
            case "ascii": return S(this, r, e);
            case "latin1":
            case "binary": return R(this, r, e);
            case "base64": return T(this, r, e);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le": return L(this, r, e);
            default:
                if (n)
                    throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(), n = !0;
        } }
    function w(t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n; }
    function d(t, r, e, n, i) { if (0 === t.length)
        return -1; if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), N(e = +e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
        if (i)
            return -1;
        e = t.length - 1;
    }
    else if (e < 0) {
        if (!i)
            return -1;
        e = 0;
    } if ("string" == typeof r && (r = u$1.from(r, n)), u$1.isBuffer(r))
        return 0 === r.length ? -1 : v(t, r, e, n, i); if ("number" == typeof r)
        return r &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : v(t, [r], e, n, i); throw new TypeError("val must be string, number or Buffer"); }
    function v(t, r, e, n, i) { var o, f = 1, u = t.length, s = r.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
        if (t.length < 2 || r.length < 2)
            return -1;
        f = 2, u /= 2, s /= 2, e /= 2;
    } function h(t, r) { return 1 === f ? t[r] : t.readUInt16BE(r * f); } if (i) {
        var a = -1;
        for (o = e; o < u; o++)
            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                if (-1 === a && (a = o), o - a + 1 === s)
                    return a * f;
            }
            else
                -1 !== a && (o -= o - a), a = -1;
    }
    else
        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
            for (var p = !0, c = 0; c < s; c++)
                if (h(t, o + c) !== h(r, c)) {
                    p = !1;
                    break;
                }
            if (p)
                return o;
        } return -1; }
    function b(t, r, e, n) { e = Number(e) || 0; var i = t.length - e; n ? (n = Number(n)) > i && (n = i) : n = i; var o = r.length; n > o / 2 && (n = o / 2); for (var f = 0; f < n; ++f) {
        var u = parseInt(r.substr(2 * f, 2), 16);
        if (N(u))
            return f;
        t[e + f] = u;
    } return f; }
    function m(t, r, e, n) { return D(_(r, t.length - e), t, e, n); }
    function E(t, r, e, n) { return D(function (t) { for (var r = [], e = 0; e < t.length; ++e)
        r.push(255 & t.charCodeAt(e)); return r; }(r), t, e, n); }
    function B(t, r, e, n) { return E(t, r, e, n); }
    function A(t, r, e, n) { return D(z(r), t, e, n); }
    function U(t, r, e, n) { return D(function (t, r) { for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f)
        e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n); return o; }(r, t.length - e), t, e, n); }
    function T(t, r, e) { return 0 === r && e === t.length ? n$1.fromByteArray(t) : n$1.fromByteArray(t.slice(r, e)); }
    function I(t, r, e) { e = Math.min(t.length, e); for (var n = [], i = r; i < e;) {
        var o, f, u, s, h = t[i], a = null, p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
        if (i + p <= e)
            switch (p) {
                case 1:
                    h < 128 && (a = h);
                    break;
                case 2:
                    128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                    break;
                case 3:
                    o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                    break;
                case 4: o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s);
            }
        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p;
    } return function (t) { var r = t.length; if (r <= 4096)
        return String.fromCharCode.apply(String, t); var e = "", n = 0; for (; n < r;)
        e += String.fromCharCode.apply(String, t.slice(n, n += 4096)); return e; }(n); }
    function S(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)
        n += String.fromCharCode(127 & t[i]); return n; }
    function R(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)
        n += String.fromCharCode(t[i]); return n; }
    function O(t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var i = "", o = r; o < e; ++o)
        i += Y[t[o]]; return i; }
    function L(t, r, e) { for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2)
        i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i; }
    function x(t, r, e) { if (t % 1 != 0 || t < 0)
        throw new RangeError("offset is not uint"); if (t + r > e)
        throw new RangeError("Trying to access beyond buffer length"); }
    function C(t, r, e, n, i, o) { if (!u$1.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance'); if (r > i || r < o)
        throw new RangeError('"value" argument is out of bounds'); if (e + n > t.length)
        throw new RangeError("Index out of range"); }
    function P(t, r, e, n, i, o) { if (e + n > t.length)
        throw new RangeError("Index out of range"); if (e < 0)
        throw new RangeError("Index out of range"); }
    function k(t, r, e, n, o) { return r = +r, e >>>= 0, o || P(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4; }
    function M(t, r, e, n, o) { return r = +r, e >>>= 0, o || P(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8; }
    function _(t, r) { var e; r = r || 1 / 0; for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
            if (!i) {
                if (e > 56319) {
                    (r -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                if (f + 1 === n) {
                    (r -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                i = e;
                continue;
            }
            if (e < 56320) {
                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                continue;
            }
            e = 65536 + (i - 55296 << 10 | e - 56320);
        }
        else
            i && (r -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, e < 128) {
            if ((r -= 1) < 0)
                break;
            o.push(e);
        }
        else if (e < 2048) {
            if ((r -= 2) < 0)
                break;
            o.push(e >> 6 | 192, 63 & e | 128);
        }
        else if (e < 65536) {
            if ((r -= 3) < 0)
                break;
            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128);
        }
        else {
            if (!(e < 1114112))
                throw new Error("Invalid code point");
            if ((r -= 4) < 0)
                break;
            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128);
        }
    } return o; }
    function z(t) { return n$1.toByteArray(function (t) { if ((t = (t = t.split("=")[0]).trim().replace(j, "")).length < 2)
        return ""; for (; t.length % 4 != 0;)
        t += "="; return t; }(t)); }
    function D(t, r, e, n) { for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)
        r[i + e] = t[i]; return i; }
    function F(t, r) { return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name; }
    function N(t) { return t != t; }
    return {
        setters: [],
        execute: function () {
            for (r = { byteLength: function (r) { var t = u(r), e = t[0], n = t[1]; return 3 * (e + n) / 4 - n; }, toByteArray: function (r) { var t, o, a = u(r), h = a[0], c = a[1], d = new n(function (r, t, e) { return 3 * (t + e) / 4 - e; }(0, h, c)), f = 0, A = c > 0 ? h - 4 : h; for (o = 0; o < A; o += 4)
                    t = e[r.charCodeAt(o)] << 18 | e[r.charCodeAt(o + 1)] << 12 | e[r.charCodeAt(o + 2)] << 6 | e[r.charCodeAt(o + 3)], d[f++] = t >> 16 & 255, d[f++] = t >> 8 & 255, d[f++] = 255 & t; 2 === c && (t = e[r.charCodeAt(o)] << 2 | e[r.charCodeAt(o + 1)] >> 4, d[f++] = 255 & t); 1 === c && (t = e[r.charCodeAt(o)] << 10 | e[r.charCodeAt(o + 1)] << 4 | e[r.charCodeAt(o + 2)] >> 2, d[f++] = t >> 8 & 255, d[f++] = 255 & t); return d; }, fromByteArray: function (r) { for (var e, n = r.length, o = n % 3, a = [], h = 0, u = n - o; h < u; h += 16383)
                    a.push(c(r, h, h + 16383 > u ? u : h + 16383)); 1 === o ? (e = r[n - 1], a.push(t[e >> 2] + t[e << 4 & 63] + "==")) : 2 === o && (e = (r[n - 2] << 8) + r[n - 1], a.push(t[e >> 10] + t[e >> 4 & 63] + t[e << 2 & 63] + "=")); return a.join(""); } }, t = [], e = [], n = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, h = o.length; a < h; ++a)
                t[a] = o[a], e[o.charCodeAt(a)] = a;
            e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63;
            a$1 = { read: function (a, t, o, r, h) { var M, f, p = 8 * h - r - 1, w = (1 << p) - 1, e = w >> 1, i = -7, N = o ? h - 1 : 0, n = o ? -1 : 1, u = a[t + N]; for (N += n, M = u & (1 << -i) - 1, u >>= -i, i += p; i > 0; M = 256 * M + a[t + N], N += n, i -= 8)
                    ; for (f = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; f = 256 * f + a[t + N], N += n, i -= 8)
                    ; if (0 === M)
                    M = 1 - e;
                else {
                    if (M === w)
                        return f ? NaN : 1 / 0 * (u ? -1 : 1);
                    f += Math.pow(2, r), M -= e;
                } return (u ? -1 : 1) * f * Math.pow(2, M - r); }, write: function (a, t, o, r, h, M) { var f, p, w, e = 8 * M - h - 1, i = (1 << e) - 1, N = i >> 1, n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u = r ? 0 : M - 1, l = r ? 1 : -1, s = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (p = isNaN(t) ? 1 : 0, f = i) : (f = Math.floor(Math.log(t) / Math.LN2), t * (w = Math.pow(2, -f)) < 1 && (f--, w *= 2), (t += f + N >= 1 ? n / w : n * Math.pow(2, 1 - N)) * w >= 2 && (f++, w /= 2), f + N >= i ? (p = 0, f = i) : f + N >= 1 ? (p = (t * w - 1) * Math.pow(2, h), f += N) : (p = t * Math.pow(2, N - 1) * Math.pow(2, h), f = 0)); h >= 8; a[o + u] = 255 & p, u += l, p /= 256, h -= 8)
                    ; for (f = f << h | p, e += h; e > 0; a[o + u] = 255 & f, u += l, f /= 256, e -= 8)
                    ; a[o + u - l] |= 128 * s; } };
            e$1 = {}, n$1 = r, i = a$1, o$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            e$1.Buffer = u$1, e$1.SlowBuffer = function (t) { +t != t && (t = 0); return u$1.alloc(+t); }, e$1.INSPECT_MAX_BYTES = 50;
            e$1.kMaxLength = 2147483647, u$1.TYPED_ARRAY_SUPPORT = function () { try {
                var t = new Uint8Array(1), r = { foo: function () { return 42; } };
                return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(t, r), 42 === t.foo();
            }
            catch (t) {
                return !1;
            } }(), u$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1.prototype, "parent", { enumerable: !0, get: function () { if (u$1.isBuffer(this))
                    return this.buffer; } }), Object.defineProperty(u$1.prototype, "offset", { enumerable: !0, get: function () { if (u$1.isBuffer(this))
                    return this.byteOffset; } }), u$1.poolSize = 8192, u$1.from = function (t, r, e) { return s(t, r, e); }, Object.setPrototypeOf(u$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1, Uint8Array), u$1.alloc = function (t, r, e) { return function (t, r, e) { return h$1(t), t <= 0 ? f(t) : void 0 !== r ? "string" == typeof e ? f(t).fill(r, e) : f(t).fill(r) : f(t); }(t, r, e); }, u$1.allocUnsafe = function (t) { return a$2(t); }, u$1.allocUnsafeSlow = function (t) { return a$2(t); }, u$1.isBuffer = function (t) { return null != t && !0 === t._isBuffer && t !== u$1.prototype; }, u$1.compare = function (t, r) { if (F(t, Uint8Array) && (t = u$1.from(t, t.offset, t.byteLength)), F(r, Uint8Array) && (r = u$1.from(r, r.offset, r.byteLength)), !u$1.isBuffer(t) || !u$1.isBuffer(r))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (t === r)
                return 0; for (var e = t.length, n = r.length, i = 0, o = Math.min(e, n); i < o; ++i)
                if (t[i] !== r[i]) {
                    e = t[i], n = r[i];
                    break;
                } return e < n ? -1 : n < e ? 1 : 0; }, u$1.isEncoding = function (t) { switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return !0;
                default: return !1;
            } }, u$1.concat = function (t, r) { if (!Array.isArray(t))
                throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length)
                return u$1.alloc(0); var e; if (void 0 === r)
                for (r = 0, e = 0; e < t.length; ++e)
                    r += t[e].length; var n = u$1.allocUnsafe(r), i = 0; for (e = 0; e < t.length; ++e) {
                var o = t[e];
                if (F(o, Uint8Array) && (o = u$1.from(o)), !u$1.isBuffer(o))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                o.copy(n, i), i += o.length;
            } return n; }, u$1.byteLength = y, u$1.prototype._isBuffer = !0, u$1.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2)
                w(this, r, r + 1); return this; }, u$1.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4)
                w(this, r, r + 3), w(this, r + 1, r + 2); return this; }, u$1.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8)
                w(this, r, r + 7), w(this, r + 1, r + 6), w(this, r + 2, r + 5), w(this, r + 3, r + 4); return this; }, u$1.prototype.toString = function () { var t = this.length; return 0 === t ? "" : 0 === arguments.length ? I(this, 0, t) : g.apply(this, arguments); }, u$1.prototype.toLocaleString = u$1.prototype.toString, u$1.prototype.equals = function (t) { if (!u$1.isBuffer(t))
                throw new TypeError("Argument must be a Buffer"); return this === t || 0 === u$1.compare(this, t); }, u$1.prototype.inspect = function () { var t = "", r = e$1.INSPECT_MAX_BYTES; return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"; }, o$1 && (u$1.prototype[o$1] = u$1.prototype.inspect), u$1.prototype.compare = function (t, r, e, n, i) { if (F(t, Uint8Array) && (t = u$1.from(t, t.offset, t.byteLength)), !u$1.isBuffer(t))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t); if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length)
                throw new RangeError("out of range index"); if (n >= i && r >= e)
                return 0; if (n >= i)
                return -1; if (r >= e)
                return 1; if (this === t)
                return 0; for (var o = (i >>>= 0) - (n >>>= 0), f = (e >>>= 0) - (r >>>= 0), s = Math.min(o, f), h = this.slice(n, i), a = t.slice(r, e), p = 0; p < s; ++p)
                if (h[p] !== a[p]) {
                    o = h[p], f = a[p];
                    break;
                } return o < f ? -1 : f < o ? 1 : 0; }, u$1.prototype.includes = function (t, r, e) { return -1 !== this.indexOf(t, r, e); }, u$1.prototype.indexOf = function (t, r, e) { return d(this, t, r, e, !0); }, u$1.prototype.lastIndexOf = function (t, r, e) { return d(this, t, r, e, !1); }, u$1.prototype.write = function (t, r, e, n) { if (void 0 === r)
                n = "utf8", e = this.length, r = 0;
            else if (void 0 === e && "string" == typeof r)
                n = r, e = this.length, r = 0;
            else {
                if (!isFinite(r))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0);
            } var i = this.length - r; if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length)
                throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1;;)
                switch (n) {
                    case "hex": return b(this, t, r, e);
                    case "utf8":
                    case "utf-8": return m(this, t, r, e);
                    case "ascii": return E(this, t, r, e);
                    case "latin1":
                    case "binary": return B(this, t, r, e);
                    case "base64": return A(this, t, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return U(this, t, r, e);
                    default:
                        if (o)
                            throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), o = !0;
                } }, u$1.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; };
            u$1.prototype.slice = function (t, r) { var e = this.length; (t = ~~t) < 0 ? (t += e) < 0 && (t = 0) : t > e && (t = e), (r = void 0 === r ? e : ~~r) < 0 ? (r += e) < 0 && (r = 0) : r > e && (r = e), r < t && (r = t); var n = this.subarray(t, r); return Object.setPrototypeOf(n, u$1.prototype), n; }, u$1.prototype.readUIntLE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
                n += this[t + o] * i; return n; }, u$1.prototype.readUIntBE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);)
                n += this[t + --r] * i; return n; }, u$1.prototype.readUInt8 = function (t, r) { return t >>>= 0, r || x(t, 1, this.length), this[t]; }, u$1.prototype.readUInt16LE = function (t, r) { return t >>>= 0, r || x(t, 2, this.length), this[t] | this[t + 1] << 8; }, u$1.prototype.readUInt16BE = function (t, r) { return t >>>= 0, r || x(t, 2, this.length), this[t] << 8 | this[t + 1]; }, u$1.prototype.readUInt32LE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]; }, u$1.prototype.readUInt32BE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]); }, u$1.prototype.readIntLE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
                n += this[t + o] * i; return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n; }, u$1.prototype.readIntBE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)
                o += this[t + --n] * i; return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o; }, u$1.prototype.readInt8 = function (t, r) { return t >>>= 0, r || x(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]; }, u$1.prototype.readInt16LE = function (t, r) { t >>>= 0, r || x(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e; }, u$1.prototype.readInt16BE = function (t, r) { t >>>= 0, r || x(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e; }, u$1.prototype.readInt32LE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24; }, u$1.prototype.readInt32BE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]; }, u$1.prototype.readFloatLE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), i.read(this, t, !0, 23, 4); }, u$1.prototype.readFloatBE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), i.read(this, t, !1, 23, 4); }, u$1.prototype.readDoubleLE = function (t, r) { return t >>>= 0, r || x(t, 8, this.length), i.read(this, t, !0, 52, 8); }, u$1.prototype.readDoubleBE = function (t, r) { return t >>>= 0, r || x(t, 8, this.length), i.read(this, t, !1, 52, 8); }, u$1.prototype.writeUIntLE = function (t, r, e, n) { (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = 1, o = 0; for (this[r] = 255 & t; ++o < e && (i *= 256);)
                this[r + o] = t / i & 255; return r + e; }, u$1.prototype.writeUIntBE = function (t, r, e, n) { (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = e - 1, o = 1; for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);)
                this[r + i] = t / o & 255; return r + e; }, u$1.prototype.writeUInt8 = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1; }, u$1.prototype.writeUInt16LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2; }, u$1.prototype.writeUInt16BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2; }, u$1.prototype.writeUInt32LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4; }, u$1.prototype.writeUInt32BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4; }, u$1.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r >>>= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                C(this, t, r, e, i - 1, -i);
            } var o = 0, f = 1, u = 0; for (this[r] = 255 & t; ++o < e && (f *= 256);)
                t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e; }, u$1.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r >>>= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                C(this, t, r, e, i - 1, -i);
            } var o = e - 1, f = 1, u = 0; for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);)
                t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e; }, u$1.prototype.writeInt8 = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1; }, u$1.prototype.writeInt16LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2; }, u$1.prototype.writeInt16BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2; }, u$1.prototype.writeInt32LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4; }, u$1.prototype.writeInt32BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4; }, u$1.prototype.writeFloatLE = function (t, r, e) { return k(this, t, r, !0, e); }, u$1.prototype.writeFloatBE = function (t, r, e) { return k(this, t, r, !1, e); }, u$1.prototype.writeDoubleLE = function (t, r, e) { return M(this, t, r, !0, e); }, u$1.prototype.writeDoubleBE = function (t, r, e) { return M(this, t, r, !1, e); }, u$1.prototype.copy = function (t, r, e, n) { if (!u$1.isBuffer(t))
                throw new TypeError("argument should be a Buffer"); if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e)
                return 0; if (0 === t.length || 0 === this.length)
                return 0; if (r < 0)
                throw new RangeError("targetStart out of bounds"); if (e < 0 || e >= this.length)
                throw new RangeError("Index out of range"); if (n < 0)
                throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e); var i = n - e; if (this === t && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(r, e, n);
            else if (this === t && e < r && r < n)
                for (var o = i - 1; o >= 0; --o)
                    t[o + r] = this[o + e];
            else
                Uint8Array.prototype.set.call(t, this.subarray(e, n), r); return i; }, u$1.prototype.fill = function (t, r, e, n) { if ("string" == typeof t) {
                if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), void 0 !== n && "string" != typeof n)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !u$1.isEncoding(n))
                    throw new TypeError("Unknown encoding: " + n);
                if (1 === t.length) {
                    var i = t.charCodeAt(0);
                    ("utf8" === n && i < 128 || "latin1" === n) && (t = i);
                }
            }
            else
                "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t)); if (r < 0 || this.length < r || this.length < e)
                throw new RangeError("Out of range index"); if (e <= r)
                return this; var o; if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t)
                for (o = r; o < e; ++o)
                    this[o] = t;
            else {
                var f = u$1.isBuffer(t) ? t : u$1.from(t, n), s = f.length;
                if (0 === s)
                    throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                for (o = 0; o < e - r; ++o)
                    this[o + r] = f[o % s];
            } return this; };
            j = /[^+/0-9A-Za-z-_]/g;
            Y = function () { for (var t = new Array(256), r = 0; r < 16; ++r)
                for (var e = 16 * r, n = 0; n < 16; ++n)
                    t[e + n] = "0123456789abcdef"[r] + "0123456789abcdef"[n]; return t; }();
            Buffer = e$1.Buffer;
            exports_112("Buffer", Buffer);
            INSPECT_MAX_BYTES = e$1.INSPECT_MAX_BYTES;
            exports_112("INSPECT_MAX_BYTES", INSPECT_MAX_BYTES);
            kMaxLength = e$1.kMaxLength;
            exports_112("kMaxLength", kMaxLength);
            exports_112("default", e$1);
        }
    };
});
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
System.register("https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/deps/safe-buffer/index", ["https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/deps/safe-buffer/deps/jspm-core/nodelibs/buffer"], function (exports_113, context_113) {
    "use strict";
    var buffer_js_1, Buffer, exports;
    var __moduleName = context_113 && context_113.id;
    function copyProps(src, dst) {
        for (var key in src) {
            dst[key] = src[key];
        }
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
    }
    return {
        setters: [
            function (buffer_js_1_1) {
                buffer_js_1 = buffer_js_1_1;
            }
        ],
        execute: function () {
            Buffer = buffer_js_1.default.Buffer;
            if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                exports = buffer_js_1.default;
            }
            else {
                copyProps(buffer_js_1.default, exports);
                exports.Buffer = SafeBuffer;
            }
            SafeBuffer.prototype = Object.create(Buffer.prototype);
            copyProps(Buffer, SafeBuffer);
            SafeBuffer.from = function (arg, encodingOrOffset, length) {
                if (typeof arg === 'number') {
                    throw new TypeError('Argument must not be a number');
                }
                return Buffer(arg, encodingOrOffset, length);
            };
            SafeBuffer.alloc = function (size, fill, encoding) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                var buf = Buffer(size);
                if (fill !== undefined) {
                    if (typeof encoding === 'string') {
                        buf.fill(fill, encoding);
                    }
                    else {
                        buf.fill(fill);
                    }
                }
                else {
                    buf.fill(0);
                }
                return buf;
            };
            SafeBuffer.allocUnsafe = function (size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return Buffer(size);
            };
            SafeBuffer.allocUnsafeSlow = function (size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return buffer_js_1.default.SlowBuffer(size);
            };
            exports_113("default", exports);
        }
    };
});
/*!
 * basic-auth
 * Copyright(c) 2013 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * Copyright(c) 2020 Anthony Mancini
 * MIT Licensed
 */
System.register("https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/index", ["https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/deps/safe-buffer/index"], function (exports_114, context_114) {
    'use strict';
    var index_js_1, Buffer, CREDENTIALS_REGEXP, USER_PASS_REGEXP;
    var __moduleName = context_114 && context_114.id;
    function auth(req) {
        if (!req) {
            throw new TypeError('argument req is required');
        }
        if (typeof req !== 'object') {
            throw new TypeError('argument req is required to be an object');
        }
        var header = getAuthorization(req);
        return parse(header);
    }
    exports_114("auth", auth);
    function decodeBase64(str) {
        return Buffer.from(str, 'base64').toString();
    }
    function getAuthorization(req) {
        if (!req.headers || typeof req.headers !== 'object') {
            throw new TypeError('argument req is required to have headers property');
        }
        return req.headers.get("authorization");
    }
    function parse(string) {
        if (typeof string !== 'string') {
            return undefined;
        }
        var match = CREDENTIALS_REGEXP.exec(string);
        if (!match) {
            return undefined;
        }
        var userPass = USER_PASS_REGEXP.exec(decodeBase64(match[1]));
        if (!userPass) {
            return undefined;
        }
        return new Credentials(userPass[1], userPass[2]);
    }
    function Credentials(name, pass) {
        this.name = name;
        this.pass = pass;
    }
    return {
        setters: [
            function (index_js_1_1) {
                index_js_1 = index_js_1_1;
            }
        ],
        execute: function () {
            Buffer = index_js_1.default.Buffer;
            CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/;
            USER_PASS_REGEXP = /^([^:]*):(.*)$/;
        }
    };
});
System.register("https://raw.githubusercontent.com/denjucks/organ/master/deps/std/fmt/colors", [], function (exports_115, context_115) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_115 && context_115.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_115("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_115("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_115("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_115("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_115("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_115("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_115("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_115("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_115("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_115("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_115("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_115("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_115("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_115("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_115("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_115("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_115("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_115("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_115("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_115("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_115("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_115("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_115("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_115("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_115("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_115("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_115("bgWhite", bgWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_115("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_115("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_115("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_115("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_115("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://raw.githubusercontent.com/denjucks/organ/master/mod", ["https://raw.githubusercontent.com/denjucks/organ/master/deps/deno_moment/moment", "https://raw.githubusercontent.com/denjucks/organ/master/deps/basic-auth/index", "https://raw.githubusercontent.com/denjucks/organ/master/deps/std/fmt/colors"], function (exports_116, context_116) {
    "use strict";
    var moment_ts_1, index_js_2, colors, Logger, Organ;
    var __moduleName = context_116 && context_116.id;
    function organ(format, debug) {
        format = format || "combined";
        return async (context, next) => {
            const startTime = Date.now();
            await next();
            const millisecondsElapsed = Date.now() - startTime;
            context.response.headers.set('X-Response-Time', millisecondsElapsed);
            Organ.log(format, context.request.serverRequest, context.response, debug);
        };
    }
    exports_116("organ", organ);
    return {
        setters: [
            function (moment_ts_1_1) {
                moment_ts_1 = moment_ts_1_1;
            },
            function (index_js_2_1) {
                index_js_2 = index_js_2_1;
            },
            function (colors_1) {
                colors = colors_1;
            }
        ],
        execute: function () {
            Logger = class Logger {
                constructor(request, response, debug) {
                    this._request = request;
                    this._response = response;
                    this._debug = debug;
                }
                date(format) {
                    const currentDate = moment_ts_1.moment().utc();
                    let formattedDate;
                    switch (format) {
                        case "clf":
                            formattedDate = currentDate.format("DD/MMM/YYYY:HH:mm:ss Z");
                            break;
                        case "iso":
                            formattedDate = currentDate.toISOString();
                            break;
                        case "web":
                            formattedDate = currentDate.toDate().toUTCString();
                            break;
                    }
                    if (formattedDate) {
                        return formattedDate;
                    }
                    else {
                        throw new Error("Date format not found, use either [clr, iso, web]");
                    }
                }
                httpVersion() {
                    let httpVersionString = this._request.proto.split("HTTP/")[1];
                    return httpVersionString;
                }
                method() {
                    let methodString = this._request.method;
                    if (this._debug) {
                        methodString = colors.bold(methodString);
                    }
                    return methodString;
                }
                referrer() {
                    let referrerString = this._request.headers.get("Referer") || "-";
                    if (this._debug) {
                        referrerString = colors.italic(referrerString);
                    }
                    return referrerString;
                }
                remoteAddress() {
                    let remoteAddressString = this._request.conn.remoteAddr.hostname;
                    return remoteAddressString;
                }
                remoteUser() {
                    const credentials = index_js_2.auth(this._request);
                    return credentials ? credentials.name : "-";
                }
                request(header) {
                    let requestHeaderString = this._request.headers.get(header) || "-";
                    return requestHeaderString;
                }
                response(header) {
                    let responseHeaderString = this._response.headers.get(header) || "-";
                    return responseHeaderString;
                }
                responseTime(digits) {
                    digits = digits || 3;
                    let responseTimeString = Number.parseFloat(this._response.headers.get("X-Response-Time")).toFixed(digits);
                    if (this._debug) {
                        responseTimeString = colors.magenta(responseTimeString);
                    }
                    return responseTimeString;
                }
                status() {
                    let statusString = this._response.status || "-";
                    statusString = new String(statusString);
                    if (this._debug) {
                        switch (statusString[0]) {
                            case "2":
                                statusString = colors.green(statusString);
                                break;
                            case "3":
                                statusString = colors.cyan(statusString);
                                break;
                            case "4":
                                statusString = colors.yellow(statusString);
                                break;
                            case "5":
                                statusString = colors.red(statusString);
                                break;
                        }
                    }
                    return statusString;
                }
                url() {
                    let urlString = this._request.url;
                    if (this._debug) {
                        urlString = colors.gray(urlString);
                    }
                    return urlString;
                }
                userAgent() {
                    let userAgent = this._request.headers.get("User-Agent");
                    return userAgent;
                }
            };
            exports_116("Logger", Logger);
            Organ = class Organ {
                static string(tokenString, request, response, debug) {
                    if (tokenString === "debug") {
                        debug = true;
                    }
                    const PREDEFINED_FORMATS = {
                        combined: `:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :response[content-length] ":referrer" ":user-agent"`,
                        common: `:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :response[content-length]`,
                        dev: `:method :url :status :response-time ms - :response[content-length]`,
                        short: `:remote-addr :remote-user :method :url HTTP/:http-version :status :response[content-length] - :response-time ms`,
                        tiny: `:method :url :status :response[content-length] - :response-time ms`,
                        debug: `METHOD:         :method\nURL:            :url\nSTATUS:         :status\nDATE:           :date[web]\nRESPONSE_TIME:  :response-time ms\nCONTENT_LENGTH: :response[content-length]\nHTTP_VERSION:   :http-version\nREMOTE_ADDR:    :remote-addr\nREMOTE_USER:    :remote-user\nREFERER:        :referrer\nUSER_AGENT:     :user-agent\n`
                    };
                    if (Object.keys(PREDEFINED_FORMATS).includes(tokenString)) {
                        tokenString = PREDEFINED_FORMATS[tokenString];
                    }
                    const logger = new Logger(request, response, debug);
                    let tokenSet = new Set(tokenString.match(/[:][a-z\-]*(\[[a-zA-Z0-9\-]*\]){0,1}/gm));
                    let tokenMap = new Map();
                    for (let token of tokenSet) {
                        if (token.includes("[")) {
                            tokenMap.set(token, [token.split("[")[0], token.split("[")[1].split("]")[0]]);
                        }
                        else {
                            tokenMap.set(token, [token, null]);
                        }
                    }
                    for (let token of new Map(tokenMap)) {
                        switch (token[1][0]) {
                            case ":date":
                                tokenMap.set(token[0], logger.date(token[1][1]));
                                break;
                            case ":http-version":
                                tokenMap.set(token[0], logger.httpVersion());
                                break;
                            case ":method":
                                tokenMap.set(token[0], logger.method());
                                break;
                            case ":referrer":
                                tokenMap.set(token[0], logger.referrer());
                                break;
                            case ":remote-addr":
                                tokenMap.set(token[0], logger.remoteAddress());
                                break;
                            case ":remote-user":
                                tokenMap.set(token[0], logger.remoteUser());
                                break;
                            case ":request":
                                tokenMap.set(token[0], logger.request(token[1][1]));
                                break;
                            case ":response":
                                tokenMap.set(token[0], logger.response(token[1][1]));
                                break;
                            case ":response-time":
                                tokenMap.set(token[0], logger.responseTime(token[1][1]));
                                break;
                            case ":status":
                                tokenMap.set(token[0], logger.status());
                                break;
                            case ":url":
                                tokenMap.set(token[0], logger.url());
                                break;
                            case ":user-agent":
                                tokenMap.set(token[0], logger.userAgent());
                                break;
                        }
                    }
                    tokenMap.delete(":");
                    for (let token of tokenMap) {
                        tokenString = tokenString.split(token[0]).join(token[1]);
                    }
                    return tokenString;
                }
                static log(tokenString, request, response, debug) {
                    console.log(Organ.string(tokenString, request, response, debug));
                }
            };
            exports_116("Organ", Organ);
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/types", [], function (exports_117, context_117) {
    "use strict";
    var __moduleName = context_117 && context_117.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/upperCase", [], function (exports_118, context_118) {
    "use strict";
    var LANGUAGES;
    var __moduleName = context_118 && context_118.id;
    function default_1(str, locale) {
        str = str == null ? "" : String(str);
        if (!locale) {
            return str.toUpperCase();
        }
        const lang = LANGUAGES[locale];
        if (lang) {
            str = str.replace(lang.regexp, function (m) {
                return lang.map[m];
            });
        }
        return str.toUpperCase();
    }
    exports_118("default", default_1);
    return {
        setters: [],
        execute: function () {
            LANGUAGES = {
                tr: {
                    regexp: /[\u0069]/g,
                    map: {
                        i: "\u0130",
                    },
                },
                az: {
                    regexp: /[\u0069]/g,
                    map: {
                        i: "\u0130",
                    },
                },
                lt: {
                    regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
                    map: {
                        i: "\u0049",
                        j: "\u004A",
                        : "\u012E",
                        i: "\u00CC",
                        i: "\u00CD",
                        i: "\u0128",
                    },
                },
            };
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/lowerCase", [], function (exports_119, context_119) {
    "use strict";
    var LANGUAGES;
    var __moduleName = context_119 && context_119.id;
    function default_2(str, locale) {
        str = str == null ? "" : String(str);
        if (!locale) {
            return str.toLowerCase();
        }
        const lang = LANGUAGES[locale];
        if (lang) {
            str = str.replace(lang.regexp, (m) => lang.map[m]);
        }
        return str.toLowerCase();
    }
    exports_119("default", default_2);
    return {
        setters: [],
        execute: function () {
            LANGUAGES = {
                tr: {
                    regexp: /\u0130|\u0049|\u0049\u0307/g,
                    map: {
                        : "\u0069",
                        I: "\u0131",
                        I: "\u0069",
                    },
                },
                az: {
                    regexp: /[\u0130]/g,
                    map: {
                        : "\u0069",
                        I: "\u0131",
                        I: "\u0069",
                    },
                },
                lt: {
                    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
                    map: {
                        I: "\u0069\u0307",
                        J: "\u006A\u0307",
                        : "\u012F\u0307",
                        : "\u0069\u0307\u0300",
                        : "\u0069\u0307\u0301",
                        : "\u0069\u0307\u0303",
                    },
                },
            };
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/vendor/nonWordRegexp", [], function (exports_120, context_120) {
    "use strict";
    var nonWordRegexp;
    var __moduleName = context_120 && context_120.id;
    return {
        setters: [],
        execute: function () {
            nonWordRegexp = /[^A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g;
            exports_120("default", nonWordRegexp);
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/vendor/camelCaseRegexp", [], function (exports_121, context_121) {
    "use strict";
    var camelCaseRegexp;
    var __moduleName = context_121 && context_121.id;
    return {
        setters: [],
        execute: function () {
            camelCaseRegexp = /([a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])/g;
            exports_121("default", camelCaseRegexp);
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/vendor/camelCaseUpperRegexp", [], function (exports_122, context_122) {
    "use strict";
    var camelCaseUpperRegexp;
    var __moduleName = context_122 && context_122.id;
    return {
        setters: [],
        execute: function () {
            camelCaseUpperRegexp = /([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A][a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])/g;
            exports_122("default", camelCaseUpperRegexp);
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/normalCase", ["https://deno.land/x/case@v2.1.0/lowerCase", "https://deno.land/x/case@v2.1.0/vendor/nonWordRegexp", "https://deno.land/x/case@v2.1.0/vendor/camelCaseRegexp", "https://deno.land/x/case@v2.1.0/vendor/camelCaseUpperRegexp"], function (exports_123, context_123) {
    "use strict";
    var lowerCase_ts_1, nonWordRegexp_ts_1, camelCaseRegexp_ts_1, camelCaseUpperRegexp_ts_1;
    var __moduleName = context_123 && context_123.id;
    function normalCase(str, locale, replacement) {
        if (str == null) {
            return "";
        }
        replacement = typeof replacement !== "string" ? " " : replacement;
        function replace(match, index, value) {
            if (index === 0 || index === value.length - match.length) {
                return "";
            }
            return replacement;
        }
        str = String(str)
            .replace(camelCaseRegexp_ts_1.default, "$1 $2")
            .replace(camelCaseUpperRegexp_ts_1.default, "$1 $2")
            .replace(nonWordRegexp_ts_1.default, replace);
        return lowerCase_ts_1.default(str, locale);
    }
    exports_123("default", normalCase);
    return {
        setters: [
            function (lowerCase_ts_1_1) {
                lowerCase_ts_1 = lowerCase_ts_1_1;
            },
            function (nonWordRegexp_ts_1_1) {
                nonWordRegexp_ts_1 = nonWordRegexp_ts_1_1;
            },
            function (camelCaseRegexp_ts_1_1) {
                camelCaseRegexp_ts_1 = camelCaseRegexp_ts_1_1;
            },
            function (camelCaseUpperRegexp_ts_1_1) {
                camelCaseUpperRegexp_ts_1 = camelCaseUpperRegexp_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/camelCase", ["https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/normalCase"], function (exports_124, context_124) {
    "use strict";
    var upperCase_ts_1, normalCase_ts_1;
    var __moduleName = context_124 && context_124.id;
    function camelCase(value, locale, mergeNumbers) {
        let result = normalCase_ts_1.default(value, locale);
        if (!mergeNumbers) {
            result = result.replace(/ (?=\d)/g, "_");
        }
        return result.replace(/ (.)/g, function (m, $1) {
            return upperCase_ts_1.default($1, locale);
        });
    }
    exports_124("default", camelCase);
    return {
        setters: [
            function (upperCase_ts_1_1) {
                upperCase_ts_1 = upperCase_ts_1_1;
            },
            function (normalCase_ts_1_1) {
                normalCase_ts_1 = normalCase_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/snakeCase", ["https://deno.land/x/case@v2.1.0/normalCase"], function (exports_125, context_125) {
    "use strict";
    var normalCase_ts_2;
    var __moduleName = context_125 && context_125.id;
    function snakeCase(value, locale) {
        return normalCase_ts_2.default(value, locale, "_");
    }
    exports_125("default", snakeCase);
    return {
        setters: [
            function (normalCase_ts_2_1) {
                normalCase_ts_2 = normalCase_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/constantCase", ["https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/snakeCase"], function (exports_126, context_126) {
    "use strict";
    var upperCase_ts_2, snakeCase_ts_1;
    var __moduleName = context_126 && context_126.id;
    function constantCase(value, locale) {
        return upperCase_ts_2.default(snakeCase_ts_1.default(value, locale), locale);
    }
    exports_126("default", constantCase);
    return {
        setters: [
            function (upperCase_ts_2_1) {
                upperCase_ts_2 = upperCase_ts_2_1;
            },
            function (snakeCase_ts_1_1) {
                snakeCase_ts_1 = snakeCase_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/dotCase", ["https://deno.land/x/case@v2.1.0/normalCase"], function (exports_127, context_127) {
    "use strict";
    var normalCase_ts_3;
    var __moduleName = context_127 && context_127.id;
    function dotCase(value, locale) {
        return normalCase_ts_3.default(value, locale, ".");
    }
    exports_127("default", dotCase);
    return {
        setters: [
            function (normalCase_ts_3_1) {
                normalCase_ts_3 = normalCase_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/headerCase", ["https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/normalCase"], function (exports_128, context_128) {
    "use strict";
    var upperCase_ts_3, normalCase_ts_4;
    var __moduleName = context_128 && context_128.id;
    function headerCase(value, locale) {
        return normalCase_ts_4.default(value, locale, "-").replace(/^.|-./g, function (m) {
            return upperCase_ts_3.default(m, locale);
        });
    }
    exports_128("default", headerCase);
    return {
        setters: [
            function (upperCase_ts_3_1) {
                upperCase_ts_3 = upperCase_ts_3_1;
            },
            function (normalCase_ts_4_1) {
                normalCase_ts_4 = normalCase_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/lowerFirstCase", ["https://deno.land/x/case@v2.1.0/lowerCase"], function (exports_129, context_129) {
    "use strict";
    var lowerCase_ts_2;
    var __moduleName = context_129 && context_129.id;
    function default_3(str, locale) {
        if (str == null) {
            return "";
        }
        str = String(str);
        return lowerCase_ts_2.default(str.charAt(0), locale) + str.substr(1);
    }
    exports_129("default", default_3);
    return {
        setters: [
            function (lowerCase_ts_2_1) {
                lowerCase_ts_2 = lowerCase_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/paramCase", ["https://deno.land/x/case@v2.1.0/normalCase"], function (exports_130, context_130) {
    "use strict";
    var normalCase_ts_5;
    var __moduleName = context_130 && context_130.id;
    function paramCase(value, locale) {
        return normalCase_ts_5.default(value, locale, "-");
    }
    exports_130("default", paramCase);
    return {
        setters: [
            function (normalCase_ts_5_1) {
                normalCase_ts_5 = normalCase_ts_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/upperFirstCase", ["https://deno.land/x/case@v2.1.0/upperCase"], function (exports_131, context_131) {
    "use strict";
    var upperCase_ts_4;
    var __moduleName = context_131 && context_131.id;
    function default_4(str, locale) {
        if (str == null) {
            return "";
        }
        str = String(str);
        return upperCase_ts_4.default(str.charAt(0), locale) + str.substr(1);
    }
    exports_131("default", default_4);
    return {
        setters: [
            function (upperCase_ts_4_1) {
                upperCase_ts_4 = upperCase_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/pascalCase", ["https://deno.land/x/case@v2.1.0/camelCase", "https://deno.land/x/case@v2.1.0/upperFirstCase"], function (exports_132, context_132) {
    "use strict";
    var camelCase_ts_1, upperFirstCase_ts_1;
    var __moduleName = context_132 && context_132.id;
    function pascalCase(value, locale, mergeNumbers) {
        return upperFirstCase_ts_1.default(camelCase_ts_1.default(value, locale, mergeNumbers), locale);
    }
    exports_132("default", pascalCase);
    return {
        setters: [
            function (camelCase_ts_1_1) {
                camelCase_ts_1 = camelCase_ts_1_1;
            },
            function (upperFirstCase_ts_1_1) {
                upperFirstCase_ts_1 = upperFirstCase_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/pathCase", ["https://deno.land/x/case@v2.1.0/normalCase"], function (exports_133, context_133) {
    "use strict";
    var normalCase_ts_6;
    var __moduleName = context_133 && context_133.id;
    function default_5(value, locale) {
        return normalCase_ts_6.default(value, locale, "/");
    }
    exports_133("default", default_5);
    return {
        setters: [
            function (normalCase_ts_6_1) {
                normalCase_ts_6 = normalCase_ts_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/sentenceCase", ["https://deno.land/x/case@v2.1.0/normalCase", "https://deno.land/x/case@v2.1.0/upperFirstCase"], function (exports_134, context_134) {
    "use strict";
    var normalCase_ts_7, upperFirstCase_ts_2;
    var __moduleName = context_134 && context_134.id;
    function sentenceCase(value, locale) {
        return upperFirstCase_ts_2.default(normalCase_ts_7.default(value, locale), locale);
    }
    exports_134("default", sentenceCase);
    return {
        setters: [
            function (normalCase_ts_7_1) {
                normalCase_ts_7 = normalCase_ts_7_1;
            },
            function (upperFirstCase_ts_2_1) {
                upperFirstCase_ts_2 = upperFirstCase_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/swapCase", ["https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/lowerCase"], function (exports_135, context_135) {
    "use strict";
    var upperCase_ts_5, lowerCase_ts_3;
    var __moduleName = context_135 && context_135.id;
    function default_6(str, locale) {
        if (str == null) {
            return "";
        }
        let result = "";
        for (let i = 0; i < str.length; i++) {
            const c = str[i];
            const u = upperCase_ts_5.default(c, locale);
            result += u === c ? lowerCase_ts_3.default(c, locale) : u;
        }
        return result;
    }
    exports_135("default", default_6);
    return {
        setters: [
            function (upperCase_ts_5_1) {
                upperCase_ts_5 = upperCase_ts_5_1;
            },
            function (lowerCase_ts_3_1) {
                lowerCase_ts_3 = lowerCase_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/titleCase", ["https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/normalCase"], function (exports_136, context_136) {
    "use strict";
    var upperCase_ts_6, normalCase_ts_8;
    var __moduleName = context_136 && context_136.id;
    function titleCase(value, locale) {
        return normalCase_ts_8.default(value, locale).replace(/^.| ./g, function (m) {
            return upperCase_ts_6.default(m, locale);
        });
    }
    exports_136("default", titleCase);
    return {
        setters: [
            function (upperCase_ts_6_1) {
                upperCase_ts_6 = upperCase_ts_6_1;
            },
            function (normalCase_ts_8_1) {
                normalCase_ts_8 = normalCase_ts_8_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/case@v2.1.0/mod", ["https://deno.land/x/case@v2.1.0/camelCase", "https://deno.land/x/case@v2.1.0/constantCase", "https://deno.land/x/case@v2.1.0/dotCase", "https://deno.land/x/case@v2.1.0/headerCase", "https://deno.land/x/case@v2.1.0/lowerCase", "https://deno.land/x/case@v2.1.0/lowerFirstCase", "https://deno.land/x/case@v2.1.0/normalCase", "https://deno.land/x/case@v2.1.0/paramCase", "https://deno.land/x/case@v2.1.0/pascalCase", "https://deno.land/x/case@v2.1.0/pathCase", "https://deno.land/x/case@v2.1.0/sentenceCase", "https://deno.land/x/case@v2.1.0/snakeCase", "https://deno.land/x/case@v2.1.0/swapCase", "https://deno.land/x/case@v2.1.0/titleCase", "https://deno.land/x/case@v2.1.0/upperCase", "https://deno.land/x/case@v2.1.0/upperFirstCase"], function (exports_137, context_137) {
    "use strict";
    var __moduleName = context_137 && context_137.id;
    return {
        setters: [
            function (camelCase_ts_2_1) {
                exports_137({
                    "camelCase": camelCase_ts_2_1["default"]
                });
            },
            function (constantCase_ts_1_1) {
                exports_137({
                    "constantCase": constantCase_ts_1_1["default"]
                });
            },
            function (dotCase_ts_1_1) {
                exports_137({
                    "dotCase": dotCase_ts_1_1["default"]
                });
            },
            function (headerCase_ts_1_1) {
                exports_137({
                    "headerCase": headerCase_ts_1_1["default"]
                });
            },
            function (lowerCase_ts_4_1) {
                exports_137({
                    "lowerCase": lowerCase_ts_4_1["default"]
                });
            },
            function (lowerFirstCase_ts_1_1) {
                exports_137({
                    "lowerFirstCase": lowerFirstCase_ts_1_1["default"]
                });
            },
            function (normalCase_ts_9_1) {
                exports_137({
                    "normalCase": normalCase_ts_9_1["default"]
                });
            },
            function (paramCase_ts_1_1) {
                exports_137({
                    "paramCase": paramCase_ts_1_1["default"]
                });
            },
            function (pascalCase_ts_1_1) {
                exports_137({
                    "pascalCase": pascalCase_ts_1_1["default"]
                });
            },
            function (pathCase_ts_1_1) {
                exports_137({
                    "pathCase": pathCase_ts_1_1["default"]
                });
            },
            function (sentenceCase_ts_1_1) {
                exports_137({
                    "sentenceCase": sentenceCase_ts_1_1["default"]
                });
            },
            function (snakeCase_ts_2_1) {
                exports_137({
                    "snakeCase": snakeCase_ts_2_1["default"]
                });
            },
            function (swapCase_ts_1_1) {
                exports_137({
                    "swapCase": swapCase_ts_1_1["default"]
                });
            },
            function (titleCase_ts_1_1) {
                exports_137({
                    "titleCase": titleCase_ts_1_1["default"]
                });
            },
            function (upperCase_ts_7_1) {
                exports_137({
                    "upperCase": upperCase_ts_7_1["default"]
                });
            },
            function (upperFirstCase_ts_3_1) {
                exports_137({
                    "upperFirstCase": upperFirstCase_ts_3_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.68.0/bytes/mod", [], function (exports_138, context_138) {
    "use strict";
    var __moduleName = context_138 && context_138.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_138("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_138("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_138("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_138("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_138("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_138("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_138("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_138("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_138("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.68.0/_util/assert", [], function (exports_139, context_139) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_139 && context_139.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_139("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_139("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.68.0/io/bufio", ["https://deno.land/std@0.68.0/bytes/mod", "https://deno.land/std@0.68.0/_util/assert"], function (exports_140, context_140) {
    "use strict";
    var mod_ts_19, assert_ts_9, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_140 && context_140.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_140("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_140("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_140("readLines", readLines);
    return {
        setters: [
            function (mod_ts_19_1) {
                mod_ts_19 = mod_ts_19_1;
            },
            function (assert_ts_9_1) {
                assert_ts_9 = assert_ts_9_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_140("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_140("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_9.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_9.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_9.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_19.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_9.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_9.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_140("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_19.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_19.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_140("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_19.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_19.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_140("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.68.0/encoding/utf8", [], function (exports_141, context_141) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_141 && context_141.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_141("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_141("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_141("encoder", encoder = new TextEncoder());
            exports_141("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.68.0/textproto/mod", ["https://deno.land/std@0.68.0/bytes/mod", "https://deno.land/std@0.68.0/encoding/utf8"], function (exports_142, context_142) {
    "use strict";
    var mod_ts_20, utf8_ts_6, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_142 && context_142.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_6.decode(buf);
        }
    }
    function charCode(s) {
        return s.charCodeAt(0);
    }
    return {
        setters: [
            function (mod_ts_20_1) {
                mod_ts_20 = mod_ts_20_1;
            },
            function (utf8_ts_6_1) {
                utf8_ts_6 = utf8_ts_6_1;
            }
        ],
        execute: function () {
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice();
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        let i = kv.indexOf(charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        const key = str(kv.subarray(0, i));
                        if (key == "") {
                            continue;
                        }
                        i++;
                        while (i < kv.byteLength &&
                            (kv[i] == charCode(" ") || kv[i] == charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        try {
                            m.append(key, value);
                        }
                        catch {
                        }
                    }
                }
                async readLineSlice() {
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        if (!line && !more) {
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_20.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === charCode(" ") || l[i] === charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_142("TextProtoReader", TextProtoReader);
        }
    };
});
System.register("https://deno.land/std@0.68.0/io/readers", ["https://deno.land/std@0.68.0/encoding/utf8"], function (exports_143, context_143) {
    "use strict";
    var utf8_ts_7, StringReader, MultiReader, LimitedReader;
    var __moduleName = context_143 && context_143.id;
    return {
        setters: [
            function (utf8_ts_7_1) {
                utf8_ts_7 = utf8_ts_7_1;
            }
        ],
        execute: function () {
            StringReader = class StringReader extends Deno.Buffer {
                constructor(s) {
                    super(utf8_ts_7.encode(s).buffer);
                }
            };
            exports_143("StringReader", StringReader);
            MultiReader = class MultiReader {
                constructor(...readers) {
                    this.currentIndex = 0;
                    this.readers = readers;
                }
                async read(p) {
                    const r = this.readers[this.currentIndex];
                    if (!r)
                        return null;
                    const result = await r.read(p);
                    if (result === null) {
                        this.currentIndex++;
                        return 0;
                    }
                    return result;
                }
            };
            exports_143("MultiReader", MultiReader);
            LimitedReader = class LimitedReader {
                constructor(reader, limit) {
                    this.reader = reader;
                    this.limit = limit;
                }
                async read(p) {
                    if (this.limit <= 0) {
                        return null;
                    }
                    if (p.length > this.limit) {
                        p = p.subarray(0, this.limit);
                    }
                    const n = await this.reader.read(p);
                    if (n == null) {
                        return null;
                    }
                    this.limit -= n;
                    return n;
                }
            };
            exports_143("LimitedReader", LimitedReader);
        }
    };
});
System.register("https://deno.land/std@0.68.0/encoding/csv", ["https://deno.land/std@0.68.0/io/bufio", "https://deno.land/std@0.68.0/textproto/mod", "https://deno.land/std@0.68.0/io/readers", "https://deno.land/std@0.68.0/_util/assert"], function (exports_144, context_144) {
    "use strict";
    var bufio_ts_6, mod_ts_21, readers_ts_1, assert_ts_10, INVALID_RUNE, ERR_BARE_QUOTE, ERR_QUOTE, ERR_INVALID_DELIM, ERR_FIELD_COUNT, ParseError;
    var __moduleName = context_144 && context_144.id;
    function chkOptions(opt) {
        if (!opt.comma) {
            opt.comma = ",";
        }
        if (!opt.trimLeadingSpace) {
            opt.trimLeadingSpace = false;
        }
        if (INVALID_RUNE.includes(opt.comma) ||
            (typeof opt.comment === "string" && INVALID_RUNE.includes(opt.comment)) ||
            opt.comma === opt.comment) {
            throw new Error(ERR_INVALID_DELIM);
        }
    }
    async function readRecord(startLine, reader, opt = { comma: ",", trimLeadingSpace: false }) {
        const tp = new mod_ts_21.TextProtoReader(reader);
        let line = await readLine(tp);
        let lineIndex = startLine + 1;
        if (line === null)
            return null;
        if (line.length === 0) {
            return [];
        }
        if (opt.comment && line[0] === opt.comment) {
            return [];
        }
        assert_ts_10.assert(opt.comma != null);
        let fullLine = line;
        let quoteError = null;
        const quote = '"';
        const quoteLen = quote.length;
        const commaLen = opt.comma.length;
        let recordBuffer = "";
        const fieldIndexes = [];
        parseField: for (;;) {
            if (opt.trimLeadingSpace) {
                line = line.trimLeft();
            }
            if (line.length === 0 || !line.startsWith(quote)) {
                const i = line.indexOf(opt.comma);
                let field = line;
                if (i >= 0) {
                    field = field.substring(0, i);
                }
                if (!opt.lazyQuotes) {
                    const j = field.indexOf(quote);
                    if (j >= 0) {
                        const col = runeCount(fullLine.slice(0, fullLine.length - line.slice(j).length));
                        quoteError = new ParseError(startLine + 1, lineIndex, col, ERR_BARE_QUOTE);
                        break parseField;
                    }
                }
                recordBuffer += field;
                fieldIndexes.push(recordBuffer.length);
                if (i >= 0) {
                    line = line.substring(i + commaLen);
                    continue parseField;
                }
                break parseField;
            }
            else {
                line = line.substring(quoteLen);
                for (;;) {
                    const i = line.indexOf(quote);
                    if (i >= 0) {
                        recordBuffer += line.substring(0, i);
                        line = line.substring(i + quoteLen);
                        if (line.startsWith(quote)) {
                            recordBuffer += quote;
                            line = line.substring(quoteLen);
                        }
                        else if (line.startsWith(opt.comma)) {
                            line = line.substring(commaLen);
                            fieldIndexes.push(recordBuffer.length);
                            continue parseField;
                        }
                        else if (0 === line.length) {
                            fieldIndexes.push(recordBuffer.length);
                            break parseField;
                        }
                        else if (opt.lazyQuotes) {
                            recordBuffer += quote;
                        }
                        else {
                            const col = runeCount(fullLine.slice(0, fullLine.length - line.length - quoteLen));
                            quoteError = new ParseError(startLine + 1, lineIndex, col, ERR_QUOTE);
                            break parseField;
                        }
                    }
                    else if (line.length > 0 || !(await isEOF(tp))) {
                        recordBuffer += line;
                        const r = await readLine(tp);
                        lineIndex++;
                        line = r ?? "";
                        fullLine = line;
                        if (r === null) {
                            if (!opt.lazyQuotes) {
                                const col = runeCount(fullLine);
                                quoteError = new ParseError(startLine + 1, lineIndex, col, ERR_QUOTE);
                                break parseField;
                            }
                            fieldIndexes.push(recordBuffer.length);
                            break parseField;
                        }
                        recordBuffer += "\n";
                    }
                    else {
                        if (!opt.lazyQuotes) {
                            const col = runeCount(fullLine);
                            quoteError = new ParseError(startLine + 1, lineIndex, col, ERR_QUOTE);
                            break parseField;
                        }
                        fieldIndexes.push(recordBuffer.length);
                        break parseField;
                    }
                }
            }
        }
        if (quoteError) {
            throw quoteError;
        }
        const result = [];
        let preIdx = 0;
        for (const i of fieldIndexes) {
            result.push(recordBuffer.slice(preIdx, i));
            preIdx = i;
        }
        return result;
    }
    async function isEOF(tp) {
        return (await tp.r.peek(0)) === null;
    }
    function runeCount(s) {
        return Array.from(s).length;
    }
    async function readLine(tp) {
        let line;
        const r = await tp.readLine();
        if (r === null)
            return null;
        line = r;
        if ((await isEOF(tp)) && line.length > 0 && line[line.length - 1] === "\r") {
            line = line.substring(0, line.length - 1);
        }
        if (line.length >= 2 &&
            line[line.length - 2] === "\r" &&
            line[line.length - 1] === "\n") {
            line = line.substring(0, line.length - 2);
            line = line + "\n";
        }
        return line;
    }
    async function readMatrix(reader, opt = {
        comma: ",",
        trimLeadingSpace: false,
        lazyQuotes: false,
    }) {
        const result = [];
        let _nbFields;
        let lineResult;
        let first = true;
        let lineIndex = 0;
        chkOptions(opt);
        for (;;) {
            const r = await readRecord(lineIndex, reader, opt);
            if (r === null)
                break;
            lineResult = r;
            lineIndex++;
            if (first) {
                first = false;
                if (opt.fieldsPerRecord !== undefined) {
                    if (opt.fieldsPerRecord === 0) {
                        _nbFields = lineResult.length;
                    }
                    else {
                        _nbFields = opt.fieldsPerRecord;
                    }
                }
            }
            if (lineResult.length > 0) {
                if (_nbFields && _nbFields !== lineResult.length) {
                    throw new ParseError(lineIndex, lineIndex, null, ERR_FIELD_COUNT);
                }
                result.push(lineResult);
            }
        }
        return result;
    }
    exports_144("readMatrix", readMatrix);
    async function parse(input, opt = {
        header: false,
    }) {
        let r;
        if (input instanceof bufio_ts_6.BufReader) {
            r = await readMatrix(input, opt);
        }
        else {
            r = await readMatrix(new bufio_ts_6.BufReader(new readers_ts_1.StringReader(input)), opt);
        }
        if (opt.header) {
            let headers = [];
            let i = 0;
            if (Array.isArray(opt.header)) {
                if (typeof opt.header[0] !== "string") {
                    headers = opt.header;
                }
                else {
                    const h = opt.header;
                    headers = h.map((e) => {
                        return {
                            name: e,
                        };
                    });
                }
            }
            else {
                const head = r.shift();
                assert_ts_10.assert(head != null);
                headers = head.map((e) => {
                    return {
                        name: e,
                    };
                });
                i++;
            }
            return r.map((e) => {
                if (e.length !== headers.length) {
                    throw `Error number of fields line:${i}`;
                }
                i++;
                const out = {};
                for (let j = 0; j < e.length; j++) {
                    const h = headers[j];
                    if (h.parse) {
                        out[h.name] = h.parse(e[j]);
                    }
                    else {
                        out[h.name] = e[j];
                    }
                }
                if (opt.parse) {
                    return opt.parse(out);
                }
                return out;
            });
        }
        if (opt.parse) {
            return r.map((e) => {
                assert_ts_10.assert(opt.parse, "opt.parse must be set");
                return opt.parse(e);
            });
        }
        return r;
    }
    exports_144("parse", parse);
    return {
        setters: [
            function (bufio_ts_6_1) {
                bufio_ts_6 = bufio_ts_6_1;
            },
            function (mod_ts_21_1) {
                mod_ts_21 = mod_ts_21_1;
            },
            function (readers_ts_1_1) {
                readers_ts_1 = readers_ts_1_1;
            },
            function (assert_ts_10_1) {
                assert_ts_10 = assert_ts_10_1;
            }
        ],
        execute: function () {
            INVALID_RUNE = ["\r", "\n", '"'];
            exports_144("ERR_BARE_QUOTE", ERR_BARE_QUOTE = 'bare " in non-quoted-field');
            exports_144("ERR_QUOTE", ERR_QUOTE = 'extraneous or missing " in quoted-field');
            exports_144("ERR_INVALID_DELIM", ERR_INVALID_DELIM = "Invalid Delimiter");
            exports_144("ERR_FIELD_COUNT", ERR_FIELD_COUNT = "wrong number of fields");
            ParseError = class ParseError extends Error {
                constructor(start, line, column, message) {
                    super();
                    this.startLine = start;
                    this.column = column;
                    this.line = line;
                    if (message === ERR_FIELD_COUNT) {
                        this.message = `record on line ${line}: ${message}`;
                    }
                    else if (start !== line) {
                        this.message =
                            `record on line ${start}; parse error on line ${line}, column ${column}: ${message}`;
                    }
                    else {
                        this.message =
                            `parse error on line ${line}, column ${column}: ${message}`;
                    }
                }
            };
            exports_144("ParseError", ParseError);
        }
    };
});
System.register("https://deno.land/std@0.61.0/encoding/utf8", [], function (exports_145, context_145) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_145 && context_145.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_145("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_145("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_145("encoder", encoder = new TextEncoder());
            exports_145("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.61.0/bytes/mod", [], function (exports_146, context_146) {
    "use strict";
    var __moduleName = context_146 && context_146.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_146("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_146("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_146("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_146("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_146("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_146("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_146("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_146("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_146("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/_util/assert", [], function (exports_147, context_147) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_147 && context_147.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_147("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_147("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.61.0/io/bufio", ["https://deno.land/std@0.61.0/bytes/mod", "https://deno.land/std@0.61.0/_util/assert"], function (exports_148, context_148) {
    "use strict";
    var mod_ts_22, assert_ts_11, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_148 && context_148.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_148("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_148("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_148("readLines", readLines);
    return {
        setters: [
            function (mod_ts_22_1) {
                mod_ts_22 = mod_ts_22_1;
            },
            function (assert_ts_11_1) {
                assert_ts_11 = assert_ts_11_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_148("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_148("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_11.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_11.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_11.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_22.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_11.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_11.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_148("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_22.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_22.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_148("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_22.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_22.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_148("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.61.0/async/deferred", [], function (exports_149, context_149) {
    "use strict";
    var __moduleName = context_149 && context_149.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_149("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/async/delay", [], function (exports_150, context_150) {
    "use strict";
    var __moduleName = context_150 && context_150.id;
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_150("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/async/mux_async_iterator", ["https://deno.land/std@0.61.0/async/deferred"], function (exports_151, context_151) {
    "use strict";
    var deferred_ts_7, MuxAsyncIterator;
    var __moduleName = context_151 && context_151.id;
    return {
        setters: [
            function (deferred_ts_7_1) {
                deferred_ts_7 = deferred_ts_7_1;
            }
        ],
        execute: function () {
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.throws = [];
                    this.signal = deferred_ts_7.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    try {
                        const { value, done } = await iterator.next();
                        if (done) {
                            --this.iteratorCount;
                        }
                        else {
                            this.yields.push({ iterator, value });
                        }
                    }
                    catch (e) {
                        this.throws.push(e);
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        await this.signal;
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        if (this.throws.length) {
                            for (const e of this.throws) {
                                throw e;
                            }
                            this.throws.length = 0;
                        }
                        this.yields.length = 0;
                        this.signal = deferred_ts_7.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_151("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.61.0/async/mod", ["https://deno.land/std@0.61.0/async/deferred", "https://deno.land/std@0.61.0/async/delay", "https://deno.land/std@0.61.0/async/mux_async_iterator"], function (exports_152, context_152) {
    "use strict";
    var __moduleName = context_152 && context_152.id;
    function exportStar_4(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_152(exports);
    }
    return {
        setters: [
            function (deferred_ts_8_1) {
                exportStar_4(deferred_ts_8_1);
            },
            function (delay_ts_3_1) {
                exportStar_4(delay_ts_3_1);
            },
            function (mux_async_iterator_ts_3_1) {
                exportStar_4(mux_async_iterator_ts_3_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/textproto/mod", ["https://deno.land/std@0.61.0/bytes/mod", "https://deno.land/std@0.61.0/encoding/utf8"], function (exports_153, context_153) {
    "use strict";
    var mod_ts_23, utf8_ts_8, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_153 && context_153.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_8.decode(buf);
        }
    }
    function charCode(s) {
        return s.charCodeAt(0);
    }
    return {
        setters: [
            function (mod_ts_23_1) {
                mod_ts_23 = mod_ts_23_1;
            },
            function (utf8_ts_8_1) {
                utf8_ts_8 = utf8_ts_8_1;
            }
        ],
        execute: function () {
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice();
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        let i = kv.indexOf(charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        const key = str(kv.subarray(0, i));
                        if (key == "") {
                            continue;
                        }
                        i++;
                        while (i < kv.byteLength &&
                            (kv[i] == charCode(" ") || kv[i] == charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        try {
                            m.append(key, value);
                        }
                        catch {
                        }
                    }
                }
                async readLineSlice() {
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        if (!line && !more) {
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_23.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === charCode(" ") || l[i] === charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_153("TextProtoReader", TextProtoReader);
        }
    };
});
System.register("https://deno.land/std@0.61.0/http/http_status", [], function (exports_154, context_154) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_154 && context_154.id;
    return {
        setters: [],
        execute: function () {
            (function (Status) {
                Status[Status["Continue"] = 100] = "Continue";
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                Status[Status["Processing"] = 102] = "Processing";
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                Status[Status["OK"] = 200] = "OK";
                Status[Status["Created"] = 201] = "Created";
                Status[Status["Accepted"] = 202] = "Accepted";
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                Status[Status["NoContent"] = 204] = "NoContent";
                Status[Status["ResetContent"] = 205] = "ResetContent";
                Status[Status["PartialContent"] = 206] = "PartialContent";
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                Status[Status["IMUsed"] = 226] = "IMUsed";
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                Status[Status["Found"] = 302] = "Found";
                Status[Status["SeeOther"] = 303] = "SeeOther";
                Status[Status["NotModified"] = 304] = "NotModified";
                Status[Status["UseProxy"] = 305] = "UseProxy";
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                Status[Status["BadRequest"] = 400] = "BadRequest";
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                Status[Status["Forbidden"] = 403] = "Forbidden";
                Status[Status["NotFound"] = 404] = "NotFound";
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                Status[Status["Conflict"] = 409] = "Conflict";
                Status[Status["Gone"] = 410] = "Gone";
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                Status[Status["Teapot"] = 418] = "Teapot";
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                Status[Status["Locked"] = 423] = "Locked";
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                Status[Status["TooEarly"] = 425] = "TooEarly";
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                Status[Status["BadGateway"] = 502] = "BadGateway";
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                Status[Status["NotExtended"] = 510] = "NotExtended";
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_154("Status", Status);
            exports_154("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.61.0/http/_io", ["https://deno.land/std@0.61.0/io/bufio", "https://deno.land/std@0.61.0/textproto/mod", "https://deno.land/std@0.61.0/_util/assert", "https://deno.land/std@0.61.0/encoding/utf8", "https://deno.land/std@0.61.0/http/server", "https://deno.land/std@0.61.0/http/http_status"], function (exports_155, context_155) {
    "use strict";
    var bufio_ts_7, mod_ts_24, assert_ts_12, utf8_ts_9, server_ts_3, http_status_ts_3;
    var __moduleName = context_155 && context_155.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_155("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_155("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        const tp = new mod_ts_24.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_12.assert(chunkSize === 0);
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_155("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_24.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_155("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_7.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_9.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_9.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_9.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_155("writeChunkedBody", writeChunkedBody);
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_7.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_9.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_9.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_155("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_3.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_7.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_9.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_9.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_12.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_12.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_12.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_12.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_155("writeResponse", writeResponse);
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_155("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_24.TextProtoReader(bufr);
        const firstLine = await tp.readLine();
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_3.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_155("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_7_1) {
                bufio_ts_7 = bufio_ts_7_1;
            },
            function (mod_ts_24_1) {
                mod_ts_24 = mod_ts_24_1;
            },
            function (assert_ts_12_1) {
                assert_ts_12 = assert_ts_12_1;
            },
            function (utf8_ts_9_1) {
                utf8_ts_9 = utf8_ts_9_1;
            },
            function (server_ts_3_1) {
                server_ts_3 = server_ts_3_1;
            },
            function (http_status_ts_3_1) {
                http_status_ts_3 = http_status_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/http/server", ["https://deno.land/std@0.61.0/encoding/utf8", "https://deno.land/std@0.61.0/io/bufio", "https://deno.land/std@0.61.0/_util/assert", "https://deno.land/std@0.61.0/async/mod", "https://deno.land/std@0.61.0/http/_io"], function (exports_156, context_156) {
    "use strict";
    var utf8_ts_10, bufio_ts_8, assert_ts_13, mod_ts_25, _io_ts_3, ServerRequest, Server;
    var __moduleName = context_156 && context_156.id;
    function _parseAddrFromStr(addr) {
        let url;
        try {
            const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
            url = new URL(`http://${host}`);
        }
        catch {
            throw new TypeError("Invalid address.");
        }
        if (url.username ||
            url.password ||
            url.pathname != "/" ||
            url.search ||
            url.hash) {
            throw new TypeError("Invalid address.");
        }
        return {
            hostname: url.hostname,
            port: url.port === "" ? 80 : Number(url.port),
        };
    }
    exports_156("_parseAddrFromStr", _parseAddrFromStr);
    function serve(addr) {
        if (typeof addr === "string") {
            addr = _parseAddrFromStr(addr);
        }
        const listener = Deno.listen(addr);
        return new Server(listener);
    }
    exports_156("serve", serve);
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_156("listenAndServe", listenAndServe);
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = Deno.listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_156("serveTLS", serveTLS);
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_156("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_10_1) {
                utf8_ts_10 = utf8_ts_10_1;
            },
            function (bufio_ts_8_1) {
                bufio_ts_8 = bufio_ts_8_1;
            },
            function (assert_ts_13_1) {
                assert_ts_13 = assert_ts_13_1;
            },
            function (mod_ts_25_1) {
                mod_ts_25 = mod_ts_25_1;
            },
            function (_io_ts_3_1) {
                _io_ts_3 = _io_ts_3_1;
            }
        ],
        execute: function () {
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_25.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                get contentLength() {
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_3.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_13.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_3.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                this._body = _io_ts_3.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        await _io_ts_3.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            this.conn.close();
                        }
                        catch {
                        }
                        err = e;
                    }
                    this.done.resolve(err);
                    if (err) {
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                    }
                    this.finalized = true;
                }
            };
            exports_156("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_8.BufReader(conn);
                    const writer = new bufio_ts_8.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_3.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                await _io_ts_3.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_10.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        const responseError = await request.done;
                        if (responseError) {
                            this.untrackConnection(request.conn);
                            return;
                        }
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_25.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_156("Server", Server);
        }
    };
});
System.register("https://deno.land/std@0.61.0/io/ioutil", ["https://deno.land/std@0.61.0/_util/assert"], function (exports_157, context_157) {
    "use strict";
    var assert_ts_14, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_157 && context_157.id;
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_14.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_157("copyN", copyN);
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_157("readShort", readShort);
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_157("readInt", readInt);
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_157("readLong", readLong);
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_157("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_14_1) {
                assert_ts_14 = assert_ts_14_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
System.register("https://deno.land/std@0.61.0/io/readers", ["https://deno.land/std@0.61.0/encoding/utf8"], function (exports_158, context_158) {
    "use strict";
    var utf8_ts_11, StringReader, MultiReader, LimitedReader;
    var __moduleName = context_158 && context_158.id;
    return {
        setters: [
            function (utf8_ts_11_1) {
                utf8_ts_11 = utf8_ts_11_1;
            }
        ],
        execute: function () {
            StringReader = class StringReader extends Deno.Buffer {
                constructor(s) {
                    super(utf8_ts_11.encode(s).buffer);
                    this.s = s;
                }
            };
            exports_158("StringReader", StringReader);
            MultiReader = class MultiReader {
                constructor(...readers) {
                    this.currentIndex = 0;
                    this.readers = readers;
                }
                async read(p) {
                    const r = this.readers[this.currentIndex];
                    if (!r)
                        return null;
                    const result = await r.read(p);
                    if (result === null) {
                        this.currentIndex++;
                        return 0;
                    }
                    return result;
                }
            };
            exports_158("MultiReader", MultiReader);
            LimitedReader = class LimitedReader {
                constructor(reader, limit) {
                    this.reader = reader;
                    this.limit = limit;
                }
                async read(p) {
                    if (this.limit <= 0) {
                        return null;
                    }
                    if (p.length > this.limit) {
                        p = p.subarray(0, this.limit);
                    }
                    const n = await this.reader.read(p);
                    if (n == null) {
                        return null;
                    }
                    this.limit -= n;
                    return n;
                }
            };
            exports_158("LimitedReader", LimitedReader);
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/_constants", [], function (exports_159, context_159) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, navigator, isWindows;
    var __moduleName = context_159 && context_159.id;
    return {
        setters: [],
        execute: function () {
            exports_159("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65);
            exports_159("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97);
            exports_159("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90);
            exports_159("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122);
            exports_159("CHAR_DOT", CHAR_DOT = 46);
            exports_159("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47);
            exports_159("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92);
            exports_159("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124);
            exports_159("CHAR_COLON", CHAR_COLON = 58);
            exports_159("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63);
            exports_159("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95);
            exports_159("CHAR_LINE_FEED", CHAR_LINE_FEED = 10);
            exports_159("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13);
            exports_159("CHAR_TAB", CHAR_TAB = 9);
            exports_159("CHAR_FORM_FEED", CHAR_FORM_FEED = 12);
            exports_159("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33);
            exports_159("CHAR_HASH", CHAR_HASH = 35);
            exports_159("CHAR_SPACE", CHAR_SPACE = 32);
            exports_159("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160);
            exports_159("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279);
            exports_159("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91);
            exports_159("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93);
            exports_159("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60);
            exports_159("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62);
            exports_159("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123);
            exports_159("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125);
            exports_159("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45);
            exports_159("CHAR_PLUS", CHAR_PLUS = 43);
            exports_159("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34);
            exports_159("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39);
            exports_159("CHAR_PERCENT", CHAR_PERCENT = 37);
            exports_159("CHAR_SEMICOLON", CHAR_SEMICOLON = 59);
            exports_159("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94);
            exports_159("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96);
            exports_159("CHAR_AT", CHAR_AT = 64);
            exports_159("CHAR_AMPERSAND", CHAR_AMPERSAND = 38);
            exports_159("CHAR_EQUAL", CHAR_EQUAL = 61);
            exports_159("CHAR_0", CHAR_0 = 48);
            exports_159("CHAR_9", CHAR_9 = 57);
            navigator = globalThis.navigator;
            isWindows = false;
            exports_159("isWindows", isWindows);
            if (globalThis.Deno != null) {
                exports_159("isWindows", isWindows = Deno.build.os == "windows");
            }
            else if (navigator?.appVersion != null) {
                exports_159("isWindows", isWindows = navigator.appVersion.includes("Win"));
            }
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/_interface", [], function (exports_160, context_160) {
    "use strict";
    var __moduleName = context_160 && context_160.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/_util", ["https://deno.land/std@0.61.0/path/_constants"], function (exports_161, context_161) {
    "use strict";
    var _constants_ts_7;
    var __moduleName = context_161 && context_161.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_161("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_7.CHAR_FORWARD_SLASH;
    }
    exports_161("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_7.CHAR_BACKWARD_SLASH;
    }
    exports_161("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_7.CHAR_LOWERCASE_A && code <= _constants_ts_7.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_7.CHAR_UPPERCASE_A && code <= _constants_ts_7.CHAR_UPPERCASE_Z));
    }
    exports_161("isWindowsDeviceRoot", isWindowsDeviceRoot);
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_7.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_7.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_7.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_7.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_161("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_161("_format", _format);
    return {
        setters: [
            function (_constants_ts_7_1) {
                _constants_ts_7 = _constants_ts_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/win32", ["https://deno.land/std@0.61.0/path/_constants", "https://deno.land/std@0.61.0/path/_util", "https://deno.land/std@0.61.0/_util/assert"], function (exports_162, context_162) {
    "use strict";
    var _constants_ts_8, _util_ts_3, assert_ts_15, sep, delimiter;
    var __moduleName = context_162 && context_162.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_3.assertPath(path);
            const len = path.length;
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len > 1) {
                if (_util_ts_3.isPathSeparator(code)) {
                    isAbsolute = true;
                    if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                        let j = 2;
                        let last = j;
                        for (; j < len; ++j) {
                            if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            last = j;
                            for (; j < len; ++j) {
                                if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                last = j;
                                for (; j < len; ++j) {
                                    if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                    if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        resolvedTail = _util_ts_3.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_3.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_162("resolve", resolve);
    function normalize(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                isAbsolute = true;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_3.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_3.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_3.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_162("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_3.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_3.isWindowsDeviceRoot(code)) {
            if (len > 2 && path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                if (_util_ts_3.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_162("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_3.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_15.assert(firstPart != null);
        if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_3.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_3.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_162("join", join);
    function relative(from, to) {
        _util_ts_3.assertPath(from);
        _util_ts_3.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_8.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_8.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_162("relative", relative);
    function toNamespacedPath(path) {
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_8.CHAR_QUESTION_MARK && code !== _constants_ts_8.CHAR_DOT) {
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_162("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_3.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = offset = 1;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return path;
                            }
                            if (j !== last) {
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_3.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_162("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_3.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_3.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_3.isPathSeparator(code)) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_3.isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_162("basename", basename);
    function extname(path) {
        _util_ts_3.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
            _util_ts_3.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_3.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_162("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_3._format("\\", pathObject);
    }
    exports_162("format", format);
    function parse(path) {
        _util_ts_3.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_3.isPathSeparator(code)) {
                rootEnd = 1;
                if (_util_ts_3.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_3.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_3.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_3.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_3.isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_3.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_162("parse", parse);
    function fromFileUrl(url) {
        return new URL(String(url)).pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\");
    }
    exports_162("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_8_1) {
                _constants_ts_8 = _constants_ts_8_1;
            },
            function (_util_ts_3_1) {
                _util_ts_3 = _util_ts_3_1;
            },
            function (assert_ts_15_1) {
                assert_ts_15 = assert_ts_15_1;
            }
        ],
        execute: function () {
            exports_162("sep", sep = "\\");
            exports_162("delimiter", delimiter = ";");
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/posix", ["https://deno.land/std@0.61.0/path/_constants", "https://deno.land/std@0.61.0/path/_util"], function (exports_163, context_163) {
    "use strict";
    var _constants_ts_9, _util_ts_4, sep, delimiter;
    var __moduleName = context_163 && context_163.id;
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_4.assertPath(path);
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        }
        resolvedPath = _util_ts_4.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_4.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_163("resolve", resolve);
    function normalize(path) {
        _util_ts_4.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_9.CHAR_FORWARD_SLASH;
        path = _util_ts_4.normalizeString(path, !isAbsolute, "/", _util_ts_4.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_163("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_4.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
    }
    exports_163("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_4.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_163("join", join);
    function relative(from, to) {
        _util_ts_4.assertPath(from);
        _util_ts_4.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_9.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_9.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_163("relative", relative);
    function toNamespacedPath(path) {
        return path;
    }
    exports_163("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_4.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_163("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_4.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_163("basename", basename);
    function extname(path) {
        _util_ts_4.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_163("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_4._format("/", pathObject);
    }
    exports_163("format", format);
    function parse(path) {
        _util_ts_4.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_163("parse", parse);
    function fromFileUrl(url) {
        return new URL(String(url)).pathname;
    }
    exports_163("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_9_1) {
                _constants_ts_9 = _constants_ts_9_1;
            },
            function (_util_ts_4_1) {
                _util_ts_4 = _util_ts_4_1;
            }
        ],
        execute: function () {
            exports_163("sep", sep = "/");
            exports_163("delimiter", delimiter = ":");
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/separator", ["https://deno.land/std@0.61.0/path/_constants"], function (exports_164, context_164) {
    "use strict";
    var _constants_ts_10, SEP, SEP_PATTERN;
    var __moduleName = context_164 && context_164.id;
    return {
        setters: [
            function (_constants_ts_10_1) {
                _constants_ts_10 = _constants_ts_10_1;
            }
        ],
        execute: function () {
            exports_164("SEP", SEP = _constants_ts_10.isWindows ? "\\" : "/");
            exports_164("SEP_PATTERN", SEP_PATTERN = _constants_ts_10.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/common", ["https://deno.land/std@0.61.0/path/separator"], function (exports_165, context_165) {
    "use strict";
    var separator_ts_4;
    var __moduleName = context_165 && context_165.id;
    function common(paths, sep = separator_ts_4.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_165("common", common);
    return {
        setters: [
            function (separator_ts_4_1) {
                separator_ts_4 = separator_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/_globrex", ["https://deno.land/std@0.61.0/path/_constants"], function (exports_166, context_166) {
    "use strict";
    var _constants_ts_11, SEP, SEP_ESC, SEP_RAW, GLOBSTAR, WILDCARD, GLOBSTAR_SEGMENT, WILDCARD_SEGMENT;
    var __moduleName = context_166 && context_166.id;
    function globrex(glob, { extended = false, globstar = false, strict = false, filepath = false, flags = "", } = {}) {
        const sepPattern = new RegExp(`^${SEP}${strict ? "" : "+"}$`);
        let regex = "";
        let segment = "";
        let pathRegexStr = "";
        const pathSegments = [];
        let inGroup = false;
        let inRange = false;
        const ext = [];
        function add(str, options = { split: false, last: false, only: "" }) {
            const { split, last, only } = options;
            if (only !== "path")
                regex += str;
            if (filepath && only !== "regex") {
                pathRegexStr += str.match(sepPattern) ? SEP : str;
                if (split) {
                    if (last)
                        segment += str;
                    if (segment !== "") {
                        if (!flags.includes("g"))
                            segment = `^${segment}$`;
                        pathSegments.push(new RegExp(segment, flags));
                    }
                    segment = "";
                }
                else {
                    segment += str;
                }
            }
        }
        let c, n;
        for (let i = 0; i < glob.length; i++) {
            c = glob[i];
            n = glob[i + 1];
            if (["\\", "$", "^", ".", "="].includes(c)) {
                add(`\\${c}`);
                continue;
            }
            if (c.match(sepPattern)) {
                add(SEP, { split: true });
                if (n != null && n.match(sepPattern) && !strict)
                    regex += "?";
                continue;
            }
            if (c === "(") {
                if (ext.length) {
                    add(`${c}?:`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ")") {
                if (ext.length) {
                    add(c);
                    const type = ext.pop();
                    if (type === "@") {
                        add("{1}");
                    }
                    else if (type === "!") {
                        add(WILDCARD);
                    }
                    else {
                        add(type);
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "|") {
                if (ext.length) {
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "+") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "@" && extended) {
                if (n === "(") {
                    ext.push(c);
                    continue;
                }
            }
            if (c === "!") {
                if (extended) {
                    if (inRange) {
                        add("^");
                        continue;
                    }
                    if (n === "(") {
                        ext.push(c);
                        add("(?!");
                        i++;
                        continue;
                    }
                    add(`\\${c}`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "?") {
                if (extended) {
                    if (n === "(") {
                        ext.push(c);
                    }
                    else {
                        add(".");
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "[") {
                if (inRange && n === ":") {
                    i++;
                    let value = "";
                    while (glob[++i] !== ":")
                        value += glob[i];
                    if (value === "alnum")
                        add("(?:\\w|\\d)");
                    else if (value === "space")
                        add("\\s");
                    else if (value === "digit")
                        add("\\d");
                    i++;
                    continue;
                }
                if (extended) {
                    inRange = true;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "]") {
                if (extended) {
                    inRange = false;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "{") {
                if (extended) {
                    inGroup = true;
                    add("(?:");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "}") {
                if (extended) {
                    inGroup = false;
                    add(")");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ",") {
                if (inGroup) {
                    add("|");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "*") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                const prevChar = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === "*") {
                    starCount++;
                    i++;
                }
                const nextChar = glob[i + 1];
                if (!globstar) {
                    add(".*");
                }
                else {
                    const isGlobstar = starCount > 1 &&
                        [SEP_RAW, "/", undefined].includes(prevChar) &&
                        [SEP_RAW, "/", undefined].includes(nextChar);
                    if (isGlobstar) {
                        add(GLOBSTAR, { only: "regex" });
                        add(GLOBSTAR_SEGMENT, { only: "path", last: true, split: true });
                        i++;
                    }
                    else {
                        add(WILDCARD, { only: "regex" });
                        add(WILDCARD_SEGMENT, { only: "path" });
                    }
                }
                continue;
            }
            add(c);
        }
        if (!flags.includes("g")) {
            regex = `^${regex}$`;
            segment = `^${segment}$`;
            if (filepath)
                pathRegexStr = `^${pathRegexStr}$`;
        }
        const result = { regex: new RegExp(regex, flags) };
        if (filepath) {
            pathSegments.push(new RegExp(segment, flags));
            result.path = {
                regex: new RegExp(pathRegexStr, flags),
                segments: pathSegments,
                globstar: new RegExp(!flags.includes("g") ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags),
            };
        }
        return result;
    }
    exports_166("globrex", globrex);
    return {
        setters: [
            function (_constants_ts_11_1) {
                _constants_ts_11 = _constants_ts_11_1;
            }
        ],
        execute: function () {
            SEP = _constants_ts_11.isWindows ? `(?:\\\\|\\/)` : `\\/`;
            SEP_ESC = _constants_ts_11.isWindows ? `\\\\` : `/`;
            SEP_RAW = _constants_ts_11.isWindows ? `\\` : `/`;
            GLOBSTAR = `(?:(?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD = `(?:[^${SEP_ESC}/]*)`;
            GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD_SEGMENT = `(?:[^${SEP_ESC}/]*)`;
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/glob", ["https://deno.land/std@0.61.0/path/separator", "https://deno.land/std@0.61.0/path/_globrex", "https://deno.land/std@0.61.0/path/mod", "https://deno.land/std@0.61.0/_util/assert"], function (exports_167, context_167) {
    "use strict";
    var separator_ts_5, _globrex_ts_1, mod_ts_26, assert_ts_16;
    var __moduleName = context_167 && context_167.id;
    function globToRegExp(glob, { extended = false, globstar = true } = {}) {
        const result = _globrex_ts_1.globrex(glob, {
            extended,
            globstar,
            strict: false,
            filepath: true,
        });
        assert_ts_16.assert(result.path != null);
        return result.path.regex;
    }
    exports_167("globToRegExp", globToRegExp);
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_167("isGlob", isGlob);
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_26.normalize(glob);
        }
        const s = separator_ts_5.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_26.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_167("normalizeGlob", normalizeGlob);
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_26.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_5.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_167("joinGlobs", joinGlobs);
    return {
        setters: [
            function (separator_ts_5_1) {
                separator_ts_5 = separator_ts_5_1;
            },
            function (_globrex_ts_1_1) {
                _globrex_ts_1 = _globrex_ts_1_1;
            },
            function (mod_ts_26_1) {
                mod_ts_26 = mod_ts_26_1;
            },
            function (assert_ts_16_1) {
                assert_ts_16 = assert_ts_16_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/path/mod", ["https://deno.land/std@0.61.0/path/_constants", "https://deno.land/std@0.61.0/path/win32", "https://deno.land/std@0.61.0/path/posix", "https://deno.land/std@0.61.0/path/common", "https://deno.land/std@0.61.0/path/separator", "https://deno.land/std@0.61.0/path/_interface", "https://deno.land/std@0.61.0/path/glob"], function (exports_168, context_168) {
    "use strict";
    var _constants_ts_12, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_168 && context_168.id;
    var exportedNames_2 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_5(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_2.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_168(exports);
    }
    return {
        setters: [
            function (_constants_ts_12_1) {
                _constants_ts_12 = _constants_ts_12_1;
            },
            function (_win32_2) {
                _win32 = _win32_2;
            },
            function (_posix_2) {
                _posix = _posix_2;
            },
            function (common_ts_6_1) {
                exportStar_5(common_ts_6_1);
            },
            function (separator_ts_6_1) {
                exports_168({
                    "SEP": separator_ts_6_1["SEP"],
                    "SEP_PATTERN": separator_ts_6_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_2_1) {
                exportStar_5(_interface_ts_2_1);
            },
            function (glob_ts_2_1) {
                exportStar_5(glob_ts_2_1);
            }
        ],
        execute: function () {
            path = _constants_ts_12.isWindows ? _win32 : _posix;
            exports_168("win32", win32 = _win32);
            exports_168("posix", posix = _posix);
            exports_168("basename", basename = path.basename), exports_168("delimiter", delimiter = path.delimiter), exports_168("dirname", dirname = path.dirname), exports_168("extname", extname = path.extname), exports_168("format", format = path.format), exports_168("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_168("isAbsolute", isAbsolute = path.isAbsolute), exports_168("join", join = path.join), exports_168("normalize", normalize = path.normalize), exports_168("parse", parse = path.parse), exports_168("relative", relative = path.relative), exports_168("resolve", resolve = path.resolve), exports_168("sep", sep = path.sep), exports_168("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.61.0/io/util", ["https://deno.land/std@0.61.0/path/mod"], function (exports_169, context_169) {
    "use strict";
    var path;
    var __moduleName = context_169 && context_169.id;
    function charCode(s) {
        return s.charCodeAt(0);
    }
    exports_169("charCode", charCode);
    async function tempFile(dir, opts = { prefix: "", postfix: "" }) {
        const r = Math.floor(Math.random() * 1000000);
        const filepath = path.resolve(`${dir}/${opts.prefix || ""}${r}${opts.postfix || ""}`);
        await Deno.mkdir(path.dirname(filepath), { recursive: true });
        const file = await Deno.open(filepath, {
            create: true,
            read: true,
            write: true,
            append: true,
        });
        return { file, filepath };
    }
    exports_169("tempFile", tempFile);
    return {
        setters: [
            function (path_1) {
                path = path_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/_util/has_own_property", [], function (exports_170, context_170) {
    "use strict";
    var __moduleName = context_170 && context_170.id;
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_170("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/mime/multipart", ["https://deno.land/std@0.61.0/bytes/mod", "https://deno.land/std@0.61.0/io/ioutil", "https://deno.land/std@0.61.0/io/readers", "https://deno.land/std@0.61.0/path/mod", "https://deno.land/std@0.61.0/io/util", "https://deno.land/std@0.61.0/io/bufio", "https://deno.land/std@0.61.0/encoding/utf8", "https://deno.land/std@0.61.0/_util/assert", "https://deno.land/std@0.61.0/textproto/mod", "https://deno.land/std@0.61.0/_util/has_own_property"], function (exports_171, context_171) {
    "use strict";
    var mod_ts_27, ioutil_ts_2, readers_ts_2, mod_ts_28, util_ts_8, bufio_ts_9, utf8_ts_12, assert_ts_17, mod_ts_29, has_own_property_ts_2, PartReader, MultipartReader, PartWriter, MultipartWriter;
    var __moduleName = context_171 && context_171.id;
    function isFormFile(x) {
        return has_own_property_ts_2.hasOwnProperty(x, "filename") && has_own_property_ts_2.hasOwnProperty(x, "type");
    }
    exports_171("isFormFile", isFormFile);
    function randomBoundary() {
        let boundary = "--------------------------";
        for (let i = 0; i < 24; i++) {
            boundary += Math.floor(Math.random() * 16).toString(16);
        }
        return boundary;
    }
    function matchAfterPrefix(buf, prefix, eof) {
        if (buf.length === prefix.length) {
            return eof ? 1 : 0;
        }
        const c = buf[prefix.length];
        if (c === " ".charCodeAt(0) ||
            c === "\t".charCodeAt(0) ||
            c === "\r".charCodeAt(0) ||
            c === "\n".charCodeAt(0) ||
            c === "-".charCodeAt(0)) {
            return 1;
        }
        return -1;
    }
    exports_171("matchAfterPrefix", matchAfterPrefix);
    function scanUntilBoundary(buf, dashBoundary, newLineDashBoundary, total, eof) {
        if (total === 0) {
            if (mod_ts_27.hasPrefix(buf, dashBoundary)) {
                switch (matchAfterPrefix(buf, dashBoundary, eof)) {
                    case -1:
                        return dashBoundary.length;
                    case 0:
                        return 0;
                    case 1:
                        return null;
                }
            }
            if (mod_ts_27.hasPrefix(dashBoundary, buf)) {
                return 0;
            }
        }
        const i = mod_ts_27.findIndex(buf, newLineDashBoundary);
        if (i >= 0) {
            switch (matchAfterPrefix(buf.slice(i), newLineDashBoundary, eof)) {
                case -1:
                    return i + newLineDashBoundary.length;
                case 0:
                    return i;
                case 1:
                    return i > 0 ? i : null;
            }
        }
        if (mod_ts_27.hasPrefix(newLineDashBoundary, buf)) {
            return 0;
        }
        const j = mod_ts_27.findLastIndex(buf, newLineDashBoundary.slice(0, 1));
        if (j >= 0 && mod_ts_27.hasPrefix(newLineDashBoundary, buf.slice(j))) {
            return j;
        }
        return buf.length;
    }
    exports_171("scanUntilBoundary", scanUntilBoundary);
    function skipLWSPChar(u) {
        const ret = new Uint8Array(u.length);
        const sp = " ".charCodeAt(0);
        const ht = "\t".charCodeAt(0);
        let j = 0;
        for (let i = 0; i < u.length; i++) {
            if (u[i] === sp || u[i] === ht)
                continue;
            ret[j++] = u[i];
        }
        return ret.slice(0, j);
    }
    function multipatFormData(fileMap, valueMap) {
        function file(key) {
            return fileMap.get(key);
        }
        function value(key) {
            return valueMap.get(key);
        }
        function* entries() {
            yield* fileMap;
            yield* valueMap;
        }
        async function removeAll() {
            const promises = [];
            for (const val of fileMap.values()) {
                if (Array.isArray(val)) {
                    for (const subVal of val) {
                        if (!subVal.tempfile)
                            continue;
                        promises.push(Deno.remove(subVal.tempfile));
                    }
                }
                else {
                    if (!val.tempfile)
                        continue;
                    promises.push(Deno.remove(val.tempfile));
                }
            }
            await Promise.all(promises);
        }
        return {
            file,
            value,
            entries,
            removeAll,
            [Symbol.iterator]() {
                return entries();
            },
        };
    }
    function checkBoundary(b) {
        if (b.length < 1 || b.length > 70) {
            throw new Error(`invalid boundary length: ${b.length}`);
        }
        const end = b.length - 1;
        for (let i = 0; i < end; i++) {
            const c = b.charAt(i);
            if (!c.match(/[a-zA-Z0-9'()+_,\-./:=?]/) || (c === " " && i !== end)) {
                throw new Error("invalid boundary character: " + c);
            }
        }
        return b;
    }
    return {
        setters: [
            function (mod_ts_27_1) {
                mod_ts_27 = mod_ts_27_1;
            },
            function (ioutil_ts_2_1) {
                ioutil_ts_2 = ioutil_ts_2_1;
            },
            function (readers_ts_2_1) {
                readers_ts_2 = readers_ts_2_1;
            },
            function (mod_ts_28_1) {
                mod_ts_28 = mod_ts_28_1;
            },
            function (util_ts_8_1) {
                util_ts_8 = util_ts_8_1;
            },
            function (bufio_ts_9_1) {
                bufio_ts_9 = bufio_ts_9_1;
            },
            function (utf8_ts_12_1) {
                utf8_ts_12 = utf8_ts_12_1;
            },
            function (assert_ts_17_1) {
                assert_ts_17 = assert_ts_17_1;
            },
            function (mod_ts_29_1) {
                mod_ts_29 = mod_ts_29_1;
            },
            function (has_own_property_ts_2_1) {
                has_own_property_ts_2 = has_own_property_ts_2_1;
            }
        ],
        execute: function () {
            PartReader = class PartReader {
                constructor(mr, headers) {
                    this.mr = mr;
                    this.headers = headers;
                    this.n = 0;
                    this.total = 0;
                }
                async read(p) {
                    const br = this.mr.bufReader;
                    let peekLength = 1;
                    while (this.n === 0) {
                        peekLength = Math.max(peekLength, br.buffered());
                        const peekBuf = await br.peek(peekLength);
                        if (peekBuf === null) {
                            throw new Deno.errors.UnexpectedEof();
                        }
                        const eof = peekBuf.length < peekLength;
                        this.n = scanUntilBoundary(peekBuf, this.mr.dashBoundary, this.mr.newLineDashBoundary, this.total, eof);
                        if (this.n === 0) {
                            assert_ts_17.assert(eof === false);
                            peekLength++;
                        }
                    }
                    if (this.n === null) {
                        return null;
                    }
                    const nread = Math.min(p.length, this.n);
                    const buf = p.subarray(0, nread);
                    const r = await br.readFull(buf);
                    assert_ts_17.assert(r === buf);
                    this.n -= nread;
                    this.total += nread;
                    return nread;
                }
                close() { }
                getContentDispositionParams() {
                    if (this.contentDispositionParams)
                        return this.contentDispositionParams;
                    const cd = this.headers.get("content-disposition");
                    const params = {};
                    assert_ts_17.assert(cd != null, "content-disposition must be set");
                    const comps = decodeURI(cd).split(";");
                    this.contentDisposition = comps[0];
                    comps
                        .slice(1)
                        .map((v) => v.trim())
                        .map((kv) => {
                        const [k, v] = kv.split("=");
                        if (v) {
                            const s = v.charAt(0);
                            const e = v.charAt(v.length - 1);
                            if ((s === e && s === '"') || s === "'") {
                                params[k] = v.substr(1, v.length - 2);
                            }
                            else {
                                params[k] = v;
                            }
                        }
                    });
                    return (this.contentDispositionParams = params);
                }
                get fileName() {
                    return this.getContentDispositionParams()["filename"];
                }
                get formName() {
                    const p = this.getContentDispositionParams();
                    if (this.contentDisposition === "form-data") {
                        return p["name"];
                    }
                    return "";
                }
            };
            MultipartReader = class MultipartReader {
                constructor(reader, boundary) {
                    this.boundary = boundary;
                    this.newLine = utf8_ts_12.encoder.encode("\r\n");
                    this.newLineDashBoundary = utf8_ts_12.encoder.encode(`\r\n--${this.boundary}`);
                    this.dashBoundaryDash = utf8_ts_12.encoder.encode(`--${this.boundary}--`);
                    this.dashBoundary = utf8_ts_12.encoder.encode(`--${this.boundary}`);
                    this.partsRead = 0;
                    this.bufReader = new bufio_ts_9.BufReader(reader);
                }
                async readForm(maxMemory = 10 << 20) {
                    const fileMap = new Map();
                    const valueMap = new Map();
                    let maxValueBytes = maxMemory + (10 << 20);
                    const buf = new Deno.Buffer(new Uint8Array(maxValueBytes));
                    for (;;) {
                        const p = await this.nextPart();
                        if (p === null) {
                            break;
                        }
                        if (p.formName === "") {
                            continue;
                        }
                        buf.reset();
                        if (!p.fileName) {
                            const n = await ioutil_ts_2.copyN(p, buf, maxValueBytes);
                            maxValueBytes -= n;
                            if (maxValueBytes < 0) {
                                throw new RangeError("message too large");
                            }
                            const value = new TextDecoder().decode(buf.bytes());
                            valueMap.set(p.formName, value);
                            continue;
                        }
                        let formFile;
                        const n = await ioutil_ts_2.copyN(p, buf, maxValueBytes);
                        const contentType = p.headers.get("content-type");
                        assert_ts_17.assert(contentType != null, "content-type must be set");
                        if (n > maxMemory) {
                            const ext = mod_ts_28.extname(p.fileName);
                            const { file, filepath } = await util_ts_8.tempFile(".", {
                                prefix: "multipart-",
                                postfix: ext,
                            });
                            try {
                                const size = await Deno.copy(new readers_ts_2.MultiReader(buf, p), file);
                                file.close();
                                formFile = {
                                    filename: p.fileName,
                                    type: contentType,
                                    tempfile: filepath,
                                    size,
                                };
                            }
                            catch (e) {
                                await Deno.remove(filepath);
                                throw e;
                            }
                        }
                        else {
                            formFile = {
                                filename: p.fileName,
                                type: contentType,
                                content: buf.bytes(),
                                size: buf.length,
                            };
                            maxMemory -= n;
                            maxValueBytes -= n;
                        }
                        if (formFile) {
                            const mapVal = fileMap.get(p.formName);
                            if (mapVal !== undefined) {
                                if (Array.isArray(mapVal)) {
                                    mapVal.push(formFile);
                                }
                                else {
                                    fileMap.set(p.formName, [mapVal, formFile]);
                                }
                            }
                            else {
                                fileMap.set(p.formName, formFile);
                            }
                        }
                    }
                    return multipatFormData(fileMap, valueMap);
                }
                async nextPart() {
                    if (this.currentPart) {
                        this.currentPart.close();
                    }
                    if (mod_ts_27.equal(this.dashBoundary, utf8_ts_12.encoder.encode("--"))) {
                        throw new Error("boundary is empty");
                    }
                    let expectNewPart = false;
                    for (;;) {
                        const line = await this.bufReader.readSlice("\n".charCodeAt(0));
                        if (line === null) {
                            throw new Deno.errors.UnexpectedEof();
                        }
                        if (this.isBoundaryDelimiterLine(line)) {
                            this.partsRead++;
                            const r = new mod_ts_29.TextProtoReader(this.bufReader);
                            const headers = await r.readMIMEHeader();
                            if (headers === null) {
                                throw new Deno.errors.UnexpectedEof();
                            }
                            const np = new PartReader(this, headers);
                            this.currentPart = np;
                            return np;
                        }
                        if (this.isFinalBoundary(line)) {
                            return null;
                        }
                        if (expectNewPart) {
                            throw new Error(`expecting a new Part; got line ${line}`);
                        }
                        if (this.partsRead === 0) {
                            continue;
                        }
                        if (mod_ts_27.equal(line, this.newLine)) {
                            expectNewPart = true;
                            continue;
                        }
                        throw new Error(`unexpected line in nextPart(): ${line}`);
                    }
                }
                isFinalBoundary(line) {
                    if (!mod_ts_27.hasPrefix(line, this.dashBoundaryDash)) {
                        return false;
                    }
                    const rest = line.slice(this.dashBoundaryDash.length, line.length);
                    return rest.length === 0 || mod_ts_27.equal(skipLWSPChar(rest), this.newLine);
                }
                isBoundaryDelimiterLine(line) {
                    if (!mod_ts_27.hasPrefix(line, this.dashBoundary)) {
                        return false;
                    }
                    const rest = line.slice(this.dashBoundary.length);
                    return mod_ts_27.equal(skipLWSPChar(rest), this.newLine);
                }
            };
            exports_171("MultipartReader", MultipartReader);
            PartWriter = class PartWriter {
                constructor(writer, boundary, headers, isFirstBoundary) {
                    this.writer = writer;
                    this.boundary = boundary;
                    this.headers = headers;
                    this.closed = false;
                    this.headersWritten = false;
                    let buf = "";
                    if (isFirstBoundary) {
                        buf += `--${boundary}\r\n`;
                    }
                    else {
                        buf += `\r\n--${boundary}\r\n`;
                    }
                    for (const [key, value] of headers.entries()) {
                        buf += `${key}: ${value}\r\n`;
                    }
                    buf += `\r\n`;
                    this.partHeader = buf;
                }
                close() {
                    this.closed = true;
                }
                async write(p) {
                    if (this.closed) {
                        throw new Error("part is closed");
                    }
                    if (!this.headersWritten) {
                        await this.writer.write(utf8_ts_12.encoder.encode(this.partHeader));
                        this.headersWritten = true;
                    }
                    return this.writer.write(p);
                }
            };
            MultipartWriter = class MultipartWriter {
                constructor(writer, boundary) {
                    this.writer = writer;
                    this.isClosed = false;
                    if (boundary !== void 0) {
                        this._boundary = checkBoundary(boundary);
                    }
                    else {
                        this._boundary = randomBoundary();
                    }
                    this.bufWriter = new bufio_ts_9.BufWriter(writer);
                }
                get boundary() {
                    return this._boundary;
                }
                formDataContentType() {
                    return `multipart/form-data; boundary=${this.boundary}`;
                }
                createPart(headers) {
                    if (this.isClosed) {
                        throw new Error("multipart: writer is closed");
                    }
                    if (this.lastPart) {
                        this.lastPart.close();
                    }
                    const part = new PartWriter(this.writer, this.boundary, headers, !this.lastPart);
                    this.lastPart = part;
                    return part;
                }
                createFormFile(field, filename) {
                    const h = new Headers();
                    h.set("Content-Disposition", `form-data; name="${field}"; filename="${filename}"`);
                    h.set("Content-Type", "application/octet-stream");
                    return this.createPart(h);
                }
                createFormField(field) {
                    const h = new Headers();
                    h.set("Content-Disposition", `form-data; name="${field}"`);
                    h.set("Content-Type", "application/octet-stream");
                    return this.createPart(h);
                }
                async writeField(field, value) {
                    const f = await this.createFormField(field);
                    await f.write(utf8_ts_12.encoder.encode(value));
                }
                async writeFile(field, filename, file) {
                    const f = await this.createFormFile(field, filename);
                    await Deno.copy(file, f);
                }
                flush() {
                    return this.bufWriter.flush();
                }
                async close() {
                    if (this.isClosed) {
                        throw new Error("multipart: writer is closed");
                    }
                    if (this.lastPart) {
                        this.lastPart.close();
                        this.lastPart = void 0;
                    }
                    await this.writer.write(utf8_ts_12.encoder.encode(`\r\n--${this.boundary}--\r\n`));
                    await this.flush();
                    this.isClosed = true;
                }
            };
            exports_171("MultipartWriter", MultipartWriter);
        }
    };
});
System.register("https://deno.land/x/multiparser@v2.0.1/deps", ["https://deno.land/std@0.61.0/http/server", "https://deno.land/std@0.61.0/mime/multipart", "https://deno.land/std@0.61.0/bytes/mod"], function (exports_172, context_172) {
    "use strict";
    var __moduleName = context_172 && context_172.id;
    return {
        setters: [
            function (server_ts_4_1) {
                exports_172({
                    "ServerRequest": server_ts_4_1["ServerRequest"]
                });
            },
            function (multipart_ts_3_1) {
                exports_172({
                    "MultipartReader": multipart_ts_3_1["MultipartReader"]
                });
            },
            function (bytes_1) {
                exports_172("bytes", bytes_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/multiparser@v2.0.1/lib/multiParser", ["https://deno.land/x/multiparser@v2.0.1/deps"], function (exports_173, context_173) {
    "use strict";
    var deps_ts_27, boundaryRegex;
    var __moduleName = context_173 && context_173.id;
    function multiParser(rawReq, maxMem = 10 << 20) {
        return new Promise(async (resolve, reject) => {
            if (rawReq?.headers?.get("content-type")) {
                const refineReq = rawReq;
                let match = refineReq.headers.get("content-type").match(boundaryRegex);
                if (!match) {
                    reject("multiParser: Invalid header");
                }
                const formBoundary = match.groups.boundary;
                const reader = new deps_ts_27.MultipartReader(refineReq.body, formBoundary);
                const formData = await reader.readForm(maxMem);
                const form = {};
                for (let [key, value] of formData.entries()) {
                    form[key] = value;
                }
                resolve(form);
            }
            else {
                reject("multiParser: no content-type header, unable to find form boundary");
            }
        });
    }
    exports_173("multiParser", multiParser);
    return {
        setters: [
            function (deps_ts_27_1) {
                deps_ts_27 = deps_ts_27_1;
            }
        ],
        execute: function () {
            boundaryRegex = /^multipart\/form-data;\sboundary=(?<boundary>.*)$/;
        }
    };
});
System.register("https://deno.land/x/multiparser@v2.0.1/lib/multiParserV2", ["https://deno.land/x/multiparser@v2.0.1/deps"], function (exports_174, context_174) {
    "use strict";
    var deps_ts_28, encoder, decoder, encode;
    var __moduleName = context_174 && context_174.id;
    async function multiParser(req, option) {
        if (req.headers.has("content-type") &&
            req.headers.get("content-type")?.startsWith("multipart/form-data")) {
            let buf = await Deno.readAll(req.body);
            let boundaryByte = getBoundary(req.headers.get("content-type"));
            if (!boundaryByte) {
                return undefined;
            }
            const pieces = getFieldPieces(buf, boundaryByte);
            const form = getForm(pieces);
            return form;
        }
        else {
            return undefined;
        }
    }
    exports_174("multiParser", multiParser);
    function getForm(pieces) {
        let form = { fields: {}, files: {} };
        for (let piece of pieces) {
            const { headerByte, contentByte } = splitPiece(piece);
            const headers = getHeaders(headerByte);
            if (typeof headers === "string") {
                if (contentByte.byteLength === 1 && contentByte[0] === 13) {
                    continue;
                }
                else {
                    form.fields[headers] = decoder.decode(contentByte);
                }
            }
            else {
                let file = {
                    name: headers.name,
                    filename: headers.filename,
                    contentType: headers.contentType,
                    size: contentByte.byteLength,
                    content: contentByte,
                };
                if (form.files[headers.name] instanceof Array) {
                    form.files[headers.name].push(file);
                }
                else if (form.files[headers.name]) {
                    form.files[headers.name] = [form.files[headers.name], file];
                }
                else {
                    form.files[headers.name] = file;
                }
            }
        }
        return form;
    }
    function getHeaders(headerByte) {
        let contentTypeIndex = deps_ts_28.bytes.findIndex(headerByte, encode.contentType);
        if (contentTypeIndex < 0) {
            return getNameOnly(headerByte);
        }
        else {
            return getHeaderNContentType(headerByte, contentTypeIndex);
        }
    }
    function getHeaderNContentType(headerByte, contentTypeIndex) {
        let headers = {};
        let contentDispositionByte = headerByte.slice(0, contentTypeIndex - 2);
        headers = getHeaderOnly(contentDispositionByte);
        let contentTypeByte = headerByte.slice(contentTypeIndex + encode.contentType.byteLength + 2);
        headers.contentType = decoder.decode(contentTypeByte);
        return headers;
    }
    function getHeaderOnly(headerLineByte) {
        let headers = {};
        let filenameIndex = deps_ts_28.bytes.findIndex(headerLineByte, encode.filename);
        if (filenameIndex < 0) {
            headers.name = getNameOnly(headerLineByte);
        }
        else {
            headers = getNameNFilename(headerLineByte, filenameIndex);
        }
        return headers;
    }
    function getNameNFilename(headerLineByte, filenameIndex) {
        let nameByte = headerLineByte.slice(0, filenameIndex - 2);
        let filenameByte = headerLineByte.slice(filenameIndex + encode.filename.byteLength + 2, headerLineByte.byteLength - 1);
        let name = getNameOnly(nameByte);
        let filename = decoder.decode(filenameByte);
        return { name, filename };
    }
    function getNameOnly(headerLineByte) {
        let nameIndex = deps_ts_28.bytes.findIndex(headerLineByte, encode.name);
        let nameByte = headerLineByte.slice(nameIndex + encode.name.byteLength + 2, headerLineByte.byteLength - 1);
        return decoder.decode(nameByte);
    }
    function splitPiece(piece) {
        const contentIndex = deps_ts_28.bytes.findIndex(piece, encode.returnNewline2);
        const headerByte = piece.slice(0, contentIndex);
        const contentByte = piece.slice(contentIndex + 4);
        return { headerByte, contentByte };
    }
    function getFieldPieces(buf, boundaryByte) {
        const startBoundaryByte = deps_ts_28.bytes.concat(encode.dashdash, boundaryByte);
        const endBoundaryByte = deps_ts_28.bytes.concat(startBoundaryByte, encode.dashdash);
        const pieces = [];
        while (!deps_ts_28.bytes.hasPrefix(buf, endBoundaryByte)) {
            buf = buf.slice(startBoundaryByte.byteLength + 2);
            let boundaryIndex = deps_ts_28.bytes.findIndex(buf, startBoundaryByte);
            pieces.push(buf.slice(0, boundaryIndex - 1));
            buf = buf.slice(boundaryIndex);
        }
        return pieces;
    }
    function getBoundary(contentType) {
        let contentTypeByte = encoder.encode(contentType);
        let boundaryIndex = deps_ts_28.bytes.findIndex(contentTypeByte, encode.boundaryEqual);
        if (boundaryIndex >= 0) {
            let boundary = contentTypeByte.slice(boundaryIndex + encode.boundaryEqual.byteLength);
            return boundary;
        }
        else {
            return undefined;
        }
    }
    return {
        setters: [
            function (deps_ts_28_1) {
                deps_ts_28 = deps_ts_28_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            decoder = new TextDecoder();
            encode = {
                contentType: encoder.encode("Content-Type"),
                filename: encoder.encode("filename"),
                name: encoder.encode("name"),
                dashdash: encoder.encode("--"),
                boundaryEqual: encoder.encode("boundary="),
                returnNewline2: encoder.encode("\r\n\r\n"),
                carriageReturn: encoder.encode("\r"),
            };
        }
    };
});
System.register("https://deno.land/x/multiparser@v2.0.1/mod", ["https://deno.land/x/multiparser@v2.0.1/lib/multiParser", "https://deno.land/x/multiparser@v2.0.1/lib/multiParserV2"], function (exports_175, context_175) {
    "use strict";
    var __moduleName = context_175 && context_175.id;
    return {
        setters: [
            function (multiParser_ts_1_1) {
                exports_175({
                    "multiParser": multiParser_ts_1_1["multiParser"]
                });
            },
            function (multiParserV2_ts_1_1) {
                exports_175({
                    "multiParserV2": multiParserV2_ts_1_1["multiParser"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/isucon/isuumo/webapp/deno/app", ["https://deno.land/x/oak@v6.1.0/mod", "https://deno.land/x/mysql@v2.4.0/mod", "https://deno.land/std@0.68.0/fmt/printf", "https://raw.githubusercontent.com/denjucks/organ/master/mod", "https://deno.land/x/case@v2.1.0/mod", "https://deno.land/std@0.68.0/encoding/csv", "https://deno.land/x/multiparser@v2.0.1/mod"], function (exports_176, context_176) {
    "use strict";
    var mod_ts_30, mod_ts_31, printf_ts_1, mod_ts_32, mod_ts_33, csv_ts_1, mod_ts_34, currentEnv, decoder, PORT, LIMIT, NAZOTTE_LIMIT, dbinfo, chairSearchConditionJson, chairSearchCondition, estateSearchConditionJson, estateSearchCondition, db, camelcaseKeys, router, app;
    var __moduleName = context_176 && context_176.id;
    return {
        setters: [
            function (mod_ts_30_1) {
                mod_ts_30 = mod_ts_30_1;
            },
            function (mod_ts_31_1) {
                mod_ts_31 = mod_ts_31_1;
            },
            function (printf_ts_1_1) {
                printf_ts_1 = printf_ts_1_1;
            },
            function (mod_ts_32_1) {
                mod_ts_32 = mod_ts_32_1;
            },
            function (mod_ts_33_1) {
                mod_ts_33 = mod_ts_33_1;
            },
            function (csv_ts_1_1) {
                csv_ts_1 = csv_ts_1_1;
            },
            function (mod_ts_34_1) {
                mod_ts_34 = mod_ts_34_1;
            }
        ],
        execute: async function () {
            currentEnv = Deno.env.toObject();
            decoder = new TextDecoder();
            PORT = currentEnv.PORT ?? 1323;
            LIMIT = 20;
            NAZOTTE_LIMIT = 50;
            dbinfo = {
                hostname: currentEnv.MYSQL_HOST ?? "127.0.0.1",
                port: parseInt(currentEnv.MYSQL_PORT ?? 3306),
                username: currentEnv.MYSQL_USER ?? "isucon",
                password: currentEnv.MYSQL_PASS ?? "isucon",
                db: currentEnv.MYSQL_DBNAME ?? "isuumo",
                poolSize: 10,
                debug: true,
            };
            chairSearchConditionJson = await Deno.readFile("../fixture/chair_condition.json");
            chairSearchCondition = JSON.parse(decoder.decode(chairSearchConditionJson));
            estateSearchConditionJson = await Deno.readFile("../fixture/estate_condition.json");
            estateSearchCondition = JSON.parse(decoder.decode(estateSearchConditionJson));
            db = await new mod_ts_31.Client().connect(dbinfo);
            camelcaseKeys = (obj) => Object.fromEntries(Object.entries(obj).map(([k, v]) => [mod_ts_33.camelCase(k), v]));
            router = new mod_ts_30.Router();
            router.post("/initialize", async (ctx) => {
                const dbdir = "../mysql/db";
                const dbfiles = [
                    "0_Schema.sql",
                    "1_DummyEstateData.sql",
                    "2_DummyChairData.sql",
                ];
                const execfiles = dbfiles.map((file) => `${dbdir}/${file}`);
                for (const execfile of execfiles) {
                    const p = Deno.run({
                        cmd: [
                            "bash",
                            "-c",
                            `mysql -h ${dbinfo.hostname} -u ${dbinfo.username} -p${dbinfo.password} -P ${dbinfo.port} ${dbinfo.db} < ${execfile}`,
                        ],
                    });
                    const status = await p.status();
                    if (!status.success) {
                        const output = await p.output();
                        throw new Error("Deno run is failed " + output);
                    }
                }
                ctx.response.body = {
                    language: "deno",
                };
            });
            router.get("/api/estate/low_priced", async (ctx) => {
                const es = await db.query("SELECT * FROM estate ORDER BY rent ASC, id ASC LIMIT ?", [LIMIT]);
                ctx.response.body = { estates: es.map(camelcaseKeys) };
            });
            router.get("/api/chair/low_priced", async (ctx) => {
                try {
                    const cs = await db.query("SELECT * FROM chair WHERE stock > 0 ORDER BY price ASC, id ASC LIMIT ?", [LIMIT]);
                    ctx.response.body = { chairs: cs.map(camelcaseKeys) };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.get("/api/chair/search", async (ctx, next) => {
                const searchQueries = [];
                const queryParams = [];
                const { priceRangeId, heightRangeId, widthRangeId, depthRangeId, kind, color, features, page, perPage, } = mod_ts_30.helpers.getQuery(ctx);
                if (!!priceRangeId) {
                    const chairPrice = chairSearchCondition["price"].ranges[priceRangeId];
                    if (chairPrice == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "priceRangeID invalid";
                        return;
                    }
                    if (chairPrice.min !== -1) {
                        searchQueries.push("price >= ? ");
                        queryParams.push(chairPrice.min);
                    }
                    if (chairPrice.max !== -1) {
                        searchQueries.push("price < ? ");
                        queryParams.push(chairPrice.max);
                    }
                }
                if (!!heightRangeId) {
                    const chairHeight = chairSearchCondition["height"].ranges[heightRangeId];
                    if (chairHeight == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "heightRangeId invalid";
                        return;
                    }
                    if (chairHeight.min !== -1) {
                        searchQueries.push("height >= ? ");
                        queryParams.push(chairHeight.min);
                    }
                    if (chairHeight.max !== -1) {
                        searchQueries.push("height < ? ");
                        queryParams.push(chairHeight.max);
                    }
                }
                if (!!widthRangeId) {
                    const chairWidth = chairSearchCondition["width"].ranges[widthRangeId];
                    if (chairWidth == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "widthRangeId invalid";
                        return;
                    }
                    if (chairWidth.min !== -1) {
                        searchQueries.push("width >= ? ");
                        queryParams.push(chairWidth.min);
                    }
                    if (chairWidth.max !== -1) {
                        searchQueries.push("width < ? ");
                        queryParams.push(chairWidth.max);
                    }
                }
                if (!!depthRangeId) {
                    const chairDepth = chairSearchCondition["depth"].ranges[depthRangeId];
                    if (chairDepth == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "depthRangeId invalid";
                        return;
                    }
                    if (chairDepth.min !== -1) {
                        searchQueries.push("depth >= ? ");
                        queryParams.push(chairDepth.min);
                    }
                    if (chairDepth.max !== -1) {
                        searchQueries.push("depth < ? ");
                        queryParams.push(chairDepth.max);
                    }
                }
                if (!!kind) {
                    searchQueries.push("kind = ? ");
                    queryParams.push(kind);
                }
                if (!!color) {
                    searchQueries.push("color = ? ");
                    queryParams.push(color);
                }
                if (!!features) {
                    const featureConditions = features.split(",");
                    for (const featureCondition of featureConditions) {
                        searchQueries.push("features LIKE ?");
                        queryParams.push(`%${featureCondition}%`);
                    }
                }
                if (searchQueries.length === 0) {
                    ctx.response.status = 400;
                    ctx.response.body = "Search condition not found";
                    return;
                }
                searchQueries.push("stock > 0");
                const pageNum = parseInt(page, 10);
                const perPageNum = parseInt(perPage, 10);
                if (!page || Number.isNaN(pageNum)) {
                    ctx.response.status = 400;
                    ctx.response.body = `page condition invalid ${page}`;
                    return;
                }
                if (!perPage || Number.isNaN(perPageNum)) {
                    ctx.response.status = 400;
                    ctx.response.body = `perPage condition invalid ${perPage}`;
                    return;
                }
                const sqlprefix = "SELECT * FROM chair WHERE ";
                const searchCondition = searchQueries.join(" AND ");
                const limitOffset = " ORDER BY popularity DESC, id ASC LIMIT ? OFFSET ?";
                const countprefix = "SELECT COUNT(*) as count FROM chair WHERE ";
                try {
                    const [{ count }] = await db.query(`${countprefix}${searchCondition}`, queryParams);
                    queryParams.push(perPageNum, perPageNum * pageNum);
                    const cs = await db.query(`${sqlprefix}${searchCondition}${limitOffset}`, queryParams);
                    const chairs = cs.map(camelcaseKeys);
                    ctx.response.body = {
                        count,
                        chairs,
                    };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.get("/api/chair/search/condition", (ctx) => {
                ctx.response.body = chairSearchCondition;
            });
            router.get("/api/chair/:id", async (ctx) => {
                try {
                    const id = ctx.params.id;
                    const [chair] = await db.query("SELECT * FROM chair WHERE id = ?", [id]);
                    if (chair == null || chair.stock <= 0) {
                        ctx.response.status = 404;
                        ctx.response.body = "Not Found";
                        return;
                    }
                    ctx.response.body = camelcaseKeys(chair);
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.post("/api/chair/buy/:id", async (ctx) => {
                try {
                    const id = ctx.params.id;
                    await db.transaction(async (conn) => {
                        const result = await conn.execute("SELECT * FROM chair WHERE id = ? AND stock > 0 FOR UPDATE", [id]);
                        if (result.rows?.[0] == null) {
                            ctx.response.status = 404;
                            ctx.response.body = "Not Found";
                            await conn.execute("ROLLBACK");
                            return;
                        }
                        const chair = result.rows[0];
                        await conn.execute("UPDATE chair SET stock = ? WHERE id = ?", [chair.stock - 1, id]);
                    });
                    ctx.response.body = { ok: true };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.get("/api/estate/search", async (ctx) => {
                const searchQueries = [];
                const queryParams = [];
                const { doorHeightRangeId, doorWidthRangeId, rentRangeId, features, page, perPage, } = mod_ts_30.helpers.getQuery(ctx);
                if (!!doorHeightRangeId) {
                    const doorHeight = estateSearchCondition["doorHeight"].ranges[doorHeightRangeId];
                    if (doorHeight == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "doorHeightRangeId invalid";
                        return;
                    }
                    if (doorHeight.min !== -1) {
                        searchQueries.push("door_height >= ? ");
                        queryParams.push(doorHeight.min);
                    }
                    if (doorHeight.max !== -1) {
                        searchQueries.push("door_height < ? ");
                        queryParams.push(doorHeight.max);
                    }
                }
                if (!!doorWidthRangeId) {
                    const doorWidth = estateSearchCondition["doorWidth"].ranges[doorWidthRangeId];
                    if (doorWidth == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "doorWidthRangeId invalid";
                        return;
                    }
                    if (doorWidth.min !== -1) {
                        searchQueries.push("door_width >= ? ");
                        queryParams.push(doorWidth.min);
                    }
                    if (doorWidth.max !== -1) {
                        searchQueries.push("door_width < ? ");
                        queryParams.push(doorWidth.max);
                    }
                }
                if (!!rentRangeId) {
                    const rent = estateSearchCondition["rent"].ranges[rentRangeId];
                    if (rent == null) {
                        ctx.response.status = 400;
                        ctx.response.body = "rentRangeId invalid";
                        return;
                    }
                    if (rent.min !== -1) {
                        searchQueries.push("rent >= ? ");
                        queryParams.push(rent.min);
                    }
                    if (rent.max !== -1) {
                        searchQueries.push("rent < ? ");
                        queryParams.push(rent.max);
                    }
                }
                if (!!features) {
                    const featureConditions = features.split(",");
                    for (const featureCondition of featureConditions) {
                        searchQueries.push("features LIKE ?");
                        queryParams.push(`%${featureCondition}%`);
                    }
                }
                if (searchQueries.length === 0) {
                    ctx.response.status = 400;
                    ctx.response.body = "Search condition not found";
                    return;
                }
                const pageNum = parseInt(page, 10);
                const perPageNum = parseInt(perPage, 10);
                if (!page || Number.isNaN(pageNum)) {
                    ctx.response.status = 400;
                    ctx.response.body = `page condition invalid ${page}`;
                    return;
                }
                if (!perPage || Number.isNaN(perPageNum)) {
                    ctx.response.status = 400;
                    ctx.response.body = `perPage condition invalid ${perPage}`;
                    return;
                }
                const sqlprefix = "SELECT * FROM estate WHERE ";
                const searchCondition = searchQueries.join(" AND ");
                const limitOffset = " ORDER BY popularity DESC, id ASC LIMIT ? OFFSET ?";
                const countprefix = "SELECT COUNT(*) as count FROM estate WHERE ";
                try {
                    const [{ count }] = await db.query(`${countprefix}${searchCondition}`, queryParams);
                    queryParams.push(perPageNum, perPageNum * pageNum);
                    const estates = await db.query(`${sqlprefix}${searchCondition}${limitOffset}`, queryParams);
                    ctx.response.body = {
                        count,
                        estates: estates.map(camelcaseKeys),
                    };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.get("/api/estate/search/condition", (ctx) => {
                ctx.response.body = estateSearchCondition;
            });
            router.post("/api/estate/req_doc/:id", async (ctx) => {
                const id = ctx.params.id;
                const [estate] = await db.query("SELECT * FROM estate WHERE id = ?", [id]);
                if (estate == null) {
                    ctx.response.status = 404;
                    ctx.response.body = "Not Found";
                    return;
                }
                ctx.response.body = { ok: true };
            });
            router.post("/api/estate/nazotte", async (ctx) => {
                const result = ctx.request.body();
                let coordinates;
                if (result.type === "json") {
                    const val = await result.value;
                    coordinates = val.coordinates;
                }
                const longitudes = coordinates.map((c) => c.longitude);
                const latitudes = coordinates.map((c) => c.latitude);
                const boundingbox = {
                    topleft: {
                        longitude: Math.min(...longitudes),
                        latitude: Math.min(...latitudes),
                    },
                    bottomright: {
                        longitude: Math.max(...longitudes),
                        latitude: Math.max(...latitudes),
                    },
                };
                try {
                    const estates = await db.query("SELECT * FROM estate WHERE latitude <= ? AND latitude >= ? AND longitude <= ? AND longitude >= ? ORDER BY popularity DESC, id ASC", [
                        boundingbox.bottomright.latitude,
                        boundingbox.topleft.latitude,
                        boundingbox.bottomright.longitude,
                        boundingbox.topleft.longitude,
                    ]);
                    const estatesInPolygon = [];
                    for (const estate of estates) {
                        const point = printf_ts_1.sprintf("'POINT(%f %f)'", estate.latitude, estate.longitude);
                        const sql = "SELECT * FROM estate WHERE id = ? AND ST_Contains(ST_PolygonFromText(%s), ST_GeomFromText(%s))";
                        const coordinatesToText = printf_ts_1.sprintf("'POLYGON((%s))'", coordinates.map((coordinate) => printf_ts_1.sprintf("%f %f", coordinate.latitude, coordinate.longitude)).join(","));
                        const sqlstr = printf_ts_1.sprintf(sql, coordinatesToText, point);
                        const [e] = await db.query(sqlstr, [estate.id]);
                        if (e && Object.keys(e).length > 0) {
                            estatesInPolygon.push(e);
                        }
                    }
                    const results = {
                        count: 0,
                        estates: [],
                    };
                    let i = 0;
                    for (const estate of estatesInPolygon) {
                        if (i >= NAZOTTE_LIMIT) {
                            break;
                        }
                        results.estates.push(camelcaseKeys(estate));
                        i++;
                    }
                    results.count = results.estates.length;
                    ctx.response.body = results;
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.get("/api/estate/:id", async (ctx) => {
                try {
                    const id = ctx.params.id;
                    const [estate] = await db.query("SELECT * FROM estate WHERE id = ?", [id]);
                    if (estate == null) {
                        ctx.response.status = 404;
                        ctx.response.body = "Estate Not Found";
                        return;
                    }
                    ctx.response.body = camelcaseKeys(estate);
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.post("/api/estate/req_doc/:id", async (ctx) => {
                const id = ctx.params.id;
                const [estate] = await db.query("SELECT * FROM estate WHERE id = ?", [id]);
                if (estate == null) {
                    ctx.response.status = 404;
                    ctx.response.body = "Not Found";
                    return;
                }
                ctx.response.body = { ok: true };
            });
            router.get("/api/recommended_estate/:id", async (ctx) => {
                try {
                    const id = ctx.params.id;
                    const [chair] = await db.query("SELECT * FROM chair WHERE id = ?", [id]);
                    const w = chair.width;
                    const h = chair.height;
                    const d = chair.depth;
                    const es = await db.query("SELECT * FROM estate where (door_width >= ? AND door_height>= ?) OR (door_width >= ? AND door_height>= ?) OR (door_width >= ? AND door_height>=?) OR (door_width >= ? AND door_height>=?) OR (door_width >= ? AND door_height>=?) OR (door_width >= ? AND door_height>=?) ORDER BY popularity DESC, id ASC LIMIT ?", [
                        w,
                        h,
                        w,
                        d,
                        h,
                        w,
                        h,
                        d,
                        d,
                        w,
                        d,
                        h,
                        LIMIT,
                    ]);
                    ctx.response.body = { estates: es.map(camelcaseKeys) };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.post("/api/chair", async (ctx) => {
                try {
                    const form = await mod_ts_34.multiParser(ctx.request.serverRequest);
                    if (!form || !form.chairs) {
                        ctx.response.status = 400;
                        ctx.response.body = "Bad Request";
                        return;
                    }
                    const content = decoder.decode(form.chairs.content);
                    const csv = await csv_ts_1.parse(content);
                    await db.transaction(async (conn) => {
                        for (let i = 0; i < csv.length; i++) {
                            const items = csv[i];
                            await conn.execute("INSERT INTO chair(id, name, description, thumbnail, price, height, width, depth, color, features, kind, popularity, stock) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?)", items);
                        }
                    });
                    ctx.response.status = 201;
                    ctx.response.body = { ok: true };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            router.post("/api/estate", async (ctx) => {
                try {
                    const form = await mod_ts_34.multiParser(ctx.request.serverRequest);
                    if (!form || !form.estates) {
                        ctx.response.status = 400;
                        ctx.response.body = "Bad Request";
                        return;
                    }
                    const content = decoder.decode(form.estates.content);
                    const csv = await csv_ts_1.parse(content);
                    await db.transaction(async (conn) => {
                        for (let i = 0; i < csv.length; i++) {
                            const items = csv[i];
                            await conn.execute("INSERT INTO estate(id, name, description, thumbnail, address, latitude, longitude, rent, door_height, door_width, features, popularity) VALUES(?,?,?,?,?,?,?,?,?,?,?,?)", items);
                        }
                    });
                    ctx.response.status = 201;
                    ctx.response.body = { ok: true };
                }
                catch (e) {
                    ctx.response.status = 500;
                    ctx.response.body = e.toString();
                }
            });
            app = new mod_ts_30.Application();
            app.use(mod_ts_32.organ());
            app.use(router.routes());
            app.use(router.allowedMethods());
            console.log(`Listening ${PORT}`);
            await app.listen({ port: +PORT });
            await db.close();
        }
    };
});

await __instantiate("file:///home/isucon/isuumo/webapp/deno/app", true);

